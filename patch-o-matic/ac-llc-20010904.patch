Index: kernel-acme/include/linux/af_netb.h
diff -c /dev/null kernel-acme/include/linux/af_netb.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:20 2001
--- kernel-acme/include/linux/af_netb.h	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,228 ----
+ #ifndef _LINUX_AF_NETB_H
+ #define _LINUX_AF_NETB_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/sockios.h>
+ 
+ /* General definitions */
+ #define NETBEUI_MAX_DATALEN  (64 * 1024) /* 64K-bytes max data buffer len */
+ #define NETBEUI_MAX_NAMES    255      /* Maximum number of local names */
+ #define NETBEUI_MAX_ADAPTERS 16	      /* Maximum number of local adapters */
+ #define NETBEUI_MAX_LINKS    256      /* Maximum number of links to others */
+ #define NETBEUI_MAX_SESSIONS 255      /* Maximum number of sessions on a link */
+ 
+ #define SOCK_NAME	SOCK_RAW    /* Socket type for Name registration */
+ #define NETBEUI_NAME_LEN 16
+ 
+ /* NetBEUI address type definitions */
+ typedef enum {
+ 	NETBEUI_NAME_UNIQUE = 1,
+ 	NETBEUI_NAME_GROUP
+ } name_type_t;
+ 
+ struct netbeui_addr {
+ 	char		name[NETBEUI_NAME_LEN];
+ 	unsigned char	reserved;	/* Safety region */
+ 	name_type_t	name_type;
+ };
+ 
+ /* Maximum permitted length of this structure is MAX_SOCK_ADDR defined in
+  * 'net/socket.c' */
+ struct sockaddr_netbeui {
+ 	unsigned short		snb_family;         /* s.b. AF_NETBEUI */
+ 	struct netbeui_addr	snb_addr;
+ };
+ 
+ /* NetBEUI Socket Layer Default Values */
+ #define NBSO_DFLT_STO_SEC    0 /* Seconds of 'Send Time Out' value */
+ #define NBSO_DFLT_STO_MICSEC 0 /* Micro-Seconds of 'Send Time Out' value */
+ 
+ #define NBSO_DFLT_RTO_SEC    0 /* Seconds of 'Receive Time Out' value */
+ #define NBSO_DFLT_RTO_MICSEC 0 /* Micro-Seconds of 'Receive Time Out' value */
+ 
+ /* Macro definitions */
+ /*
+  * Macro to set up NETBEUI SOCKADDRs.
+  *
+  * _snb  : pointer to a 'struct sockaddr_netbeui'.
+  * _type : type of NetBIOS name.
+  * _name : a NULL terminated char string.
+  * _port : port number that will be located at end of NetBIOS name.
+  */
+ #define SET_NETBEUI_SOCKADDR(_snb, _type, _name, _port)			\
+ {									\
+ 	int _i;								\
+ 	(_snb)->snb_family = AF_NETBEUI;				\
+ 	(_snb)->snb_addr.name_type = (_type);				\
+ 	for (_i = 0; _i < NETBEUI_NAME_LEN - 1; _i++) {			\
+ 		(_snb)->snb_addr.name[_i] = ' ';			\
+ 	}								\
+ 	for (_i = 0; (*((_name) + _i) != '\0') && 			\
+ 		      (_i < NETBEUI_NAME_LEN-1); _i++) {		\
+ 		(_snb)->snb_addr.name[_i] = *((_name) + _i);		\
+ 	}								\
+ 	(_snb)->snb_addr.name[NETBEUI_NAME_LEN - 1] = (_port);		\
+ 	(_snb)->snb_addr.reserved = 0;					\
+ }
+ 
+ /* NetBEUI ioctls */
+ /* From 0x89E0 to 0x89EF are protocol private 'ioctl numbers'                 *\
+  * For more information see  SIOCDEVPRIVATE and SIOCPROTOPRIVATE  definitions *
+ \* in 'include/linux/sockios.h' file                                          */
+ 
+ /* NetBEUI specific I/O ConTroL calls (ioctl) */
+ #define SIOCGSTATE   (SIOCPROTOPRIVATE)     /* Gets NetBEUI socket state */
+ #define SIOCTRIMDATA (SIOCPROTOPRIVATE + 1) /* Trims last bytes of current
+ 					       message */
+ #define SIOCSENDZERO (SIOCPROTOPRIVATE + 2) /* Send a dummy session message with
+ 					       zero size */
+ #define SIOCRUWDGF   (SIOCPROTOPRIVATE + 3) /* Removes an UnWanted DataGram
+ 					       Frames */
+ #define NBIOCGSTATUS (SIOCPROTOPRIVATE + 4) /* Gets NetBIOS STATUS of local or
+ 					       remote node */
+ #define NBIOCCONFIG  (SIOCPROTOPRIVATE + 5) /* Configures NetBEUI during
+ 					       running */
+ /* NetBEUI 'SIOCGSTATE' ioctl() Constants */
+ typedef enum {
+ 	NBSO_INIT = 0,
+ 	NBSO_LISTENING,
+ 	NBSO_RUNNING
+ } nbso_state_t;
+ 
+ /* NetBEUI Configuration (via NBIOCCONFIG ioctl) */
+ /* NetBEUI Configuration request constants */
+ #define NETBEUI_MAX_NIF_NAME_LEN 16 /* Maximum of Net InterFace Name Length */
+ #define NETBEUI_UNBIND_FLAG_SAFE  0 /* Unbinds device only if no connection
+ 				       exist on it */
+ #define NETBEUI_UNBIND_FLAG_DROP  1 /* Drops connections that exist on device
+ 				       and then unbinds it */
+ #define NETBEUI_CFGCMD_NIF_UNBIND 0
+ #define NETBEUI_CFGCMD_NIF_BIND   1
+ #define NETBEUI_CFGCMD_DROP_SESS  2
+ #define NETBEUI_CFGCMD_DROP_LINK  3
+ 
+ /* NetBEUI Configuration request data structure */
+ struct netbeui_cfg {
+ 	unsigned short	command;	/* NETBEUI_CFGCMD_... */
+ 	char		nif_name[NETBEUI_MAX_NIF_NAME_LEN];
+ 	unsigned char	reserved;	/* Safety region, always must be zero */
+ 	unsigned char	flag;		/* NETBEUI_UNBIND_FLAG_... */
+ 	int		ln_num;		/* 0 <= ln_num < NETBEUI_MAX_LINKS */
+ 	int		sn_num;		/* 0 < sn_num < NETBEUI_MAX_SESSIONS */
+ };
+ 
+ /* NetBEUI setsockopt / getsockopt */
+ /*
+  * NetBEUI specific level definitions for setsockopt() & getsockopt() 
+  *
+  * Note: SOL_SOCKET defined in 'include/asm/socket.h' to 1
+  *       and other protocol constants defined in 'include/linux/socket.h'
+  */
+ #define SOL_NETBEUI 300
+ /*
+  * NetBEUI specific option names for setsockopt() & getsockopt()
+  *
+  * Note: Remainder of option names defined in 'asm/socket.h' from 1 to 15
+  */
+ #define SO_URGENTACK 106	
+ #define SO_NBPARAM   107
+ 
+ /*
+  * NetBEUI configurable parameters use by SO_NBPARAM
+  *
+  * Note: Setting value of a parameter to zero means no change to the
+  *	 current value.
+  */
+ struct netbeui_config {
+ 	__u8 inactivity_timeout;
+ 	__u8 transmit_timeout;
+ 	__u8 transmit_count;
+ 	__u8 resource_timeout;
+ 	__u8 data_ack_timeout;
+ };
+ 
+ /* Definition of default and maximum value of NetBIOS configurable parameters */
+ #define DEFAULT_LINK_INACTIVITY_TIMEOUT	30	/* Unit is second */
+ #define MAX_LINK_INACTIVITY_TIMEOUT	255	/* Unit is second */
+ #define DEFAULT_TRANSMIT_TIMEOUT	1	/* Unit is 1/2 second */
+ #define MAX_TRANSMIT_TIMEOUT		10	/* Unit is 1/2 second */
+ #define DEFAULT_TRANSMIT_COUNT		6
+ #define MAX_TRANSMIT_COUNT		10
+ #define DEFAULT_RESOURCE_TIMEOUT	1	/* Unit is 1/10 second */
+ #define MAX_RESOURCE_TIMEOUT		10	/* Unit is 1/10 second */
+ #define DEFAULT_DATA_ACK_TIMEOUT	1	/* Unit is 1/10 second */
+ #define MAX_DATA_ACK_TIMEOUT		10	/* Unit is 1/10 second */
+ 
+ /* NetBEUI STATUS Service */
+ /* NetBEUI status service constants */
+ #define NETBEUI_MIN_STATUS_BUFF_LEN 60
+ #define NETBEUI_MAX_STATUS_BUFF_LEN (NETBEUI_MIN_STATUS_BUFF_LEN + \
+ 				     18 * NETBEUI_MAX_NAMES)
+ 
+ /* NetBEUI STATUS request data structure */
+ struct netbeui_status {
+ 	char called_name[NETBEUI_NAME_LEN];
+ 	char reserved;       /* Safety region, always must be zero */
+ 	int  buff_len;
+ 	char status_buff[0]; /* A dynamic length array for status information */
+ };
+ 
+ /* Adapter types in status information */
+ enum {
+ 	_3174_PEER = 0xFB,
+ 	IBM_FDDI,
+ 	ETHERNET,
+ 	PC_NETWORK,
+ 	TOKEN_RING
+ };
+ 
+ /* Name structure in status information */
+ struct nb_status_names {
+ 	char	name[NETBEUI_NAME_LEN];
+ 	__u8	name_number;
+ 	__u8	name_status;
+ };
+ 
+ /* STATUS information structure */
+ typedef struct {
+ 	__u8	adptr_addr[6];
+ 	__u8	sftwr_release_no;
+ 	__u8	zero;
+ 	struct {
+ 		__u8	adptr_type;
+ 		__u8	sftwr_level;
+ 	}	adptr_type_AND_sftwr_level;
+ 	__u16	duration;
+ 	__u16	no_rx_FRMR;			/* NOT SUPPORTED YET */
+ 	__u16	no_tx_FRMR;			/* NOT SUPPORTED YET */
+ 	__u16	no_rx_Iformat_LPDUs;		/* NOT SUPPORTED YET */
+ 	__u16	no_abrtd_transmissions;		/* NOT SUPPORTED YET */
+ 	__u32	no_succ_tx_packets;		/* NOT SUPPORTED YET */
+ 	__u32	no_succ_rx_packets;		/* NOT SUPPORTED YET */
+ 	__u16	no_tx_Iformat_LPDUs;		/* NOT SUPPORTED YET */
+ 	__u16	lost_data_OR_buff_fails;	/* NOT SUPPORTED YET */
+ 	__u16	no_DLC_T1_expired;		/* NOT SUPPORTED YET */
+ 	__u16	no_DLC_Ti_expired;		/* NOT SUPPORTED YET */
+ 	__u32	ext_status_inf_addr;		/* NOT SUPPORTED YET */
+ 	__u16	no_free_NCBs;			/* NOT SUPPORTED YET */
+ 	__u16	config_max_NCBs;		/* NOT SUPPORTED YET */
+ 	__u16	max_no_NCBs;			/* NOT SUPPORTED YET */
+ 	__u16	local_busy_OR_buff_fails;	/* NOT SUPPORTED YET */
+ 	__u16	max_dgram_packet_size;
+ 	__u16	no_pend_sess;			/* NOT SUPPORTED YET */
+ 	__u16	config_max_pend_sess;		/* NOT SUPPORTED YET */
+ 	__u16	max_no_pend_sess;
+ 	__u16	max_size_sess_data_packet;
+ 	__u16	no_names_in_local_name_tbl;
+ 	struct nb_status_names local_names[NETBEUI_MAX_NAMES];
+ } nb_status_buffer_t;
+ #endif /* _LINUX_AF_NETB_H */
Index: kernel-acme/include/linux/brlock.h
diff -c kernel-acme/include/linux/brlock.h:1.1.1.1 kernel-acme/include/linux/brlock.h:1.1.1.1.4.1
*** kernel-acme/include/linux/brlock.h:1.1.1.1	Tue Jun 26 14:34:01 2001
--- kernel-acme/include/linux/brlock.h	Wed Aug 22 16:21:39 2001
***************
*** 28,40 ****
   * load-locked/store-conditional cpus (ALPHA/MIPS/PPC) and
   * compare-and-swap cpus (Sparc64).  So we control which
   * implementation to use with a __BRLOCK_USE_ATOMICS define. -DaveM
   */
  
  /* Register bigreader lock indices here. */
  enum brlock_indices {
  	BR_GLOBALIRQ_LOCK,
  	BR_NETPROTO_LOCK,
! 
  	__BR_END
  };
  
--- 28,44 ----
   * load-locked/store-conditional cpus (ALPHA/MIPS/PPC) and
   * compare-and-swap cpus (Sparc64).  So we control which
   * implementation to use with a __BRLOCK_USE_ATOMICS define. -DaveM
+  *
+  * Added BR_8022_LOCK for use in net/core/ext8022.c -acme
   */
  
  /* Register bigreader lock indices here. */
  enum brlock_indices {
  	BR_GLOBALIRQ_LOCK,
  	BR_NETPROTO_LOCK,
! #if defined(CONFIG_LLC) || defined(CONFIG_LLC_MODULE)
! 	BR_8022_LOCK,
! #endif
  	__BR_END
  };
  
Index: kernel-acme/include/linux/dextab.h
diff -c /dev/null kernel-acme/include/linux/dextab.h:1.1.4.3
*** /dev/null	Wed Sep  5 00:22:21 2001
--- kernel-acme/include/linux/dextab.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,58 ----
+ #ifndef __LINUX_DEXTAB_H
+ #define __LINUX_DEXTAB_H
+ /*
+  * dextab.h - Contains definition of dynamically expandable tables 
+  *
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <asm/byteorder.h>
+ 
+ /* Dynamically expandable table structure */
+ struct dex_table {
+ 	void **		addr;
+ 	__u16		size;
+ 	__u16		reserved;
+ 	__u16		max_size;
+ 	__u16		count;
+ 	spinlock_t	lock;
+ };
+ typedef struct dex_table dextab_t;
+ 
+ #define DEXTAB_NOFREE_ENTRY	0
+ #define DEXTAB_FREE_ENTRY	1
+ 
+ #define dextab_add_entry(tbl, entry_size) \
+ 	dextab_add_insert_entry(tbl, entry_size, NULL)
+ #define dextab_insert_entry(tbl, entry)	dextab_add_insert_entry(tbl, 0, entry)
+ #define dextab_remove_index(tbl, entry_index) \
+ 	dextab_remove_delete_index(tbl, entry_index, DEXTAB_FREE_ENTRY)
+ #define dextab_delete_index(tbl, entry_index) \
+ 	dextab_remove_delete_index(tbl, entry_index, DEXTAB_NOFREE_ENTRY)
+ #define __dextab_delete_index(tbl, entry_index) \
+ 	__dextab_remove_delete_index(tbl, entry_index, DEXTAB_NOFREE_ENTRY)
+ #define dextab_remove_entry(tbl, entry) \
+ 	dextab_remove_delete_index(tbl, dextab_entry_index(tbl, entry), \
+ 				   DEXTAB_FREE_ENTRY)
+ #define dextab_delete_entry(tbl, entry) \
+ 	dextab_remove_delete_index(tbl, dextab_entry_index(tbl, entry), \
+ 				   DEXTAB_NOFREE_ENTRY)
+ /* Dynamically expandable table interface */
+ extern void dextab_init(dextab_t *tbl, int reserved, int max_size);
+ extern int dextab_add_insert_entry(dextab_t *tbl, int entry_size, void *entry);
+ extern void __dextab_remove_delete_index(dextab_t *tbl, int entry_index,
+ 				         int flag);
+ extern void dextab_remove_delete_index(dextab_t *tbl, int entry_index,
+ 				       int flag);
+ extern int dextab_entry_index(dextab_t *tbl, void *entry);
+ extern inline int __dextab_count_entries(dextab_t *tbl);
+ extern inline int dextab_count_entries(dextab_t *tbl);
+ extern void dextab_destruct(dextab_t *tbl);
+ #endif __LINUX_DEXTAB_H
Index: kernel-acme/include/linux/netbeui.h
diff -c kernel-acme/include/linux/netbeui.h:1.1.1.1 kernel-acme/include/linux/netbeui.h:1.1.1.1.4.7
*** kernel-acme/include/linux/netbeui.h:1.1.1.1	Tue Jun 26 14:34:01 2001
--- kernel-acme/include/linux/netbeui.h	Sun Aug 26 17:30:44 2001
***************
*** 1,16 ****
  #ifndef _LINUX_NETBEUI_H
  #define _LINUX_NETBEUI_H
  
! #include <linux/if.h>
  
! #define NB_NAME_LEN	20	/* Set this properly from the full docs when
! 				   I get them */
! 				   
! struct sockaddr_netbeui
! {
! 	sa_family	snb_family;
! 	char		snb_name[NB_NAME_LEN];
! 	char		snb_devhint[IFNAMSIZ];
  };
  
! #endif
--- 1,591 ----
  #ifndef _LINUX_NETBEUI_H
  #define _LINUX_NETBEUI_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netdevice.h>
+ #include <linux/if_tr.h>
+ #include <linux/if_ether.h>
+ #include <linux/dextab.h>
+ #include <linux/af_netb.h>
+ /* NetBIOS frame commands - listed by functionality */
+ #define NETBEUI_ADD_GROUP_NAME_QUERY	0x00
+ #define NETBEUI_ADD_NAME_QUERY		0x01
+ #define NETBEUI_ADD_NAME_RESPONSE	0x0D
+ #define NETBEUI_NAME_IN_CONFLICT	0x02
  
! #define NETBEUI_NAME_QUERY		0x0A
! #define NETBEUI_NAME_RECOGNIZED		0x0E
! #define NETBEUI_SESSION_ALIVE		0x1F
! #define NETBEUI_SESSION_CONFIRM		0x17
! #define NETBEUI_SESSION_END		0x18
! #define NETBEUI_SESSION_INITIALIZE	0x19
  
! #define NETBEUI_DATA_ACK		0x14
! #define NETBEUI_DATA_FIRST_MIDDLE	0x15
! #define NETBEUI_DATAGRAM		0x08
! #define NETBEUI_DATAGRAM_BROADCAST	0x09
! #define NETBEUI_DATA_ONLY_LAST		0x16
! #define NETBEUI_NO_RECEIVE		0x1A
! #define NETBEUI_RECEIVE_CONTINUE	0x1C
! #define NETBEUI_RECEIVE_OUTSTANDING	0x1B
! 
! #define NETBEUI_STATUS_QUERY		0x03
! #define NETBEUI_STATUS_RESPONSE		0x0F
! #define NETBEUI_TERMINATE_TRACE		0x07
! #define NETBEUI_TERMINATE_TRACE2	0x13
! 
! #define NETBEUI_MAX_COMMAND_CODE	0x1F
! #define NETBEUI_MIN_COMMAND_LEN		0x0B
! 
! #define dprintk(format, a...) \
!                 printk(KERN_INFO __FUNCTION__ ": " format, ##a)
! 
! extern u8 nb_command_header_len[];
! 
! /* NetBIOS name service constants */
! typedef enum { 
! 	NETBEUI_NAME_INITIAL = 0, 
! 	NETBEUI_NAME_ADDWAIT, 
! 	NETBEUI_NAME_COLLIDED,
! 	NETBEUI_NAME_ACQUIRED 
! } name_state_t;
! 
! typedef enum {
! 	NETBEUI_NAME_ADD_NAME = 0,
! 	NETBEUI_NAME_RETRY_TIMEOUT,
! 	NETBEUI_NAME_RESPONSE_TIMEOUT,
! 	NETBEUI_NAME_ADD_NAME_RESPONSE1,
! 	NETBEUI_NAME_ADD_NAME_RESPONSE2,
! 	NETBEUI_NAME_ADD_NAME_QUERY,
! 	NETBEUI_NAME_NAME_CONFLICT,
! 	NETBEUI_NAME_REMOVE_NAME
! } name_event_t;
! 
! /* NetBIOS query service constants */
! #define NETBEUI_QUERY_MAX_CACHE_ENTRIES 50
! #define NETBEUI_QUERY_CACHE_LIVING_TIME (5 * 60 * HZ)
! 
! typedef enum { 
! 	NETBEUI_QUERY_INITIAL = 0, 
! 	NETBEUI_QUERY_QRYWAIT,
! 	NETBEUI_QUERY_FINDWAIT,
! 	NETBEUI_QUERY_RECOGNIZED
! } query_state_t;
! 
! typedef enum {
! 	NETBEUI_QUERY_NAME_QUERY = 0,
! 	NETBEUI_QUERY_NAME_FIND,
! 	NETBEUI_QUERY_RETRY_TIMEOUT,
! 	NETBEUI_QUERY_RESPONSE_TIMEOUT,
! 	NETBEUI_QUERY_NAME_RECOGNIZED,
! 	NETBEUI_QUERY_END_QUERY
! } query_event_t;
! 
! #define NETBEUI_CALL_TT(data2)		((data2 & 0xFF00) >> 8)
! #define NETBEUI_CALL_SS(data2)  	(data2 & 0x00FF)
! #define NETBEUI_CALL_DATA2(tt,ss)	(((tt << 8) & 0xFF00) | (ss & 0x00FF))
! 
! /* NetBIOS session service constants */ 
! typedef enum { 
! 	NETBEUI_SESS_INITIAL = 0, 
! 	NETBEUI_SESS_CALLWAIT,
! 	NETBEUI_SESS_CONFWAIT,
! 	NETBEUI_SESS_LISTENWAIT,
! 	NETBEUI_SESS_INITWAIT,
! 	NETBEUI_SESS_CONNECTED,
! 	NETBEUI_SESS_DISCWAIT,
! 	NETBEUI_SESS_CONTWAIT,
! 	NETBEUI_SESS_STANDWAIT,
! 	NETBEUI_SESS_ACKWAIT,
! 	NETBEUI_SESS_RSRCWAIT,
! 	NETBEUI_SESS_NORMAL
! } session_state_t;
! 
! typedef enum {
! 	NETBEUI_SESS_CALL = 0,
! 	NETBEUI_SESS_LISTEN,
! 	NETBEUI_SESS_CONFIRM,
! 	NETBEUI_SESS_REJECT,
! 	NETBEUI_SESS_CONNECT,
! 	NETBEUI_SESS_TIMEOUT,
! 	NETBEUI_SESS_ABORT,
! 	NETBEUI_SESS_HANGUP,
! 	NETBEUI_SESS_END,
! 	NETBEUI_SESS_FIRST_MIDDLE_CONT,
! 	NETBEUI_SESS_FIRST_MIDDLE,
! 	NETBEUI_SESS_CONTINUE,
! 	NETBEUI_SESS_NONBLOCK,
! 	NETBEUI_SESS_PAUSE,
! 	NETBEUI_SESS_PAUSE2, 
! 	NETBEUI_SESS_RESTART,
! 	NETBEUI_SESS_ONLY_LAST_ACK,
! 	NETBEUI_SESS_ONLY_LAST,
! 	NETBEUI_SESS_DATA_ACKED,
! 	NETBEUI_SESS_RESOURCE,
! 	NETBEUI_SESS_CONN_RETRY,
! 	NETBEUI_SESS_NORM_RETRY,
! 	NETBEUI_SESS_ABORT_SEND,
! } session_event_t;
! 
! typedef enum {
! 	NETBEUI_RECV_NORMAL= 0,
! 	NETBEUI_RECV_NO_RECEIVE,
! 	NETBEUI_RECV_RECEIVE_OUTSTANDING
! } input_state_t;
! 
! #define NETBEUI_VERSION_1xx	0
! #define NETBEUI_VERSION_2xx	1
! 
! #define NETBEUI_NACK_NONE	0
! #define NETBEUI_NACK_ABLE	1
! 
! #define NETBEUI_ORIGIN_CONNECTED 1
! #define NETBEUI_ORIGIN_NORMAL    2
! 
! #define NETBEUI_IS_ABLE_TO_HANDLE_NACK(hdr)	(hdr->data1 & 0x80)
! #define NETBIOS_VERSION(hdr)		(hdr->data1 & 0x01)
! #define NETBEUI_TR_FRAME_LF(hdr)		(((hdr->data1) & 0x0E) >> 1)
! 
! #define NETBEUI_RECEIVE_CONTINUE_REQUESTED(hdr) (hdr->data1 & 0x01)
! #define NETBEUI_NACK_INDICATOR(hdr)		(hdr->data1 & 0x02)
! #define NETBEUI_ACK_WITH_DATA_ALLOWED(hdr)  	(hdr->data1 & 0x04)
! #define NETBEUI_ACK_WITH_DATA_INCLUDED(hdr)	(hdr->data1 & 0x08)
! 
! #define NETBEUI_REQUEST_RECEIVE_CONTINUE(hdr)	(hdr->data1 |= 0x01)
! #define NETBEUI_INDICATE_NACK(hdr)		(hdr->data1 |= 0x02)
! #define NETBEUI_ALLOW_ACK_WITH_DATA(hdr)	(hdr->data1 |= 0x04)
! #define NETBEUI_INCLUDE_ACK_WITH_DATA(hdr)	(hdr->data1 |= 0x08)
! 
! #define NETBEUI_RESYNCH_INDICATOR(hdr)		(hdr->data2)
! 
! #define NETBEUI_ACK_FLAG			0x80000000
! 
! /* NetBIOS link manager constants */
! typedef enum {
! 	NETBEUI_LINK_INITIAL= 0,
! 	NETBEUI_LINK_CONNWAIT,
! 	NETBEUI_LINK_UP
! } link_state_t;
! 
! typedef enum {
! 	NETBEUI_LINK_CONN_INDICATE= 0,
! 	NETBEUI_LINK_CONN_REQUEST,
! 	NETBEUI_LINK_DUMMY_CONN,
! 	NETBEUI_LINK_CONN_CONFIRM,
! 	NETBEUI_LINK_CONN_REJECT,
! 	NETBEUI_LINK_RESET_INDICATE,
! 	NETBEUI_LINK_SESSION_ALIVE,
! 	NETBEUI_LINK_DISC_REQUEST,
! 	NETBEUI_LINK_DISC_INDICATE
! } link_event_t;
! 
! /* NetBIOS constants */
! #define MIN(a,b) (((a) < (b)) ? (a) : (b))
! #define MAX(a,b) (((a) > (b)) ? (a) : (b))
! 
! #define NB_SK(sk) sk->protinfo.af_netbeui
! 
! #define MAC_ADDR_LEN	6
! 
! #define NETBIOS_FUNC_ADDR_4ETH	"\x03\x00\x00\x00\x00\x01"
! #define NETBIOS_FUNC_ADDR_4TR	"\xC0\x00\x00\x00\x00\x80"
! 
! #define NETBEUI_DELIMITER	0xEFFF
! 
! #define NETBEUI_LLC_I_HEADLEN	4	/* 4 bytes for LLC header of I_frames */
! #define NETBEUI_ILEN		0x0E	/* NetBEUI I_frame header length */
! 
! #define NETBEUI_LLC_UI_HEADLEN	3       /* 3 bytes for LLC header of UI_frames */
! #define NETBEUI_UILEN	0x2C    /* NetBEUI UI_frame header length */
! 
! #define NETBEUI_MAC_B_HEADLEN MAX(sizeof(struct ethhdr), sizeof(struct trh_hdr))
! 
! /* NetBIOS status service constants */
! typedef enum { 
! 	NBS_STAT_INITIAL = 0, 
! 	NBS_STAT_RESPWAIT
! } status_state_t;
! 
! typedef enum {
! 	NBE_STAT_STATUS_QUERY = 0,
! 	NBE_STAT_RETRY_TIMEOUT,
! 	NBE_STAT_RESPONSE_TIMEOUT,
! 	NBE_STAT_STATUS_RESPONSE,
! 	NBE_STAT_INCOMP_RESPONSE
! } status_event_t;
! 
! typedef enum {
! 	NO_RESPONSE = 0,
! 	INCOMPLETE_RESPONSE,
! 	USER_BUFFER_OVERFLOW,
! 	COMPLETED_RESPONSE
! } status_rc_t;
! 
! /* NetBIOS name data structure */
! struct nb_name {
! 	struct nb_name *	next;
! 	atomic_t		refcnt;
! 	name_state_t volatile  	state;		
! 	s32 volatile		status;
! 	__u8     		name[NETBEUI_NAME_LEN];	
! 	__u8			reserved;
! 	__u8			conflicted;
! 	name_type_t		type;		
! 	__u8			name_number;
! 	__u32			identifier;
! 	wait_queue_head_t       waitq;
! 	struct timer_list 	timer;
! 	struct sk_buff *	skb;
! 	__u16 			resp_correlator;
! 	__u16			xmit_correlator;
! 	__u8 			retries;	
! 	__u8 			responses;
! 	__u8			remote_mac[6];
! 	struct net_device      *remote_dev;
! 	struct proc_dir_entry  *dent;
! };
! typedef struct nb_name name_t;
! 
! /* NetBIOS Query Data Structure */ 
! struct nb_query {
! 	struct nb_query *	next;
! 	query_state_t volatile 	state;		
! 	s32 volatile 		status;
! 	name_t *		calling_name;
! 	__u8     		called_name[NETBEUI_NAME_LEN];	
! 	__u8			reserved;
! 	__u8			lsn;
! 	__u16 			resp_correlator;
! 	char *			mac_buff;
! 	struct net_device **	dev_buff;
! 	__u8			buff_len;
! 	__u8			buff_ofs;
! 	__u8			rsn;
! 	__u8			remote_mac[6];
! 	struct net_device *	remote_dev;
! 	__u16			xmit_correlator;
! 	__u8			tr_lfb; /* for Token-Ring support */
! 	struct timer_list 	timer;
! 	struct sk_buff *	skb;
! 	__u8 			retries;	
! 	__u8 			responses;
! 	wait_queue_head_t       waitq;
! };
! typedef struct nb_query query_t;
! 
! struct nb_session;
! typedef struct nb_session session_t;
! 
! typedef void (*abort_owner_cbt)(struct sock *sk, session_t *session);
! typedef void (*session_ready_cbt)(struct sock *sk, session_t *session);
! 
! /* NetBIOS Session Data Structure */
! struct nb_session {
! 	struct nb_session *	next;
! 	struct nb_session *	prev;
! 	session_state_t volatile state;		
! 	s32 volatile		status;
! 	atomic_t		refcnt;
! 	int			link_no;
! 	struct sock *		owner;
! 	name_t *		local_name;
! 	name_type_t		remote_name_type;		
! 	__u8 			remote_name[NETBEUI_NAME_LEN];
! 	__u8			reserved;
! 	__u8			lsn;
! 	__u8			rsn;
! 	__u8			version;
! 	__u8			nack_indicator;
! 	__u8			tr_frame_lf;
! 	__u16			mtu;
! 	__u16			llcmac_ihl;
! 	__u8			urgent_ack;
! 	__u8			users;
! 	__u8			zapped;
! 	struct sk_buff_head 	back_log;
! 	abort_owner_cbt		abort_owner_callback;
! 	session_ready_cbt	session_ready_callback;
! 	wait_queue_head_t       waitq;
! 	struct timer_list 	timer;
! 	struct sk_buff *	skb;
! 	struct net_device * 	remote_dev;
! 	__u8			remote_mac[6];
! 	__u16			xmit_correlator;
! 	__u16			resp_correlator;
! 	__u8			o_nonblock;
! 	__u8			o_noack;
! 	__u8			o_aborted;
! 	__u8			o_no_receive;
! 	__u8			o_receive_continue;
! 	__u8			o_receive_outstanding;
! 	__u8			o_rsrc_origin;
! 	__u8 *			o_buff;
! 	__u16			o_buffsize;
! 	__u16			o_size;
! 	__u16			o_txed;
! 	__u16			o_acked;
! 	__u16			r_acked;
! 	__u32			o_total;
! 	__u32			o_ack_correlator;
! 	__u16			i_rcvbuf;
! 	__u16			i_aborted;
! 	input_state_t		i_state;
! 	struct sk_buff_head 	i_skbq;
! 	__u16			i_notacked;
! 	__u16			i_size;
! 	__u32			i_total;
! 	struct proc_dir_entry   *dent;
! };
! 
! /* NetBIOS-LLC link data structure */
! struct nb_link {
! 	link_state_t volatile 	state;		
! 	s32	volatile 	status;
! 	void 		       *llc_handle;	
! 	__u32			link_no;
! 	atomic_t		refcnt;
! 	__u8			remote_mac[6];	
! 	struct net_device      *remote_dev;	
! 	struct sk_buff_head	skbq;
! 	__u8			llc_busy;
! 	__u32			iactivity;
! 	__u8			keep_alive;
! 	struct timer_list	timer;
! 	dextab_t		session_table;	
! 	wait_queue_head_t       waitq;
!         struct proc_dir_entry   *dent, *dent_sessions;
! };
! typedef struct nb_link link_t;
! 
! /* NetBIOS dataGram data structure */
! struct name_dgrms {
! 	char			 name[NETBEUI_NAME_LEN];
! 	struct sk_buff_head	 frameq;
! 	struct sk_buff		*curr_skb;
! 	volatile unsigned char	 connected;
! 	char			*conn_name;
! 	wait_queue_head_t	*waitq;
! 	struct name_dgrms	**list;
! 	struct name_dgrms	*next;
! 	struct name_dgrms	*prev;
! };
! typedef struct name_dgrms name_dgrms_t;
! 
! /* NetBIOS socket supplement structures */
! struct netbeui_sock {
! 	name_t *name;
! 	union {
! 		struct {
! 			session_t *session;
! 			session_t *backlog;
! 			volatile struct timeval	sto;
! 			volatile struct timeval	rto;
! 		} st;
! 		struct {
! 			struct sockaddr_netbeui	conn_name;
! 			name_dgrms_t *namep;
! 		} dg;
! 	} u;
! };
! 
! /* NetBIOS status data structure */ 
! struct nb_status {
! 	struct nb_status 	*next;
! 	__u8     		*called_name;
! 	char			*user_sbuff;
! 	int			sbuff_len;
! 	status_rc_t		resp_status;
! 	volatile status_state_t	state;
! 	__u8 			retries;	
! 	int			len_rx_info;
! 	__u8			no_rx_names;
! 	__u8			overflowed;
! 	__u16 			resp_correlator;
! 	__u8			unicast;
! 	__u8			remote_mac[MAC_ADDR_LEN];
! 	struct sk_buff		*tx_skb;
! 	struct sk_buff		*rx_skb;
! 	volatile unsigned char	locked;
! 	struct timer_list 	timer;
! 	wait_queue_head_t       waitq;
! };
! typedef struct nb_status status_t;
! 
! /* NetBIOS datagram packet header */
! struct nb_dgram {
! 	__u16	length;
! 	__u16	delimiter;
! 	__u8	command;
! 	__u8	data1;
! 	__u16	data2;
! 	__u16	xmit_correlator;
! 	__u16	resp_correlator;
! 	__u8	dest_name[NETBEUI_NAME_LEN];
! 	__u8	source_name[NETBEUI_NAME_LEN];
! };
! typedef struct nb_dgram dgram_t;
! 
! /* NetBIOS session packet header */ 
! struct nb_packet {
! 	__u16	length;
! 	__u16	delimiter;
! 	__u8	command;
! 	__u8	data1;
! 	__u16	data2;
! 	__u16	xmit_correlator;
! 	__u16	resp_correlator;
! 	__u8	dest_num;
! 	__u8	source_num;
  };
+ typedef	struct nb_packet packet_t;
+ 
+ /* NetBIOS Configuration Definitions */
+ typedef struct netbeui_config config_t;
+ 
+ extern config_t netbios_config;
+ 
+ #define NETBEUI_INACTIVITY_TIMEOUT (netbios_config.inactivity_timeout * HZ)
+ #define NETBEUI_TRANSMIT_TIMEOUT   (netbios_config.transmit_timeout * (HZ / 2))
+ #define NETBEUI_TRANSMIT_COUNT     (netbios_config.transmit_count)
+ #define NETBEUI_RESOURCE_TIMEOUT   (netbios_config.resource_timeout * (HZ / 10))
+ #define NETBEUI_DATA_ACK_TIMEOUT   (netbios_config.data_ack_timeout * (HZ / 10))
+ 
+ /* Common functions interface */ 
+ extern inline char *NETBEUI_FUNCADDR(struct net_device *dev);
+ extern unsigned char nbcm_apt_dev(struct net_device *dev);
+ extern inline int MAC_HEADLEN(struct net_device *dev);
+ extern inline int LLCMAC_I_HEADLEN(struct net_device *dev);
+ extern inline int LLCMAC_UI_HEADLEN(int mac_hlen);
+ extern inline int LLCMAC_UIB_HEADLEN(void);
+ extern inline int CALC_DG_SKBLEN(int mac_hlen, int user_datalen);
+ 
+ /* LLC supplement interface */
+ extern int nbll_attach_session(session_t *session, struct net_device *dev,
+ 			       unsigned char *remote_mac);
+ extern int nbll_link_session(int link_no, unsigned char session_no);
+ extern int nbll_isend(int link_no, struct sk_buff *skb);
+ extern int nbll_uisend(unsigned char *remote_maccaddr, struct sk_buff *skb);
+ extern void nbll_detach_session(int link_no, unsigned char session_no);
+ extern int nbll_drop_link(int link_no);
+ extern dextab_t *nbll_get_link_table(void);
+ extern link_t *nbll_get_link(int link_no);
+ extern inline void nbll_link_put(link_t *nb_link);
+ extern void nbll_test(void);
+  
+ /* Name service interface */
+ extern unsigned char *DEV_NAME_NUMBER_1(struct net_device *dev);
+ extern int nbns_validate_name(char *name);
+ extern void nbns_init_name_number_1(struct net_device *adapters[]);
+ extern name_t *nbns_name_number_1(void);
+ extern int nbns_add_name(char *name, name_type_t type, name_t **out_name);
+ extern name_t *nbns_find_name(char *name);
+ extern inline void nbns_name_hold(name_t *nb_name);
+ extern inline void nbns_name_put(name_t *nb_name);
+ extern void nbns_del_name(name_t *name);
+ extern void nbns_del_identifier(unsigned long id);
+ extern void nbns_get_add_name_query(struct sk_buff *skb,
+ 				    unsigned char *remote_mac, int type);
+ extern void nbns_get_add_name_response(struct sk_buff *skb,
+ 				       unsigned char *remote_mac);
+ extern void nbns_get_name_conflict(struct sk_buff *skb);
+ extern dextab_t *nbns_get_name_table(void);
+ extern name_t *nbns_get_name_list(void);
+ extern int nbns_count_names(void);
+ extern void nbns_test(void);
+ 
+ /* Query service interface */
+ extern void nbqs_get_name_recognized(struct sk_buff *skb,
+ 				     unsigned char *remote_mac);
+ extern int nbqs_query_name(char *called_name, name_t *calling_name, 
+                            unsigned char lsn, unsigned char *rsn, 
+                            unsigned char *lfb, unsigned short *xmit_correlator);
+ extern int nbqs_find_name(char *called_name, char *mac_buff, 
+ 			  struct net_device **dev_buff, int buff_len);
+ extern void nbqs_add_rnc(char *name, struct net_device *dev,
+ 			 unsigned char *mac);
+ extern void nbqs_delete_rnc(char *name);
+ extern void nbqs_test(void);
+ 
+ /* Session service interface */
+ extern void nbss_get_name_query(struct sk_buff *skb, unsigned char *remote_mac);
+ extern void nbss_deliver_frame(session_t *session, struct sk_buff *skb);
+ extern int nbss_call(name_t *calling_name, char *called_name,
+ 		     struct sock *owner, abort_owner_cbt itf_abort_owner, 
+            	     session_t **session_ptr);
+ extern int nbss_listen(name_t *name, int backlog, struct sock *owner,
+            	       abort_owner_cbt itf_abort_owner, 
+            	       session_ready_cbt itf_session_ready);
+ extern int nbss_listen_bh(name_t *nb_name, int backlog, struct sock *owner,
+ 			  abort_owner_cbt itf_abort_owner,
+ 			  session_ready_cbt itf_session_ready);
+ extern void __nbss_end_listen(name_t *name);
+ extern int nbss_send(session_t *session, unsigned char *buf,
+ 		     unsigned short size, unsigned char nonblock,
+ 		     unsigned char noack);
+ extern int nbss_send_zero(session_t *session, char *buff);
+ extern void nbss_abort_send(session_t *session);
+ extern int nbss_send_ready(session_t *session);
+ extern int nbss_receive(session_t *session, unsigned char *buf,
+   			unsigned short size, unsigned char nonblock);
+ extern void nbss_abort_receive(session_t *session);
+ extern int nbss_receive_ready(session_t *session);
+ extern int nbss_trim_data(session_t *session);
+ extern void nbss_hangup(session_t *session);
+ extern void nbss_abort_session(session_t *session);
+ extern int nbss_drop_session(int link_no, int session_no);
+ extern dextab_t *nbss_get_session_table(int link_no);
+ extern void nbss_test(char *service_name);
+ 
+ /* DataGram service interface */
+ extern void nbdg_set_dgbc_mtu(void);
+ extern int nbdg_remove_unwanted_dgf(name_dgrms_t *namep, int len);
+ extern void nbdg_register_peername(name_dgrms_t *namep, char *remote_name);
+ extern void nbdg_deregister_peername(name_dgrms_t *namep);
+ extern int nbdg_add_name(char *local_name, wait_queue_head_t *wq,
+ 			 name_dgrms_t **namep);
+ extern void nbdg_del_name(name_dgrms_t *namep);
+ extern int nbdg_receive_ready(name_dgrms_t *namep);
+ extern int nbdg_send(struct sock *sk, char *local_name, char *dest_name,
+ 		     name_type_t dest_type, struct iovec *iov, int len,
+ 		     int noblock);
+ extern int nbdg_receive(name_dgrms_t *namep, char *source_name, char *dest_name,
+ 			char *buff, int bufflen, int nonblock);
+ extern void nbdg_get_datagram(struct sk_buff *skb);
+ extern void nbdg_get_datagram_broadcast(struct sk_buff *skb);
+ 
+ /* Socket Supplement Interface */
+ extern int nbso_init(void);
+ extern int nbso_exit(void);
+ 
+ /* Status service interface */
+ void nbst_init_status(void);
+ int nbst_obtain_status(char *called_name, char *status_buff, int *buff_len);
+ void nbst_get_status_query(struct sk_buff *skb, unsigned char *remote_mac);
+ void nbst_get_status_response(struct sk_buff *skb, unsigned char *remote_mac);
+ 
+ /* PROC entry interface */
+ extern int netbeui_proc_init(void);
+ extern void netbeui_proc_clean(void);
+ extern int netbeui_proc_add_name(name_t *name);
+ extern int netbeui_proc_add_link(link_t *link);
+ extern int netbeui_proc_add_session(session_t *session);
+ extern void netbeui_proc_del_name(name_t *name);
+ extern void netbeui_proc_del_link(link_t *link);
+ extern void netbeui_proc_del_session(session_t *session);
  
! /* Configuration system interface */ 
! extern int nbcs_setsockopt(struct socket *sock, int optname, void *optval,
! 			   int optlen);
! extern int nbcs_getsockopt(struct socket *sock, int optname, void *optval,
! 			   int *optlen);
! extern int nbcs_ioctl(unsigned int cmd, void *arg);
! #endif /* _LINUX_NETBEUI_H */
Index: kernel-acme/include/linux/trdevice.h
diff -c kernel-acme/include/linux/trdevice.h:1.1.1.1 kernel-acme/include/linux/trdevice.h:1.1.1.1.4.1
*** kernel-acme/include/linux/trdevice.h:1.1.1.1	Tue Jun 26 14:34:03 2001
--- kernel-acme/include/linux/trdevice.h	Thu Aug 16 22:26:35 2001
***************
*** 31,36 ****
--- 31,39 ----
  extern int		tr_header(struct sk_buff *skb, struct net_device *dev,
  				   unsigned short type, void *daddr,
  				   void *saddr, unsigned len);
+ extern void		tr_source_route(struct sk_buff *skb,
+ 					struct trh_hdr *trh,
+ 					struct net_device *dev);
  extern int		tr_rebuild_header(struct sk_buff *skb);
  extern unsigned short	tr_type_trans(struct sk_buff *skb, struct net_device *dev);
  extern struct net_device *init_trdev(struct net_device *dev, int sizeof_priv);
Index: kernel-acme/include/net/datalink.h
diff -c kernel-acme/include/net/datalink.h:1.1.1.1 kernel-acme/include/net/datalink.h:1.1.1.1.4.1
*** kernel-acme/include/net/datalink.h:1.1.1.1	Tue Jun 26 14:33:58 2001
--- kernel-acme/include/net/datalink.h	Thu Aug 16 22:26:35 2001
***************
*** 2,16 ****
  #define _NET_INET_DATALINK_H_
  
  struct datalink_proto {
! 	unsigned short	type_len;
! 	unsigned char	type[8];
! 	const char	*string_name;
! 	unsigned short	header_length;
! 	int	(*rcvfunc)(struct sk_buff *, struct net_device *, 
! 				struct packet_type *);
! 	void	(*datalink_header)(struct datalink_proto *, struct sk_buff *,
! 					unsigned char *);
! 	struct datalink_proto	*next;
  };
  
  #endif
--- 2,25 ----
  #define _NET_INET_DATALINK_H_
  
  struct datalink_proto {
!         unsigned short  type_len;
!         unsigned char   type[8];
!         const char      *string_name;
! 
!         union {
!                 struct llc_pinfo *llc;
!         } ll_pinfo;
! 
! 	struct llc_sc_info *llc_sc;
! 	struct sock *sock;
! 
!         unsigned short  header_length;
! 
!         int     (*rcvfunc)(struct sk_buff *, struct net_device *,
!                                 struct packet_type *);
!         void    (*datalink_header)(struct datalink_proto *, struct sk_buff *,
!                                         unsigned char *);
!         struct datalink_proto   *next;
  };
  
  #endif
Index: kernel-acme/include/net/llc_actn.h
diff -c /dev/null kernel-acme/include/net/llc_actn.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_actn.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,48 ----
+ #ifndef LLC_ACTN_H
+ #define LLC_ACTN_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Station component state transition actions */
+ #define STATION_AC_START_ACK_TIMER                 1
+ #define STATION_AC_SET_RETRY_COUNT_0               2
+ #define STATION_AC_INCREMENT_RETRY_COUNT_BY_1      3
+ #define STATION_AC_SET_XID_R_COUNT_0               4
+ #define STATION_AC_INCREMENT_XID_R_COUNT_BY_1      5
+ #define STATION_AC_SEND_NULL_DSAP_XID_C            6
+ #define STATION_AC_SEND_XID_R                      7
+ #define STATION_AC_SEND_TEST_R                     8
+ #define STATION_AC_REPORT_STATUS                   9
+ 
+ /* All station state event action functions look like this */
+ typedef u16 (*station_action_t)(struct p8022_station *station,
+ 				struct station_state_event *event);
+ extern u16 station_ac_start_ack_timer(struct p8022_station *station,
+                                       struct station_state_event *event);
+ extern u16 station_ac_set_retry_count_0(struct p8022_station *station,
+                                         struct station_state_event *event);
+ extern u16 station_ac_increment_retry_count_by_1(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ extern u16 station_ac_set_xid_r_count_0(struct p8022_station *station,
+                                         struct station_state_event *event);
+ extern u16 station_ac_increment_xid_r_count_by_1(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ extern u16 station_ac_send_null_dsap_xid_c(struct p8022_station *station,
+ 					   struct station_state_event *event);
+ extern u16 station_ac_send_xid_r(struct p8022_station *station,
+ 				 struct station_state_event *event);
+ extern u16 station_ac_send_test_r(struct p8022_station *station,
+                                   struct station_state_event *event);
+ extern u16 station_ac_report_status(struct p8022_station *station,
+ 				    struct station_state_event *event);
+ extern u16 station_ac_report_status(struct p8022_station *station,
+                                    struct station_state_event *event);
+ #endif /* LLC_ACTN_H */
Index: kernel-acme/include/net/llc_c_ac.h
diff -c /dev/null kernel-acme/include/net/llc_c_ac.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_c_ac.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,268 ----
+ #ifndef LLC_C_AC_H
+ #define LLC_C_AC_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Connection component state transition actions */
+ /* 
+  * Connection state transition actions
+  * (Fb = F bit; Pb = P bit; Xb = X bit)
+  */
+ #define CONN_AC_CLEAR_REMOTE_BUSY                          1
+ #define CONN_AC_CONNECT_INDICATION                         2
+ #define CONN_AC_CONNECT_CONFIRM                            3
+ #define CONN_AC_DATA_INDICATION                            4
+ #define CONN_AC_DISCONNECT_INDICATION                      5
+ #define CONN_AC_RESET_INDICATION                           6
+ #define CONN_AC_RESET_CONFIRM                              7
+ #define CONN_AC_REPORT_STATUS                              8
+ #define CONN_AC_CLEAR_REMOTE_BUSY_IF_Fb_EQ_1               9
+ #define CONN_AC_STOP_REJ_TIMER_IF_DATA_FLAG_EQ_2           10
+ #define CONN_AC_SEND_DISC_CMD_Pb_SET_X                     11
+ #define CONN_AC_SEND_DM_RSP_Fb_SET_Pb                      12
+ #define CONN_AC_SEND_DM_RSP_Fb_SET_1                       13
+ #define CONN_AC_SEND_DM_RSP_Fb_SET_F_FLAG                  14
+ #define CONN_AC_SEND_FRMR_RSP_Fb_SET_X                     15
+ #define CONN_AC_RESEND_FRMR_RSP_Fb_SET_0                   16
+ #define CONN_AC_RESEND_FRMR_RSP_Fb_SET_Pb                  17
+ #define CONN_AC_SEND_I_CMD_Pb_SET_1                        18
+ #define CONN_AC_RESEND_I_CMD_Pb_SET_1                      19
+ #define CONN_AC_RESEND_I_CMD_Pb_SET_1_OR_SEND_RR           20
+ #define CONN_AC_SEND_I_XXX_Xb_SET_0                        21
+ #define CONN_AC_RESEND_I_XXX_Xb_SET_0                      22
+ #define CONN_AC_RESEND_I_XXX_Xb_SET_0_OR_SEND_RR           23
+ #define CONN_AC_RESEND_I_RSP_Fb_SET_1                      24
+ #define CONN_AC_SEND_REJ_CMD_Pb_SET_1                      25
+ #define CONN_AC_SEND_REJ_RSP_Fb_SET_1                      26
+ #define CONN_AC_SEND_REJ_XXX_Xb_SET_0                      27
+ #define CONN_AC_SEND_RNR_CMD_Pb_SET_1                      28
+ #define CONN_AC_SEND_RNR_RSP_Fb_SET_1                      29
+ #define CONN_AC_SEND_RNR_XXX_Xb_SET_0                      30
+ #define CONN_AC_SET_REMOTE_BUSY                            31
+ #define CONN_AC_OPTIONAL_SEND_RNR_XXX_Xb_SET_0             32
+ #define CONN_AC_SEND_RR_CMD_Pb_SET_1                       33
+ #define CONN_AC_SEND_ACK_CMD_Pb_SET_1                      34
+ #define CONN_AC_SEND_RR_RSP_Fb_SET_1                       35
+ #define CONN_AC_SEND_ACK_RSP_Fb_SET_1                      36
+ #define CONN_AC_SEND_RR_XXX_Xb_SET_0                       37
+ #define CONN_AC_SEND_ACK_XXX_Xb_SET_0                      38
+ #define CONN_AC_SEND_SABME_CMD_Pb_SET_X                    39
+ #define CONN_AC_SEND_UA_RSP_Fb_SET_Pb                      40
+ #define CONN_AC_SEND_UA_RSP_Fb_SET_F_FLAG                  41
+ #define CONN_AC_S_FLAG_SET_0                               42
+ #define CONN_AC_S_FLAG_SET_1                               43
+ #define CONN_AC_START_P_TIMER                              44
+ #define CONN_AC_START_ACK_TIMER                            45
+ #define CONN_AC_START_REJ_TIMER                            46
+ #define CONN_AC_START_ACK_TIMER_IF_NOT_RUNNING             47
+ #define CONN_AC_STOP_ACK_TIMER                             48
+ #define CONN_AC_STOP_P_TIMER                               49
+ #define CONN_AC_STOP_REJ_TIMER                             50
+ #define CONN_AC_STOP_ALL_TIMERS                            51
+ #define CONN_AC_STOP_OTHER_TIMERS                          52
+ #define CONN_AC_UPDATE_Nr_RECEIVED                         53
+ #define CONN_AC_UPDATE_P_FLAG                              54
+ #define CONN_AC_DATA_FLAG_SET_2                            55
+ #define CONN_AC_DATA_FLAG_SET_0                            56
+ #define CONN_AC_DATA_FLAG_SET_1                            57
+ #define CONN_AC_DATA_FLAG_SET_1_IF_DATA_FLAG_EQ_0          58
+ #define CONN_AC_P_FLAG_SET_0                               59
+ #define CONN_AC_P_FLAG_SET_P                               60
+ #define CONN_AC_REMOTE_BUSY_SET_0                          61
+ #define CONN_AC_RETRY_COUNT_SET_0                          62
+ #define CONN_AC_RETRY_COUNT_INCREMENT_BY_1                 63
+ #define CONN_AC_Vr_SET_0                                   64
+ #define CONN_AC_Vr_INCREMENT_BY_1                          65
+ #define CONN_AC_Vs_SET_0                                   66
+ #define CONN_AC_Vs_SET_Nr                                  67
+ #define CONN_AC_F_FLAG_SET_P                               68
+ #define CONN_AC_STOP_SENDACK_TIMER                         70
+ #define CONN_AC_START_SENDACK_TIMER_IF_NOT_RUNNING         71
+ 
+ typedef u16 (*conn_action_t)(struct p8022_connection *conn,
+ 			     struct conn_state_event *event);
+ 
+ extern u16 conn_ac_clear_remote_busy(struct p8022_connection *conn,
+                                      struct conn_state_event *event);
+ extern u16 conn_ac_connect_indication(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u16 conn_ac_connect_confirm(struct p8022_connection *conn,
+                                    struct conn_state_event *event);
+ extern u16 conn_ac_data_indication(struct p8022_connection *conn,
+ 				   struct conn_state_event *event);
+ extern u16 conn_ac_disconnect_indication(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ac_reset_indication(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ac_reset_confirm(struct p8022_connection *conn,
+ 				 struct conn_state_event *event);
+ extern u16 conn_ac_report_status(struct p8022_connection *conn,
+ 				 struct conn_state_event *event);
+ extern u16 conn_ac_clear_remote_busy_if_f_eq_1(struct p8022_connection *conn,
+ 					       struct conn_state_event *event);
+ extern u16 conn_ac_stop_rej_timer_if_data_flag_eq_2(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_send_disc_cmd_p_set_x(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ac_send_dm_rsp_f_set_p(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ac_send_dm_rsp_f_set_1(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ac_send_dm_rsp_f_set_f_flag(struct p8022_connection *conn,
+                                             struct conn_state_event *event);
+ extern u16 conn_ac_send_frmr_rsp_f_set_x(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ac_resend_frmr_rsp_f_set_0(struct p8022_connection *conn,
+                                            struct conn_state_event *event);
+ extern u16 conn_ac_resend_frmr_rsp_f_set_p(struct p8022_connection *conn,
+                                            struct conn_state_event *event);
+ extern u16 conn_ac_send_i_cmd_p_set_1(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u16 conn_ac_send_i_cmd_p_set_0(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u16 conn_ac_resend_i_cmd_p_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_resend_i_cmd_p_set_1_or_send_rr(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_send_i_xxx_x_set_0(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u16 conn_ac_resend_i_xxx_x_set_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_resend_i_xxx_x_set_0_or_send_rr(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_resend_i_rsp_f_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rej_cmd_p_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rej_rsp_f_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rej_xxx_x_set_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rnr_cmd_p_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rnr_rsp_f_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rnr_xxx_x_set_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_set_remote_busy(struct p8022_connection *conn,
+ 				   struct conn_state_event *event);
+ extern u16 conn_ac_optional_send_rnr_xxx_x_set_0(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_send_rr_cmd_p_set_1(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ac_send_ack_cmd_p_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rr_rsp_f_set_1(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ac_send_ack_rsp_f_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_rr_xxx_x_set_0(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ac_send_ack_xxx_x_set_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ac_send_sabme_cmd_p_set_x(struct p8022_connection *conn,
+                                           struct conn_state_event *event);
+ extern u16 conn_ac_send_ua_rsp_f_set_f_flag(struct p8022_connection *conn,
+                                             struct conn_state_event *event);
+ extern u16 conn_ac_send_ua_rsp_f_set_p(struct p8022_connection *conn,
+ 				       struct conn_state_event *event);
+ extern u16 conn_ac_set_s_flag_0(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_ac_set_s_flag_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_ac_start_p_timer(struct p8022_connection *conn,
+ 				 struct conn_state_event *event);
+ extern u16 conn_ac_start_ack_timer(struct p8022_connection *conn,
+ 				   struct conn_state_event *event);
+ extern u16 conn_ac_start_rej_timer(struct p8022_connection *conn,
+ 				   struct conn_state_event *event);
+ extern u16 conn_ac_start_ack_timer_if_not_running(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_stop_ack_timer(struct p8022_connection *conn,
+ 				  struct conn_state_event *event);
+ extern u16 conn_ac_stop_p_timer(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_ac_stop_rej_timer(struct p8022_connection *conn,
+ 				  struct conn_state_event *event);
+ extern u16 conn_ac_stop_all_timers(struct p8022_connection *conn,
+                                    struct conn_state_event *event);
+ extern u16 conn_ac_stop_other_timers(struct p8022_connection *conn,
+                                      struct conn_state_event *event);
+ extern u16 conn_ac_update_nr_received(struct p8022_connection *conn,
+ 				      struct conn_state_event *event);
+ extern u16 conn_ac_increase_transmit_window_size(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_decrease_transmit_window_size(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_update_p_flag(struct p8022_connection *conn,
+ 				 struct conn_state_event *event);
+ extern u16 conn_ac_set_data_flag_2(struct p8022_connection *conn,
+                                    struct conn_state_event *event);
+ extern u16 conn_ac_set_data_flag_0(struct p8022_connection *conn,
+                                    struct conn_state_event *event);
+ extern u16 conn_ac_set_data_flag_1(struct p8022_connection *conn,
+ 				   struct conn_state_event *event);
+ extern u16 conn_ac_set_data_flag_1_if_data_flag_eq_0(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ac_set_p_flag_0(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_ac_set_p_flag_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_ac_set_remote_busy_0(struct p8022_connection *conn,
+                                      struct conn_state_event *event);
+ extern u16 conn_ac_set_retry_count_0(struct p8022_connection *conn,
+                                      struct conn_state_event *event);
+ extern u16 conn_ac_set_cause_flag_0(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ac_set_cause_flag_1(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ac_increment_retry_count_by_1(struct p8022_connection *conn,
+ 					      struct conn_state_event *event);
+ extern u16 conn_ac_set_vr_0(struct p8022_connection *conn,
+ 			    struct conn_state_event *event);
+ extern u16 conn_ac_increment_vr_by_1(struct p8022_connection *conn,
+ 				     struct conn_state_event *event);
+ extern u16 conn_ac_set_vs_0(struct p8022_connection *conn,
+ 			    struct conn_state_event *event);
+ extern u16 conn_ac_set_vs_nr(struct p8022_connection *conn,
+ 			     struct conn_state_event *event);
+ extern u16 conn_ac_reset_vs(struct p8022_connection *conn,
+ 			    struct conn_state_event *event);
+ extern u16 conn_ac_update_vs(struct p8022_connection *conn,
+ 			     struct conn_state_event *event);
+ extern u16 conn_ac_set_f_flag_p(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_disconnect(struct p8022_connection *conn,
+ 			   struct conn_state_event *event);
+ extern u16 conn_reset(struct p8022_connection *conn,
+ 		      struct conn_state_event *event);
+ extern u16 conn_ac_disconnect_confirm(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u8 circular_between(u8 a, u8 b, u8 c);
+ extern u16 conn_ac_send_ack_if_needed(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u16 conn_ac_increase_npta_value(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ac_adjust_npta_by_rr(struct p8022_connection *conn,
+                                      struct conn_state_event *event);
+ extern u16 conn_ac_adjust_npta_by_rnr(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u16 conn_ac_reset_sendack_flag(struct p8022_connection *conn,
+                                       struct conn_state_event *event);
+ extern u16 conn_ac_send_rr_rsp_f_set_ackpf(struct p8022_connection *conn,
+                                            struct conn_state_event *event);
+ extern u16 conn_ac_send_i_rsp_f_set_ackpf(struct p8022_connection *conn,
+                                           struct conn_state_event *event);
+ extern u16 conn_ac_send_i_rsp_as_ack(struct p8022_connection *conn,
+                                      struct conn_state_event *event);
+ extern u16 conn_ac_send_i_as_ack(struct p8022_connection *conn,
+ 				 struct conn_state_event *event);
+ #endif /* LLC_C_AC_H */
Index: kernel-acme/include/net/llc_c_ev.h
diff -c /dev/null kernel-acme/include/net/llc_c_ev.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_c_ev.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,330 ----
+ #ifndef LLC_C_EV_H
+ #define LLC_C_EV_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Connection component state transition event qualifiers */
+ /* Types of events (possible values in 'event->type') */
+ #define CONN_EV_TYPE_SIMPLE        1
+ #define CONN_EV_TYPE_CONDITION     2
+ #define CONN_EV_TYPE_PRIM          3
+ #define CONN_EV_TYPE_PDU           4           /* command/response PDU */
+ #define CONN_EV_TYPE_ACK_TIMER     5
+ #define CONN_EV_TYPE_P_TIMER       6
+ #define CONN_EV_TYPE_REJ_TIMER     7
+ #define CONN_EV_TYPE_BUSY_TIMER    8
+ #define CONN_EV_TYPE_RPT_STATUS    9
+ #define CONN_EV_TYPE_SENDACK_TIMER 10
+ 
+ #define NBR_CONN_EV		   5 
+ /* Connection events which cause state transitions when fully qualified */
+ 
+ #define CONN_EV_CONNECT_REQUEST                    1
+ #define CONN_EV_CONNECT_RESPONSE                   2
+ #define CONN_EV_DATA_REQUEST                       3
+ #define CONN_EV_DISCONNECT_REQUEST                 4
+ #define CONN_EV_RESET_REQUEST                      5
+ #define CONN_EV_RESET_RESPONSE                     6
+ #define CONN_EV_LOCAL_BUSY_DETECTED                7
+ #define CONN_EV_LOCAL_BUSY_CLEARED                 8
+ #define CONN_EV_RX_BAD_PDU                         9
+ #define CONN_EV_RX_DISC_CMD_Pbit_SET_X             10
+ #define CONN_EV_RX_DM_RSP_Fbit_SET_X               11
+ #define CONN_EV_RX_FRMR_RSP_Fbit_SET_X             12
+ #define CONN_EV_RX_I_CMD_Pbit_SET_X                13
+ #define CONN_EV_RX_I_CMD_Pbit_SET_X_UNEXPD_Ns      14
+ #define CONN_EV_RX_I_CMD_Pbit_SET_X_INVAL_Ns       15
+ #define CONN_EV_RX_I_RSP_Fbit_SET_X                16
+ #define CONN_EV_RX_I_RSP_Fbit_SET_X_UNEXPD_Ns      17
+ #define CONN_EV_RX_I_RSP_Fbit_SET_X_INVAL_Ns       18
+ #define CONN_EV_RX_REJ_CMD_Pbit_SET_X              19
+ #define CONN_EV_RX_REJ_RSP_Fbit_SET_X              20
+ #define CONN_EV_RX_RNR_CMD_Pbit_SET_X              21
+ #define CONN_EV_RX_RNR_RSP_Fbit_SET_X              22
+ #define CONN_EV_RX_RR_CMD_Pbit_SET_X               23
+ #define CONN_EV_RX_RR_RSP_Fbit_SET_X               24
+ #define CONN_EV_RX_SABME_CMD_Pbit_SET_X            25
+ #define CONN_EV_RX_UA_RSP_Fbit_SET_X               26
+ #define CONN_EV_RX_XXX_CMD_Pbit_SET_X              27
+ #define CONN_EV_RX_XXX_RSP_Fbit_SET_X              28
+ #define CONN_EV_RX_XXX_YYY                         29
+ #define CONN_EV_RX_ZZZ_CMD_Pbit_SET_X_INVAL_Nr     30
+ #define CONN_EV_RX_ZZZ_RSP_Fbit_SET_X_INVAL_Nr     31
+ #define CONN_EV_P_TIMER_EXPIRED                    32
+ #define CONN_EV_ACK_TIMER_EXPIRED                  33
+ #define CONN_EV_REJ_TIMER_EXPIRED                  34
+ #define CONN_EV_BUSY_TIMER_EXPIRED                 35
+ #define CONN_EV_RX_XXX_CMD_Pbit_SET_1              36
+ #define CONN_EV_RX_XXX_CMD_Pbit_SET_0              37
+ #define CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns      38
+ #define CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns      39
+ #define CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns      40
+ #define CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns      41
+ #define CONN_EV_RX_I_CMD_Pbit_SET_0                42
+ #define CONN_EV_RX_I_RSP_Fbit_SET_0                43
+ #define CONN_EV_RX_I_CMD_Pbit_SET_1                44
+ #define CONN_EV_RX_RR_CMD_Pbit_SET_0               45
+ #define CONN_EV_RX_RR_RSP_Fbit_SET_0               46
+ #define CONN_EV_RX_RR_RSP_Fbit_SET_1               47
+ #define CONN_EV_RX_RR_CMD_Pbit_SET_1               48
+ #define CONN_EV_RX_RNR_CMD_Pbit_SET_0              49
+ #define CONN_EV_RX_RNR_RSP_Fbit_SET_0              50
+ #define CONN_EV_RX_RNR_RSP_Fbit_SET_1              51
+ #define CONN_EV_RX_RNR_CMD_Pbit_SET_1              52
+ #define CONN_EV_RX_REJ_CMD_Pbit_SET_0              53
+ #define CONN_EV_RX_REJ_RSP_Fbit_SET_0              54
+ #define CONN_EV_RX_REJ_CMD_Pbit_SET_1              55
+ #define CONN_EV_RX_I_RSP_Fbit_SET_1                56
+ #define CONN_EV_RX_REJ_RSP_Fbit_SET_1              57
+ #define CONN_EV_RX_XXX_RSP_Fbit_SET_1              58
+ #define CONN_EV_TX_BUFF_FULL                       59
+ 
+ #define CONN_EV_INIT_P_F_CYCLE                     100
+ /*
+  * Connection event qualifiers; for some events a certain combination of
+  * these qualifiers must be TRUE before event recognized valid for state;
+  * these constants act as indexes into the Event Qualifier function 
+  * table
+  */
+ #define CONN_EV_QFY_DATA_FLAG_EQ_1         1
+ #define CONN_EV_QFY_DATA_FLAG_EQ_0         2
+ #define CONN_EV_QFY_DATA_FLAG_EQ_2         3
+ #define CONN_EV_QFY_P_FLAG_EQ_1            4
+ #define CONN_EV_QFY_P_FLAG_EQ_0            5
+ #define CONN_EV_QFY_P_FLAG_EQ_Fbit         6
+ #define CONN_EV_QFY_REMOTE_BUSY_EQ_0       7
+ #define CONN_EV_QFY_RETRY_COUNT_LT_N2      8
+ #define CONN_EV_QFY_RETRY_COUNT_GTE_N2     9
+ #define CONN_EV_QFY_S_FLAG_EQ_1            10
+ #define CONN_EV_QFY_S_FLAG_EQ_0            11
+ #define CONN_EV_QFY_INIT_P_F_CYCLE         12
+ 
+ /* Event data interface; what is sent in an event package */
+ /* Event CONN_EV_TYPE_SIMPLE interface */
+ typedef struct {
+ 	u8 event;
+ } conn_event_simple_if_t;
+ 
+ /* Event CONN_EV_TYPE_PRIM interface */
+ typedef struct {
+ 	u8    prim;  /* connect, disconnect, reset, ... */
+ 	u8    type;  /* request, indicate, response, confirm */
+ 	struct prim_if_block *data;
+ } conn_event_prim_if_t;
+ 
+ /* Event CONN_EV_TYPE_PDU interface */
+ typedef struct {                      
+ 	u8 event;
+ 	u8 reason;
+ 	struct sk_buff *skb;
+ } conn_event_pdu_if_t;
+ 
+ /* Event interface for timer-generated events */
+ typedef struct {
+ 	struct p8022_connection *conn;
+ 	u32           component_handle;
+ 	void		*timer_specific;
+ } conn_event_timer_if_t;
+ 
+ typedef struct {
+ 	u8 status;
+ } conn_event_rpt_sts_if_t;
+ 
+ typedef union {
+ 	conn_event_simple_if_t  a;          /* 'a' for simple, easy ... */
+ 	conn_event_prim_if_t    prim;
+ 	conn_event_pdu_if_t     pdu;
+ 	conn_event_timer_if_t   tmr;
+ 	conn_event_rpt_sts_if_t rsts;       /* report status */
+ } conn_event_if_t;
+ 
+ struct conn_state_event {
+ 	u8		      type;
+ 	u8		      status;
+ 	u8		      flag;
+ 	struct prim_if_block *ind_prim;
+ 	struct prim_if_block *cfm_prim;
+ 	conn_event_if_t       data;
+ 	struct list_head      node; /* entry in connection_t event_q list */
+ };
+ typedef u16 (*conn_event_t)(struct p8022_connection *conn,
+ 			    struct conn_state_event *event);
+ typedef u16 (*conn_event_qfyr_t)(struct p8022_connection *conn,
+ 				 struct conn_state_event *event);
+ 
+ extern u16 conn_ev_connect_request(struct p8022_connection *conn,
+ 				   struct conn_state_event *event);
+ extern u16 conn_ev_connect_response(struct p8022_connection *conn,
+ 				    struct conn_state_event *event);
+ extern u16 conn_ev_data_request(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_ev_disconnect_request(struct p8022_connection *conn,
+ 				      struct conn_state_event *event);
+ extern u16 conn_ev_reset_request(struct p8022_connection *conn,
+ 				 struct conn_state_event *event);
+ extern u16 conn_ev_reset_response(struct p8022_connection *conn,
+ 				  struct conn_state_event *event);
+ extern u16 conn_ev_local_busy_detected(struct p8022_connection *conn,
+ 				       struct conn_state_event *event);
+ extern u16 conn_ev_local_busy_cleared(struct p8022_connection *conn,
+ 				      struct conn_state_event *event);
+ extern u16 conn_ev_rx_bad_pdu(struct p8022_connection *conn,
+ 			      struct conn_state_event *event);
+ extern u16 conn_ev_rx_disc_cmd_pbit_set_x(struct p8022_connection *conn,
+ 					  struct conn_state_event *event);
+ extern u16 conn_ev_rx_dm_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				        struct conn_state_event *event);
+ extern u16 conn_ev_rx_frmr_rsp_fbit_set_x(struct p8022_connection *conn,
+ 					  struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_cmd_pbit_set_x_inval_ns(struct p8022_connection *conn,
+ 					        struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				       struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_rsp_fbit_set_x_unexpd_ns(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_rsp_fbit_set_x_inval_ns(struct p8022_connection *conn,
+ 					        struct conn_state_event *event);
+ extern u16 conn_ev_rx_rej_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				         struct conn_state_event *event);
+ extern u16 conn_ev_rx_sabme_cmd_pbit_set_x(struct p8022_connection *conn,
+ 					   struct conn_state_event *event);
+ extern u16 conn_ev_rx_ua_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				        struct conn_state_event *event);
+ extern u16 conn_ev_rx_xxx_cmd_pbit_set_x(struct p8022_connection *conn,
+ 					 struct conn_state_event *event);
+ extern u16 conn_ev_rx_xxx_rsp_fbit_set_x(struct p8022_connection *conn,
+ 					 struct conn_state_event *event);
+ extern u16 conn_ev_rx_xxx_yyy(struct p8022_connection *conn,
+ 			      struct conn_state_event *event);
+ extern u16 conn_ev_rx_zzz_cmd_pbit_set_x_inval_nr(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ev_rx_zzz_rsp_fbit_set_x_inval_nr(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ extern u16 conn_ev_p_timer_expired(struct p8022_connection *conn,
+ 				   struct conn_state_event *event);
+ extern u16 conn_ev_ack_timer_expired(struct p8022_connection *conn,
+ 				     struct conn_state_event *event);
+ extern u16 conn_ev_rej_timer_expired(struct p8022_connection *conn,
+ 				     struct conn_state_event *event);
+ extern u16 conn_ev_busy_timer_expired(struct p8022_connection *conn,
+ 				      struct conn_state_event *event);
+ extern u16 conn_ev_any_timer_expired(struct p8022_connection *conn,
+ 				     struct conn_state_event *event);
+ extern u16 conn_ev_sendack_timer_expired(struct p8022_connection *conn,
+ 					 struct conn_state_event *event); 
+ /* NOT_USED functions and their variations */
+ extern u16 conn_ev_rx_xxx_cmd_pbit_set_1(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_xxx_cmd_pbit_set_0(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_xxx_rsp_fbit_set_1(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns(struct p8022_connection *conn,
+                                                 struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns(struct p8022_connection *conn,
+                                                 struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_cmd_pbit_set_0(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_cmd_pbit_set_1(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns(struct p8022_connection *conn,
+                                                 struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns(struct p8022_connection *conn,
+                                                 struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_rsp_fbit_set_0(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ev_rx_i_rsp_fbit_set_1(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ev_rx_rr_cmd_pbit_set_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_rx_rr_cmd_pbit_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_rx_rr_rsp_fbit_set_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_rx_rr_rsp_fbit_set_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_rx_rnr_cmd_pbit_set_0(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_rnr_cmd_pbit_set_1(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_rnr_rsp_fbit_set_0(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_rnr_rsp_fbit_set_1(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_rej_cmd_pbit_set_0(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_rej_cmd_pbit_set_1(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_rej_rsp_fbit_set_0(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_rej_rsp_fbit_set_1(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_rx_any_frame(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ extern u16 conn_ev_tx_buffer_full(struct p8022_connection *conn,
+ 				  struct conn_state_event *event);
+ extern u16 conn_ev_init_p_f_cycle(struct p8022_connection *conn,
+ 				  struct conn_state_event *event);
+ 
+ /* Available connection action qualifiers */
+ extern u16 conn_ev_qlfy_data_flag_eq_1(struct p8022_connection *conn,
+ 				       struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_data_flag_eq_0(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_data_flag_eq_2(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_p_flag_eq_1(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_last_frame_eq_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_last_frame_eq_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_p_flag_eq_0(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_p_flag_eq_f(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_remote_busy_eq_0(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_remote_busy_eq_1(struct p8022_connection *conn,
+                                          struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_retry_count_lt_n2(struct p8022_connection *conn,
+                                           struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_retry_count_gte_n2(struct p8022_connection *conn,
+                                            struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_s_flag_eq_1(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_s_flag_eq_0(struct p8022_connection *conn,
+                                     struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_cause_flag_eq_1(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_cause_flag_eq_0(struct p8022_connection *conn,
+                                         struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_init_p_f_cycle(struct p8022_connection *conn,
+                                        struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_connect(struct p8022_connection *conn,
+                                            struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_disconnect(struct p8022_connection *conn,
+                                               struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_failed(struct p8022_connection *conn,
+                                           struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_impossible(struct p8022_connection *conn,
+                                               struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_remote_busy(struct p8022_connection *conn,
+                                                struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_received(struct p8022_connection *conn,
+                                             struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_refuse(struct p8022_connection *conn,
+                                           struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_conflict(struct p8022_connection *conn,
+                                             struct conn_state_event *event);
+ extern u16 conn_ev_qlfy_set_status_reset_done(struct p8022_connection *conn,
+                                               struct conn_state_event *event);
+ #endif /* LLC_C_EV_H */
Index: kernel-acme/include/net/llc_c_st.h
diff -c /dev/null kernel-acme/include/net/llc_c_st.h:1.1.4.3
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_c_st.h	Tue Aug 28 01:32:08 2001
***************
*** 0 ****
--- 1,49 ----
+ #ifndef LLC_C_ST_H
+ #define LLC_C_ST_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Connection component state management */
+ /* connection states */
+ #define CONN_OUT_OF_SVC            0       /* prior to allocation */
+ 
+ #define CONN_STATE_ADM             1       /* disconnected, initial state */
+ #define CONN_STATE_SETUP           2       /* disconnected state */
+ #define CONN_STATE_NORMAL          3       /* connected state */
+ #define CONN_STATE_BUSY            4       /* connected state */
+ #define CONN_STATE_REJECT          5       /* connected state */
+ #define CONN_STATE_AWAIT           6       /* connected state */
+ #define CONN_STATE_AWAIT_BUSY      7       /* connected state */
+ #define CONN_STATE_AWAIT_REJECT    8       /* connected state */
+ #define CONN_STATE_D_CONN          9       /* disconnected state */
+ #define CONN_STATE_RESET           10      /* disconnected state */
+ #define CONN_STATE_ERROR           11      /* disconnected state */
+ #define CONN_STATE_TEMP            12      /* disconnected state */
+ 
+ #define NBR_CONN_STATES            12      /* size of state table */
+ #define NO_STATE_CHANGE            100      
+ 
+ /* Connection state table structure */
+ typedef struct {
+    conn_event_t       event;
+    u8                 next_state;
+    conn_event_qfyr_t *event_qualifiers;
+    conn_action_t *    event_actions;
+ } conn_state_transition_t;
+ 
+ typedef struct {
+    u8 current_state;
+    conn_state_transition_t **transitions;
+    char *desc;
+ } conn_state_t;
+ 
+ extern conn_state_t Connection_state_table[];
+ #endif /* LLC_C_ST_H */
Index: kernel-acme/include/net/llc_conn.h
diff -c /dev/null kernel-acme/include/net/llc_conn.h:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_conn.h	Sun Aug 26 10:53:14 2001
***************
*** 0 ****
--- 1,121 ----
+ #ifndef LLC_CONN_H
+ #define LLC_CONN_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Defines the connection component */
+ /* 
+  * Structure for maintaining rx_frames or happend events that occured
+  * during processing a request. log_q(in struct p8022_connection) is a queue 
+  * of this structure. 
+ */
+ #include <linux/timer.h>
+ 
+ struct p8022_rx_object {
+ 	struct list_head node; /* node in p8022_connection log_q list */
+ 	u8 desc;
+ 	union {
+ 		struct sk_buff *skb;
+ 		void *event;
+ 	} obj;
+ };
+ 
+ struct p8022_connection {
+ 	u8		    state;              /* state of connection */
+ 	u8		    send_i_pdu_flag;    /* 1 to allow, 0 to disallow */
+ 	struct p8022_sap   *parent_sap;         /* pointer to parent SAP */
+ 	address_t	    local_dl_addr;      /* lsap/mac pair */
+ 	address_t	    remote_dl_addr;     /* lsap/mac pair */
+ 	struct list_head    node;		/* entry in sap conn_list */
+ 	struct net_device  *local_dev;          /* device to send to remote */
+ 	u8                  retry_count;        /* number of retries */
+ 	struct timer_list   ack_timer;          /* ack to I-PDU/rsp to UI PDU */
+ 	u8		    ack_running;        /* ack timer is running or no */
+ 	u8		    ack_must_be_send;
+ 	u8		    first_pdu_Ns;
+ 	u8		    npta;   
+ 	struct timer_list   pf_cycle_timer;     
+ 	u8		    pf_cycle_running;   /* pf cycle timer is running? */
+ 	struct timer_list   reject_sent_timer;  /* REJECT timer */
+ 	u8		    reject_sent_running;/* REJ timer is running or no */
+ 	struct timer_list   busy_state_timer;   /* ind busy clr at remote LLC */
+ 	u8                  busy_state_running; /* busy timer is running? */
+ 	u8                  vS;                 /* seq# next in-seq I-PDU tx'd*/
+ 	u8		    vR;                 /* seq# next in-seq I-PDU rx'd*/
+ 	u32		    n2;                 /* max nbr re-tx's for timeout*/
+ 	u32		    n1;                 /* max nbr octets in I PDU */
+ 	u8		    k;                  /* tx window size; max = 127 */
+ 	u8		    rw;                 /* rx window size; max = 127 */
+ 	u8		    min_U_pdu_len;      /* 3 (bytes) always */
+ 	u8		    min_I_S_pdu_len;    /* 4 (bytes) always */
+ 	u8		    p_flag;             /* state flags */
+ 	u8		    f_flag;
+ 	u8		    s_flag;
+ 	u8		    data_flag;
+ 	u8		    remote_busy_flag;
+ 	u8		    cause_flag;
+ 	struct sk_buff_head mac_pdu_q;   /* PDUs ready to send to MAC */
+ 	struct sk_buff_head pdu_unack_q; /* PUDs sent/waiting ack */
+ 	u16		    link_no;     /* network layer link number */
+ 	u8		    X;           /* a temporary variable */
+ 	u8		    busy;        /* llc is processing a request or no */
+ 	struct {
+ 		spinlock_t	 lock;
+ 		struct list_head list;
+ 	} log_q;			 /* frames and events(timers) that have
+ 					    received during processing a
+ 					    request */
+ 	u8		    ack_pf;      /* this flag indicates what is the
+ 					    P-bit of acknowledge. */  
+ 	u8		    failed_data_req; /* recognize that already exist a
+ 					        failed data_conn_req
+ 					        (tx_buffer_full or unacceptable
+ 					        state */
+ 	u8		    inc_step;
+ 	u8		    dec_step;
+ 	u8		    inc_cntr;
+ 	u8		    dec_cntr;
+ 	u8		    connect_step;
+ 	u8		    last_nr;	   /* NR of last pdu recieved */
+ 	int		    data_ret_val;  /* return value of data_req_handler
+ 					      function (defined in llc_if.h) */
+ 	u32		    rx_pdu_hdr;	   /* used for saving header of last pdu
+ 					      received and caused sending FRMR.
+ 					      Used for resending FRMR */
+ };
+ 
+ struct conn_state_event;
+ 
+ /* Access to a connection */
+ extern u16 conn_initialize(struct p8022_connection *conn);
+ extern u16 conn_service(struct p8022_connection *conn,
+ 		        struct conn_state_event *event);
+ extern struct conn_state_event *conn_alloc_event(struct p8022_connection *conn);
+ extern u16 conn_send_event(struct p8022_connection *conn,
+ 			   struct conn_state_event *event);
+ extern u16 conn_send_pdu(struct p8022_connection *conn, struct sk_buff *skb);
+ extern u16 conn_rtn_pdu(struct p8022_connection *conn, struct sk_buff *skb,
+ 			struct conn_state_event *event);
+ extern void conn_free_event(struct p8022_connection *conn,
+ 			    struct conn_state_event *event);
+ extern u16 conn_resend_i_pdu_as_cmd(struct p8022_connection *conn, u8 nr,
+ 				    u8 first_p_bit);
+ extern u16 conn_resend_i_pdu_as_rsp(struct p8022_connection *conn, u8 nr,
+ 				    u8 first_f_bit);
+ extern u16 conn_remove_acked_pdus(struct p8022_connection *conn, u8 nr,
+ 				  u16 *how_many_unacked);
+ extern struct p8022_connection *find_conn(struct p8022_sap *sap,
+ 					  address_t *remote_addr);
+ extern u8   data_accept_state(u8 state); 
+ extern void build_offset_table(void); 
+ extern u16  find_offset(u16 state, u16 event_type);
+ extern void inc_conn_busy(struct p8022_connection *conn);
+ extern void dec_conn_busy(struct p8022_connection *conn);
+ #endif /* LLC_CONN_H */
Index: kernel-acme/include/net/llc_evnt.h
diff -c /dev/null kernel-acme/include/net/llc_evnt.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_evnt.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,92 ----
+ #ifndef LLC_EVNT_H
+ #define LLC_EVNT_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Station component state transition events */
+ /* Types of events (possible values in 'event->type') */
+ #define STATION_EV_TYPE_SIMPLE         1
+ #define STATION_EV_TYPE_CONDITION      2
+ #define STATION_EV_TYPE_PRIM           3
+ #define STATION_EV_TYPE_PDU            4       /* command/response PDU */
+ #define STATION_EV_TYPE_ACK_TIMER      5
+ #define STATION_EV_TYPE_RPT_STATUS     6
+ 
+ /* Events */
+ #define STATION_EV_ENABLE_WITH_DUP_ADDR_CHECK                  1
+ #define STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK               2
+ #define STATION_EV_ACK_TIMER_EXPIRED_LT_RETRY_COUNT_MAX_RETRY  3
+ #define STATION_EV_ACK_TIMER_EXPIRED_EQ_RETRY_COUNT_MAX_RETRY  4
+ #define STATION_EV_RX_NULL_DSAP_XID_C                          5
+ #define STATION_EV_RX_NULL_DSAP_0_XID_R_XID_R_COUNT_EQ         6
+ #define STATION_EV_RX_NULL_DSAP_1_XID_R_XID_R_COUNT_EQ         7
+ #define STATION_EV_RX_NULL_DSAP_TEST_C                         8
+ #define STATION_EV_DISABLE_REQUEST                             9
+ 
+ /* Interfaces for various types of supported events */
+ typedef struct {
+ 	u8 event;
+ } stat_event_simple_if_t;
+ 
+ typedef struct {
+ 	u8 prim; /* connect, disconnect, reset, ... */
+ 	u8 type; /* request, indicate, response, confirm */
+ } stat_event_prim_if_t;
+ 
+ typedef struct {                      
+ 	u8 reason;
+ 	struct sk_buff *skb;
+ } stat_event_pdu_if_t;
+ 
+ typedef struct {
+ 	void *timer_specific;
+ } stat_event_timer_if_t;
+ 
+ typedef struct {
+ 	u8 status;
+ } stat_event_rpt_sts_if_t;
+ 
+ typedef union {
+ 	stat_event_simple_if_t  a;          /* 'a' for simple, easy ... */
+ 	stat_event_prim_if_t    prim;
+ 	stat_event_pdu_if_t     pdu;
+ 	stat_event_timer_if_t   tmr;
+ 	stat_event_rpt_sts_if_t rsts;       /* report status */
+ } stat_event_if_t;
+ 
+ struct station_state_event {
+ 	u8               type;
+ 	stat_event_if_t  data;
+ 	struct list_head node; /* node in station->event_q.list */
+ };
+ 
+ typedef u16 (*station_event_t)(struct p8022_station *station,
+ 			       struct station_state_event *event);
+ extern u16 stat_ev_enable_with_dup_addr_check(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ extern u16 stat_ev_enable_without_dup_addr_check(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ extern u16 stat_ev_ack_timer_expired_lt_retry_count_max_retry(struct p8022_station *
+ 									station,
+ 					     struct station_state_event *event);
+ extern u16 stat_ev_ack_timer_expired_eq_retry_count_max_retry(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ extern u16 stat_ev_rx_null_dsap_xid_c(struct p8022_station *station,
+                                       struct station_state_event *event);
+ extern u16 stat_ev_rx_null_dsap_0_xid_r_xid_r_count_eq(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ extern u16 stat_ev_rx_null_dsap_1_xid_r_xid_r_count_eq(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ extern u16 stat_ev_rx_null_dsap_test_c(struct p8022_station *station,
+                                        struct station_state_event *event);
+ extern u16 stat_ev_disable_request(struct p8022_station *station, 
+                                    struct station_state_event *event);
+ #endif /* LLC_EVNT_H */
Index: kernel-acme/include/net/llc_if.h
diff -c /dev/null kernel-acme/include/net/llc_if.h:1.1.4.3
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_if.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,150 ----
+ #ifndef LLC_IF_H
+ #define LLC_IF_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Defines LLC interface to network layer */
+ /* Available primitives */
+ #define P8022_DATAUNIT_PRIM          0
+ #define P8022_CONNECT_PRIM           1
+ #define P8022_DATA_PRIM              2
+ #define P8022_DISCONNECT_PRIM        3
+ #define P8022_RESET_PRIM             4
+ #define P8022_FLOWCONTROL_PRIM       5
+ #define P8022_DISABLE_PRIM           6
+ #define P8022_XID_PRIM               7
+ #define P8022_TEST_PRIM              8
+ #define P8022_SAP_ACTIVATION         9
+ #define P8022_SAP_DEACTIVATION       10
+ 
+ #define P8022_NBR_PRIMITIVES         11
+ 
+ #define P8022_INDICATE               1
+ #define P8022_CONFIRM                2
+  
+ /* Primitive type */
+ #define P8022_PRIM_TYPE_REQUEST      1
+ #define P8022_PRIM_TYPE_INDICATE     2
+ #define P8022_PRIM_TYPE_RESPONSE     3
+ #define P8022_PRIM_TYPE_CONFIRM      4
+ 
+ /* Reset reasons, remote entity or local LLC */
+ #define P8022_RESET_REASON_REMOTE        1
+ #define P8022_RESET_REASON_LOCAL         2
+ 
+ /* Disconnect reasons */
+ #define P8022_DISC_REASON_RX_DM_RSP_PDU          0
+ #define P8022_DISC_REASON_RX_DISC_CMD_PDU        1
+ #define P8022_DISC_REASON_ACK_TIMER_EXPIRED      2
+  
+ /* Confirm reasons */
+ #define P8022_STATUS_CONNECT		0 /* connect confirm & reset confirm */
+ #define P8022_STATUS_DISCONNECT		1 /* connect confirm & reset confirm */
+ #define P8022_STATUS_FAILED		2 /* connect confirm & reset confirm */	
+ #define P8022_STATUS_IMPOSSIBLE		3 /* connect confirm */
+ #define P8022_STATUS_RECEIVED		4 /* data conn */
+ #define P8022_STATUS_REMOTE_BUSY	5 /* data conn */
+ #define P8022_STATUS_REFUSE		6 /* data conn */
+ #define P8022_STATUS_CONFLICT		7 /* disconnect conn */
+ #define P8022_STATUS_RESET_DONE		8 /*  */
+ 
+ /* Structures and types */
+ /* SAP/MAC Address pair */
+ typedef struct {
+ 	u8 lsap;
+ 	u8 mac[6];
+ } address_t;
+ 
+ /* Primitive-specific data */
+ typedef struct {
+ 	address_t		 source_addr;	/* used by request only */
+ 	address_t		 dest_addr;	/* used by request only */
+ 	u8			 status;	/* reason for failure */	
+ 	u8			 priority;	/* service_class */
+ 	struct net_device	*device;	/* (struct net_device *) */
+ 	struct p8022_connection *connection;	/* returned from REQUEST */
+ 	u16			 link_no;
+ 	struct sk_buff		*skb;		/* received SABME  */
+ } prim_connect_t;
+ 
+ typedef struct {
+ 	struct p8022_connection *connection;
+ 	u16			 link_no;
+ 	u8			 reason;	/* not used by request */
+ } prim_disconnect_t;
+ 
+ typedef struct {
+ 	struct p8022_connection *connection;
+ 	u16			 link_no;
+ 	u8			 reason;	/* used only by indicate */
+ } prim_reset_t;
+ 
+ typedef struct {
+ 	struct p8022_connection *connection;
+ 	u16			 link_no;
+ 	u32			 amount;
+ } prim_flow_control_t;
+ 
+ typedef struct {
+ 	struct p8022_connection *connection;
+ 	u16			 link_no;
+ 	u8			 priority;
+ 	struct sk_buff		*skb;		/* pointer to frame */
+ 	u8			 status;	/* reason */
+ } prim_data_t;
+ 
+  /* Sending data in conection-less mode */
+ typedef struct {
+ 	address_t	source_addr;
+ 	address_t	dest_addr;
+ 	u8		priority;
+ 	struct sk_buff *skb;      /* pointer to frame */
+ 	u8		lfb;	     /* largest frame bit (TR) */
+ } prim_unit_data_t;
+ 
+ typedef struct {
+ 	address_t source_addr;
+ 	address_t dest_addr;
+ 	u8        priority;
+ } prim_xid_t;
+ 
+ typedef struct {
+ 	address_t	source_addr;
+ 	address_t	dest_addr;
+ 	u8		priority;
+ 	struct sk_buff *skb;           /* pointer to frame */
+ } prim_test_t;
+                        
+ typedef union {
+ 	prim_connect_t      conn;
+ 	prim_disconnect_t   disc;
+ 	prim_reset_t        res;
+ 	prim_flow_control_t fc;
+ 	prim_data_t         data;           /* data */
+ 	prim_unit_data_t    udata;          /* unit data */
+ 	prim_xid_t          xid;
+ 	prim_test_t         test;
+ } prim_data_u;
+ 
+ struct p8022_sap;
+ 
+ /* Information block passed with all called primitives */
+ struct prim_if_block {
+ 	struct p8022_sap *sap;
+ 	u8		  primitive;
+ 	prim_data_u	 *data;
+ };
+ typedef int (*primitive_call_t)(struct prim_if_block *prim_if);
+ 
+ struct p8022_sap *llc_sap_open(primitive_call_t network_indicate,
+ 			       primitive_call_t network_confirm, u8 local_sap);
+ extern void llc_sap_close(struct p8022_sap *sap);
+ #endif /* LLC_IF_H */
Index: kernel-acme/include/net/llc_mac.h
diff -c /dev/null kernel-acme/include/net/llc_mac.h:1.1.4.3
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_mac.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,40 ----
+ #ifndef LLC_MAC_H
+ #define LLC_MAC_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #define MAC_ADDR_LEN 6
+ 
+ /* 802.3/Ethernet MAC structure */
+ typedef struct {
+ 	u8  da[MAC_ADDR_LEN];	/* destination address */
+ 	u8  sa[MAC_ADDR_LEN];	/* source address */
+ 	u16 lpdu_len;		/* length of "information" */
+ } ieee_802_3_mac_hdr_t;
+ 
+ /* Token-ring MAC structure */
+ typedef struct {
+ 	u8  ac;			/* access control */
+ 	u8  fc;			/* frame control */
+ 	u8  da[MAC_ADDR_LEN];	/* destination address */
+ 	u8  sa[MAC_ADDR_LEN];	/* source address */
+ 	u16 rcf;		/* route control field */
+ 	u16 rseg[8];		/* routing registers */
+ } token_ring_mac_hdr_t;
+ 
+ /* Defines MAC-layer interface to LLC layer */
+ extern u16 mac_send_pdu(struct sk_buff *skb);
+ extern int mac_indicate(struct sk_buff *skb, struct net_device *dev,
+ 			struct packet_type *pt);
+ extern void llc_pdu_router(struct p8022_sap *sap, struct p8022_connection *conn,
+ 			   struct sk_buff *skb, u8 type);
+ extern u16 lan_hdrs_init(struct sk_buff *skb, u8 *sa, u8 *da);
+ #endif /* LLC_MAC_H */
Index: kernel-acme/include/net/llc_main.h
diff -c /dev/null kernel-acme/include/net/llc_main.h:1.1.4.8
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_main.h	Tue Aug 28 01:32:08 2001
***************
*** 0 ****
--- 1,72 ----
+ #ifndef LLC_MAIN_H
+ #define LLC_MAIN_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #define P8022_EVENT		1
+ #define P8022_FRAME		2
+ #define P8022_TYPE_1		1
+ #define P8022_TYPE_2		2
+ #define P8022_P_TIME		2
+ #define P8022_ACK_TIME	3
+ #define P8022_REJ_TIME	3
+ #define P8022_BUSY_TIME	3
+ #define P8022_SENDACK_TIME   50
+ #define P8022_DEST_INVALID	0  /* Invalid LLC PDU type */
+ #define P8022_DEST_SAP	1  /* Type 1 goes here */
+ #define P8022_DEST_CONN	2  /* Type 2 goes here */
+ 
+ /* LLC Layer global default parameters */
+ 
+ #define P8022_GLOBAL_DEFAULT_MAX_NBR_SAPS            4
+ #define P8022_GLOBAL_DEFAULT_MAX_NBR_CONNS           64
+ 
+ extern struct prim_if_block Ind_prim, Cfm_prim;
+ extern prim_data_u Ind_data_prim, Cfm_data_prim;
+ 
+ /* LLC station component (SAP and connection resource manager) */
+ /* Station component; one per adapter */
+ struct p8022_station {
+ 	u8     state;			/* state of station */
+ 	u8     xid_r_count;		/* XID response PDU counter */
+ 	struct timer_list ack_timer;
+ 	u8     ack_timer_running;	/* 1 or 0 */
+ 	u8     retry_count;
+ 	u8     maximum_retry;
+ 	u8     mac_sa[6];		/* MAC source address */
+ 	struct {
+ 		spinlock_t	 lock;
+ 		struct list_head list;
+ 	} sap_list;			/* list of related SAPs */
+ 	struct {
+ 		spinlock_t	 lock;
+ 		struct list_head list;
+ 	} event_q;			/* events entering state mach. */
+ 	struct sk_buff_head mac_pdu_q;	/* PDUs ready to send to MAC */
+ };
+ struct station_state_event;
+ 
+ extern struct p8022_sap *llc_sap_alloc(void);
+ extern void llc_sap_save(struct p8022_sap *sap);
+ extern void llc_free_sap(struct p8022_sap *sap);
+ extern struct p8022_sap *llc_sap_find(u8 lsap);
+ extern u16 llc_check_init(void);
+ extern struct p8022_connection *llc_connection_alloc(void);
+ extern void llc_connection_free(struct p8022_connection *connection);
+ extern u16 llc_connection_reset(struct p8022_connection *connection);
+ extern u16 llc_service_io(struct p8022_station *station);
+ extern struct p8022_station *station_get(void);
+ extern struct station_state_event *station_get_event(struct p8022_station *station);
+ extern u16 station_send_event(struct p8022_station *station,
+ 			      struct station_state_event *event);
+ extern u16 station_send_pdu(struct p8022_station *station, struct sk_buff *skb);
+ extern struct sk_buff *frame_pdu_allocate(void);
+ #endif /* LLC_MAIN_H */
Index: kernel-acme/include/net/llc_pdu.h
diff -c /dev/null kernel-acme/include/net/llc_pdu.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_pdu.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,258 ----
+ #ifndef LLC_PDU_H
+ #define LLC_PDU_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* LLC PDU structure */
+ /* Lengths of frame formats */
+ #define LLC_PDU_LEN_I          4       /* header and 2 control bytes */
+ #define LLC_PDU_LEN_S          4
+ #define LLC_PDU_LEN_U          3       /* header and 1 control byte */
+ /* Known SAP addresses */
+ #define GLOBAL_SAP             0xFF
+ #define NULL_SAP               0x00        /* not network-layer visible */
+ #define LLC_MGMT_INDIV         0x02        /* station LLC mgmt indiv addr */
+ #define LLC_MGMT_GRP           0x03        /* station LLC mgmt group addr */
+ #define RDE_SAP                0xA6        /* route ... */
+ 
+ /* SAP field bit masks */
+ #define ISO_RESERVED_SAP       0x02
+ #define SAP_GROUP_DSAP         0x01
+ #define SAP_RESPONSE_SSAP      0x01
+ 
+ /* Group/individual DSAP indicator is DSAP field */
+ #define LLC_PDU_GROUP_DSAP_MASK    0x01
+ #define LLC_PDU_IS_GROUP_DSAP(pdu)      \
+            ((pdu->dsap & LLC_PDU_GROUP_DSAP_MASK) ? 0 : 1)
+ #define LLC_PDU_IS_INDIV_DSAP(pdu)      \
+            (!(pdu->dsap & LLC_PDU_GROUP_DSAP_MASK) ? 0 : 1)
+ 
+ /* Command/response PDU indicator in SSAP field */
+ #define LLC_PDU_CMD_RSP_MASK   0x01
+ #define LLC_PDU_CMD            0
+ #define LLC_PDU_RSP            1
+ #define LLC_PDU_IS_CMD(pdu)    ((pdu->ssap & LLC_PDU_RSP) ? 1 : 0)
+ #define LLC_PDU_IS_RSP(pdu)    ((pdu->ssap & LLC_PDU_RSP) ? 0 : 1)
+ 
+ /* Get PDU type from 2 lowest-order bits of control field first byte */
+ #define LLC_PDU_TYPE_I_MASK    0x01        /* 16-bit control field */
+ #define LLC_PDU_TYPE_S_MASK    0x03
+ #define LLC_PDU_TYPE_U_MASK    0x03        /* 8-bit control field */
+ #define LLC_PDU_TYPE_MASK      0x03
+ 
+ #define LLC_PDU_TYPE_I         0           /* first bit */
+ #define LLC_PDU_TYPE_S         1           /* first two bits */
+ #define LLC_PDU_TYPE_U         3           /* first two bits */
+ 
+ #define LLC_PDU_TYPE_IS_I(pdu) \
+            ((!(pdu->ctrl_1 & LLC_PDU_TYPE_I_MASK)) ? 0 : 1)
+ 
+ #define LLC_PDU_TYPE_IS_U(pdu) \
+            (((pdu->ctrl_1 & LLC_PDU_TYPE_U_MASK) == LLC_PDU_TYPE_U) ? 0 : 1)
+ 
+ #define LLC_PDU_TYPE_IS_S(pdu) \
+            (((pdu->ctrl_1 & LLC_PDU_TYPE_S_MASK) == LLC_PDU_TYPE_S) ? 0 : 1)
+ 
+ /* U-format PDU control field masks */
+ #define LLC_U_PF_BIT_MASK      0x10        /* P/F bit mask */
+ #define LLC_U_PF_IS_1(pdu)     ((pdu->ctrl_1 & LLC_U_PF_BIT_MASK) ? 0 : 1)
+ #define LLC_U_PF_IS_0(pdu)     ((!(pdu->ctrl_1 & LLC_U_PF_BIT_MASK)) ? 0 : 1)
+ 
+ #define LLC_U_PDU_CMD_MASK     0xEC        /* cmd/rsp mask */
+ #define LLC_U_PDU_CMD(pdu)     (pdu->ctrl_1 & LLC_U_PDU_CMD_MASK)
+ #define LLC_U_PDU_RSP(pdu)     (pdu->ctrl_1 & LLC_U_PDU_CMD_MASK)
+ 
+ #define LLC_1_PDU_CMD_UI       0x00        /* Type 1 cmds/rsps */
+ #define LLC_1_PDU_CMD_XID      0xAC
+ #define LLC_1_PDU_CMD_TEST     0xE0
+ 
+ #define LLC_2_PDU_CMD_SABME    0x6C        /* Type 2 cmds/rsps */
+ #define LLC_2_PDU_CMD_DISC     0x40
+ #define LLC_2_PDU_RSP_UA       0x60
+ #define LLC_2_PDU_RSP_DM       0x0C
+ #define LLC_2_PDU_RSP_FRMR     0x84
+ 
+ /* Type 1 operations */
+ 
+ /* XID information field bit masks */
+ 
+ /* LLC format identifier (byte 1) */
+ #define XID_FMT_ID             0x81        /* first byte must be this */
+ 
+ /* LLC types/classes identifier (byte 2) */
+ #define XID_CLASS_ZEROS_MASK   0xE0        /* these must be zeros */
+ #define XID_CLASS_MASK         0x1F        /* AND with byte to get below */
+ 
+ #define XID_NULL_CLASS_1       0x01        /* if NULL LSAP...use these */
+ #define XID_NULL_CLASS_2       0x03
+ #define XID_NULL_CLASS_3       0x05
+ #define XID_NULL_CLASS_4       0x07
+ 
+ #define XID_NNULL_TYPE_1       0x01        /* if non-NULL LSAP...use these */
+ #define XID_NNULL_TYPE_2       0x02
+ #define XID_NNULL_TYPE_3       0x04
+ #define XID_NNULL_TYPE_1_2     0x03
+ #define XID_NNULL_TYPE_1_3     0x05
+ #define XID_NNULL_TYPE_2_3     0x06
+ #define XID_NNULL_ALL          0x07
+ 
+ /* Sender Receive Window (byte 3) */
+ #define XID_RW_MASK            0xFE        /* AND with value to get below */
+ 
+ #define XID_MIN_RW             0x02        /* lowest-order bit always zero */
+ 
+ /* Type 2 operations */
+ 
+ #define LLC_2_SEQ_NBR_MODULO   ((u8) 128)
+ 
+ /* I-PDU masks ('ctrl' is I-PDU control word) */
+ #define LLC_I_GET_NS(pdu)     (u8)((pdu->ctrl_1 & 0xFE) >> 1)
+ #define LLC_I_GET_NR(pdu)     (u8)((pdu->ctrl_2 & 0xFE) >> 1)
+ 
+ #define LLC_I_PF_BIT_MASK      0x01
+ 
+ #define LLC_I_PF_IS_0(pdu)     ((!(pdu->ctrl_2 & LLC_I_PF_BIT_MASK)) ? 0 : 1)
+ #define LLC_I_PF_IS_1(pdu)     ((pdu->ctrl_2 & LLC_I_PF_BIT_MASK) ? 0 : 1)
+ 
+ /* S-PDU supervisory commands and responses */
+ 
+ #define LLC_S_PDU_CMD_MASK     0x0C
+ #define LLC_S_PDU_CMD(pdu)     (pdu->ctrl_1 & LLC_S_PDU_CMD_MASK)
+ #define LLC_S_PDU_RSP(pdu)     (pdu->ctrl_1 & LLC_S_PDU_CMD_MASK)
+ 
+ #define LLC_2_PDU_CMD_RR       0x00        /* rx ready cmd */
+ #define LLC_2_PDU_RSP_RR       0x00        /* rx ready rsp */
+ #define LLC_2_PDU_CMD_REJ      0x08        /* reject PDU cmd */
+ #define LLC_2_PDU_RSP_REJ      0x08        /* reject PDU rsp */
+ #define LLC_2_PDU_CMD_RNR      0x04        /* rx not ready cmd */
+ #define LLC_2_PDU_RSP_RNR      0x04        /* rx not ready rsp */
+ 
+ #define LLC_S_PF_BIT_MASK      0x01
+ #define LLC_S_PF_IS_0(pdu)     ((!(pdu->ctrl_2 & LLC_S_PF_BIT_MASK)) ? 0 : 1)
+ #define LLC_S_PF_IS_1(pdu)     ((pdu->ctrl_2 & LLC_S_PF_BIT_MASK) ? 0 : 1)
+ 
+ #define PDU_SUPV_GET_Nr(pdu)   ((pdu->ctrl_2 & 0xFE) >> 1)
+ #define PDU_GET_NEXT_Vr(sn)    (++sn & ~LLC_2_SEQ_NBR_MODULO)
+ 
+ /* FRMR information field macros */
+ 
+ #define FRMR_INFO_LENGTH       5           /* 5 bytes of information */
+ 
+ /* 
+  * info is pointer to FRMR info field structure; 'rej_ctrl' is byte pointer
+  * (if U-PDU) or word pointer to rejected PDU control field
+  */
+ #define FRMR_INFO_SET_REJ_CNTRL(info,rej_ctrl) \
+    info->rej_pdu_ctrl = ((*((u8 *) rej_ctrl) & LLC_PDU_TYPE_U) != LLC_PDU_TYPE_U ? \
+                            (u16)*((u16 *) rej_ctrl) : \
+                            (((u16) *((u8 *) rej_ctrl)) & 0x00FF))
+ 
+ /* 
+  * Info is pointer to FRMR info field structure; 'vs' is a byte containing
+  * send state variable value in low-order 7 bits (insure the lowest-order
+  * bit remains zero (0)) 
+  */
+ #define FRMR_INFO_SET_Vs(info,vs) (info->curr_ssv = (((u8) vs) << 1))
+ #define FRMR_INFO_SET_Vr(info,vr) (info->curr_rsv = (((u8) vr) << 1))
+ 
+ /* 
+  * Info is pointer to FRMR info field structure; 'cr' is a byte containing
+  * the C/R bit value in the low-order bit
+  */
+ #define FRMR_INFO_SET_C_R_BIT(info, cr)  (info->curr_rsv |= (((u8) cr) & 0x01))
+ 
+ /* 
+  * In the remaining five macros, 'info' is pointer to FRMR info field
+  * structure; 'ind' is a byte containing the bit value to set in the
+  * lowest-order bit)
+  */
+ #define FRMR_INFO_SET_INVALID_PDU_CTRL_IND(info, ind) \
+        (info->ind_bits = ((info->ind_bits & 0xFE) | (((u8) ind) & 0x01)))
+ 
+ #define FRMR_INFO_SET_INVALID_PDU_INFO_IND(info, ind) \
+        (info->ind_bits = ( (info->ind_bits & 0xFD) | \
+                                            (((u8) ind) & 0x02)) )
+ 
+ #define FRMR_INFO_SET_PDU_INFO_2LONG_IND(info, ind) \
+        (info->ind_bits = ( (info->ind_bits & 0xFB) | \
+                                            (((u8) ind) & 0x04)) )
+ 
+ #define FRMR_INFO_SET_PDU_INVALID_Nr_IND(info, ind) \
+        (info->ind_bits = ( (info->ind_bits & 0xF7) | \
+                                            (((u8) ind) & 0x08)) )
+ 
+ #define FRMR_INFO_SET_PDU_INVALID_Ns_IND(info, ind) \
+        (info->ind_bits = ( (info->ind_bits & 0xEF) | \
+                                            (((u8) ind) & 0x10)) )
+ 
+ /* Sequence-numbered PDU format (4 bytes in length) */
+ typedef struct {
+    u8 dsap;
+    u8 ssap;
+    u8 ctrl_1;
+    u8 ctrl_2;
+ } pdu_sn_t;
+ 
+ /* Un-numbered PDU format (3 bytes in length) */
+ typedef struct {
+    u8 dsap;
+    u8 ssap;
+    u8 ctrl_1;
+ } pdu_un_t;
+ 
+ /* LLC Type 1 XID command/response information fields format */
+ typedef struct {
+    u8 fmt_id;             /* always 0x18 for LLC */
+    u8 type;               /* different if NULL/non-NULL LSAP */
+    u8 rw;                 /* sender receive window */   
+ } xid_info_t;
+ 
+ /* LLC Type 2 FRMR response information field format */
+ typedef struct {
+    u16 rej_pdu_ctrl;       /* bits 1-8 if U-PDU */
+    u8  curr_ssv;           /* current send state variable val */
+    u8  curr_rsv;           /* current receive state variable */
+    u8  ind_bits;           /* indicator bits set with macro */
+ } frmr_info_t;
+ 
+ extern u16 pdu_set_cmd_rsp(struct sk_buff *skb, u8 type);
+ extern u16 pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value);
+ extern u16 pdu_decode_pf_bit(struct sk_buff *skb, u8 *pf_bit);
+ extern u16 pdu_decode_cr_bit(struct sk_buff *skb, u8 *cr_bit);
+ extern u16 pdu_decode_sa(struct sk_buff *skb, u8 *sa);
+ extern u16 pdu_decode_da(struct sk_buff *skb, u8 *ds);
+ extern u16 pdu_decode_dsap(struct sk_buff *skb, u8 *dsap);
+ extern u16 pdu_decode_ssap(struct sk_buff *skb, u8 *ssap);
+ extern u16 decode_pdu_type(struct sk_buff *skb, u8 *destination);
+ extern u16 pdu_header_init(struct sk_buff *skb, u8 pdu_type, u8 ssap,
+ 			   u8 dsap, u8 cr);
+ extern u16 pdu_init_as_ui_cmd(struct sk_buff *skb);
+ extern u16 pdu_init_as_xid_cmd(struct sk_buff *skb, u8 svcs_supported,
+ 			       u8 rx_window);
+ extern u16 pdu_init_as_test_cmd(struct sk_buff *skb);
+ extern u16 pdu_init_as_disc_cmd(struct sk_buff *skb, u8 p_bit);
+ extern u16 pdu_init_as_i_cmd(struct sk_buff *skb, u8 p_bit, u8 ns, u8 nr);
+ extern u16 pdu_init_as_rej_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+ extern u16 pdu_init_as_rnr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+ extern u16 pdu_init_as_rr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+ extern u16 pdu_init_as_sabme_cmd(struct sk_buff *skb, u8 p_bit);
+ extern u16 pdu_init_as_dm_rsp(struct sk_buff *skb, u8 f_bit);
+ extern u16 pdu_init_as_xid_rsp(struct sk_buff *skb, u8 svcs_supported,
+ 			       u8 rx_window);
+ extern u16 pdu_init_as_test_rsp(struct sk_buff *skb, struct sk_buff *ev_skb);
+ extern u16 pdu_init_as_frmr_rsp(struct sk_buff *skb,
+ 				pdu_sn_t *prev_pdu, u8 f_bit, u8 vs,
+ 				u8 vr, u8 vzyxw);
+ extern u16 pdu_init_as_rr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+ extern u16 pdu_init_as_rej_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+ extern u16 pdu_init_as_rnr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+ extern u16 pdu_init_as_ua_rsp(struct sk_buff *skb, u8 f_bit);
+ #endif /* LLC_PDU_H */
Index: kernel-acme/include/net/llc_s_ac.h
diff -c /dev/null kernel-acme/include/net/llc_s_ac.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_s_ac.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,47 ----
+ #ifndef LLC_S_AC_H
+ #define LLC_S_AC_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* SAP component actions */
+ #define SAP_ACT_UNITDATA_INDICATION        1
+ #define SAP_ACT_SEND_UI                    2
+ #define SAP_ACT_SEND_XID_C                 3
+ #define SAP_ACT_SEND_XID_R                 4
+ #define SAP_ACT_SEND_TEST_C                5
+ #define SAP_ACT_SEND_TEST_R                6
+ #define SAP_ACT_REPORT_STATUS              7
+ #define SAP_ACT_XID_INDICATION             8
+ #define SAP_ACT_TEST_INDICATION            9
+ 
+ /* All action functions must look like this */
+ typedef u16 (*sap_action_t)(struct p8022_sap *sap,
+ 			    struct sap_state_event *event);
+ 
+ extern u16 sap_action_unitdata_indication(struct p8022_sap *sap,
+ 					  struct sap_state_event *event);
+ extern u16 sap_action_send_ui(struct p8022_sap *sap,
+ 			      struct sap_state_event *event);
+ extern u16 sap_action_send_xid_c(struct p8022_sap *sap,
+ 				 struct sap_state_event *event);
+ extern u16 sap_action_send_xid_r(struct p8022_sap *sap,
+ 				 struct sap_state_event *event);
+ extern u16 sap_action_send_test_c(struct p8022_sap *sap,
+ 				  struct sap_state_event *event);
+ extern u16 sap_action_send_test_r(struct p8022_sap *sap,
+ 				  struct sap_state_event *event);
+ extern u16 sap_action_report_status(struct p8022_sap *sap,
+ 				    struct sap_state_event *event);
+ extern u16 sap_action_xid_indication(struct p8022_sap *sap,
+ 				     struct sap_state_event *event);
+ extern u16 sap_action_test_indication(struct p8022_sap *sap,
+ 				      struct sap_state_event *event);
+ #endif /* LLC_S_AC_H */
Index: kernel-acme/include/net/llc_s_ev.h
diff -c /dev/null kernel-acme/include/net/llc_s_ev.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:24 2001
--- kernel-acme/include/net/llc_s_ev.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,105 ----
+ #ifndef LLC_S_EV_H
+ #define LLC_S_EV_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Defines SAP component events */
+ /* Types of events (possible values in 'event->type') */
+ #define SAP_EV_TYPE_SIMPLE             1
+ #define SAP_EV_TYPE_CONDITION          2
+ #define SAP_EV_TYPE_PRIM               3
+ #define SAP_EV_TYPE_PDU                4   /* command/response PDU */
+ #define SAP_EV_TYPE_ACK_TIMER          5
+ #define SAP_EV_TYPE_RPT_STATUS         6
+ 
+ #define SAP_EV_ACTIVATION_REQUEST      1
+ #define SAP_EV_RX_UI                   2
+ #define SAP_EV_UNITDATA_REQUEST        3
+ #define SAP_EV_XID_REQUEST             4
+ #define SAP_EV_RX_XID_C                5
+ #define SAP_EV_RX_XID_R                6
+ #define SAP_EV_TEST_REQUEST            7
+ #define SAP_EV_RX_TEST_C               8
+ #define SAP_EV_RX_TEST_R               9
+ #define SAP_EV_DEACTIVATION_REQUEST    10
+ 
+ /* Interfaces for various types of supported events */
+ typedef struct {
+    u8 event;
+ } sap_event_simple_if_t;
+ 
+ struct prim_if_block;
+ 
+ typedef struct {
+    u8    prim;   /* connect, disconnect, reset, ... */
+    u8    type;   /* request, indicate, response, confirm */
+    struct prim_if_block *data;
+ } sap_event_prim_if_t;
+ 
+ typedef struct {                      
+    u8 event;
+    u8 reason;
+    struct sk_buff *skb;
+ } sap_event_pdu_if_t;
+ 
+ typedef struct {
+    void *timer_specific;
+ } sap_event_timer_if_t;
+ 
+ typedef struct {
+    u8 status;
+ } sap_event_rpt_sts_if_t;
+ 
+ 
+ typedef union
+ {
+    sap_event_simple_if_t   a;          /* 'a' for simple, easy ... */
+    sap_event_prim_if_t     prim;
+    sap_event_pdu_if_t      pdu;
+    sap_event_timer_if_t    tmr;
+    sap_event_rpt_sts_if_t  rsts;       /* report status */
+ } sap_event_if_t;
+ 
+ struct prim_if_block;
+ 
+ struct sap_state_event {
+    u8               type;
+    u8               ind_cfm_flag;
+    struct prim_if_block *prim;
+    sap_event_if_t   data;
+ };
+ 
+ struct p8022_sap;
+ 
+ typedef u16 (*sap_event_t)(struct p8022_sap *sap,
+ 			   struct sap_state_event *event);
+ 
+ extern u16 sap_ev_activation_request(struct p8022_sap *sap,
+ 				     struct sap_state_event *event);
+ extern u16 sap_ev_rx_ui(struct p8022_sap *sap,
+ 			struct sap_state_event *event);
+ extern u16 sap_ev_unitdata_request(struct p8022_sap *sap,
+ 				   struct sap_state_event *event);
+ extern u16 sap_ev_xid_request(struct p8022_sap *sap,
+ 			      struct sap_state_event *event);
+ extern u16 sap_ev_rx_xid_c(struct p8022_sap *sap,
+ 			   struct sap_state_event *event);
+ extern u16 sap_ev_rx_xid_r(struct p8022_sap *sap,
+ 			   struct sap_state_event *event);
+ extern u16 sap_ev_test_request(struct p8022_sap *sap,
+ 			       struct sap_state_event *event);
+ extern u16 sap_ev_rx_test_c(struct p8022_sap *sap,
+ 			    struct sap_state_event *event);
+ extern u16 sap_ev_rx_test_r(struct p8022_sap *sap,
+ 			    struct sap_state_event *event);
+ extern u16 sap_ev_deactivation_request(struct p8022_sap *sap,
+ 				       struct sap_state_event *event); 
+ #endif /* LLC_S_EV_H */
Index: kernel-acme/include/net/llc_s_st.h
diff -c /dev/null kernel-acme/include/net/llc_s_st.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:25 2001
--- kernel-acme/include/net/llc_s_st.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,34 ----
+ #ifndef LLC_S_ST_H
+ #define LLC_S_ST_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Defines SAP component states */
+ 
+ #define SAP_STATE_INACTIVE         1
+ #define SAP_STATE_ACTIVE           2
+ #define NBR_SAP_STATES             2       /* size of state table */
+ /* structures and types */
+ /* SAP state table structure */
+ typedef struct {
+ 	sap_event_t   event;
+ 	u8            next_state;
+ 	sap_action_t *event_actions;
+ } sap_state_transition_t;
+ 
+ typedef struct {
+     u8 current_state;
+     sap_state_transition_t **transitions;
+ } sap_state_t;
+ 
+ /* only access to SAP state table */
+ extern sap_state_t Sap_state_table[NBR_SAP_STATES];
+ #endif /* LLC_S_ST_H */
Index: kernel-acme/include/net/llc_sap.h
diff -c /dev/null kernel-acme/include/net/llc_sap.h:1.1.4.3
*** /dev/null	Wed Sep  5 00:22:25 2001
--- kernel-acme/include/net/llc_sap.h	Sun Aug 26 11:37:00 2001
***************
*** 0 ****
--- 1,47 ----
+ #ifndef LLC_SAP_H
+ #define LLC_SAP_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Defines the SAP component */
+ struct p8022_sap {
+ 	u8			state;
+ 	struct p8022_station   *parent_station;
+ 	u8			p_bit;		/* only lowest-order bit used */
+ 	u8			f_bit;		/* only lowest-order bit used */
+ 	primitive_call_t	request;	/* provided by LLC layer */
+ 	primitive_call_t	response;	/* provided by LLC layer */
+ 	primitive_call_t	indicate;	/* provided by network layer */
+ 	primitive_call_t	confirm;	/* provided by network layer */
+ 	address_t		local_dl_addr;	/* SAP value in this 'lsap' */
+ 	struct list_head	node;		/* entry in station sap_list */
+ 	struct {
+ 		spinlock_t	 lock;
+ 		struct list_head list;
+ 	} connection_list; /* connections this one manages */
+ 	struct sk_buff_head mac_pdu_q;		/* PDUs ready to send to MAC */
+ };
+ struct p8022_connection;
+ struct sap_state_event;
+ 
+ extern u16 sap_initialize(struct p8022_sap *sap);
+ extern void sap_assign_conn(struct p8022_sap *sap,
+ 			    struct p8022_connection *connection);
+ extern void sap_unassign_conn(struct p8022_sap *sap,
+ 			      struct p8022_connection *connection);
+ extern struct p8022_connection *sap_find_conn(struct p8022_sap *sap,
+ 					      address_t *remote_addr);
+ extern struct sap_state_event *sap_get_event(struct p8022_sap *sap);
+ extern u16 sap_send_event(struct p8022_sap *sap, struct sap_state_event *event);
+ extern u16 sap_rtn_pdu(struct p8022_sap *sap, struct sk_buff *skb,
+ 		       struct sap_state_event *event);
+ extern u16 sap_send_pdu(struct p8022_sap *sap, struct sk_buff *skb);
+ #endif /* LLC_SAP_H */
Index: kernel-acme/include/net/llc_stat.h
diff -c /dev/null kernel-acme/include/net/llc_stat.h:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:25 2001
--- kernel-acme/include/net/llc_stat.h	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,39 ----
+ #ifndef LLC_STAT_H
+ #define LLC_STAT_H
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ /* Station component state table */
+ /* Station component states */
+ #define STATION_STATE_DOWN             1           /* initial state */
+ #define STATION_STATE_DUP_ADDR_CHK     2
+ #define STATION_STATE_UP               3
+ 
+ #define NBR_STATION_STATES             3           /* size of state table */
+ 
+ /* Station component state table structure */
+ typedef struct {
+ #if 0
+ 	u8 event;
+ #else
+ 	station_event_t event;
+ #endif
+ 	u8 next_state;
+ 	station_action_t *event_actions;
+ } station_state_transition_t;
+ 
+ typedef struct {
+ 	u8 current_state;
+ 	station_state_transition_t **transitions;
+ } station_state_t;
+ 
+ extern station_state_t Station_state_table[NBR_STATION_STATES];
+ #endif /* LLC_STAT_H */
Index: kernel-acme/include/net/p8022.h
diff -c kernel-acme/include/net/p8022.h:1.1.1.1 kernel-acme/include/net/p8022.h:1.1.1.1.4.1
*** kernel-acme/include/net/p8022.h:1.1.1.1	Tue Jun 26 14:33:57 2001
--- kernel-acme/include/net/p8022.h	Thu Aug 16 22:26:36 2001
***************
*** 1,7 ****
  #ifndef _NET_P8022_H
  #define _NET_P8022_H
! 
! extern struct datalink_proto *register_8022_client(unsigned char type, int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *));
  extern void unregister_8022_client(unsigned char type);
- 
  #endif
--- 1,9 ----
  #ifndef _NET_P8022_H
  #define _NET_P8022_H
! extern struct datalink_proto *register_8022_client(unsigned char type,
! 						   int (*rcvfunc)
! 						   	(struct sk_buff *,
! 							 struct net_device *,
! 							 struct packet_type *));
  extern void unregister_8022_client(unsigned char type);
  #endif
Index: kernel-acme/include/net/sock.h
diff -c kernel-acme/include/net/sock.h:1.1.1.2 kernel-acme/include/net/sock.h:1.1.1.2.2.1
*** kernel-acme/include/net/sock.h:1.1.1.2	Thu Aug 16 19:25:30 2001
--- kernel-acme/include/net/sock.h	Thu Aug 16 22:26:36 2001
***************
*** 24,29 ****
--- 24,30 ----
   *		Alan Cox	:	Eliminate low level recv/recvfrom
   *		David S. Miller	:	New socket lookup architecture.
   *              Steve Whitehouse:       Default routines for sock_ops
+  *              Arnaldo C. Melo :	include netbeui_sock in sock->protinfo
   *
   *		This program is free software; you can redistribute it and/or
   *		modify it under the terms of the GNU General Public License
***************
*** 94,99 ****
--- 95,103 ----
  #if defined(CONFIG_IRDA) || defined(CONFIG_IRDA_MODULE)
  #include <net/irda/irda.h>
  #endif
+ #if defined(CONFIG_NETBEUI) || defined(CONFIG_NETBEUI_MODULE)
+ #include <linux/netbeui.h>	/* struct netbeui_sock */
+ #endif
  
  #if defined(CONFIG_ATM) || defined(CONFIG_ATM_MODULE)
  struct atm_vcc;
***************
*** 652,657 ****
--- 656,664 ----
  #endif
  #if defined(CONFIG_IRDA) || defined(CONFIG_IRDA_MODULE)
  		struct irda_sock        *irda;
+ #endif
+ #if defined(CONFIG_NETBEUI) || defined(CONFIG_NETBEUI_MODULE)
+ 		struct netbeui_sock     *af_netbeui;
  #endif
  #if defined(CONFIG_WAN_ROUTER) || defined(CONFIG_WAN_ROUTER_MODULE)
                 struct wanpipe_opt      *af_wanpipe;
Index: kernel-acme/include/net/usr_to_krnl.h
diff -c /dev/null kernel-acme/include/net/usr_to_krnl.h:1.1.4.1
*** /dev/null	Wed Sep  5 00:22:25 2001
--- kernel-acme/include/net/usr_to_krnl.h	Thu Aug 16 22:26:36 2001
***************
*** 0 ****
--- 1,66 ----
+ /*
+  * Copyright (c) 1997 by Procom Technology,Inc.
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  *
+  */
+  
+ #ifndef USR_TO_KRNL_H
+ #define USR_TO_KRNL_H
+ 
+ 
+ 
+ #define  CONNECT_PRIM               1
+ #define  I_PRIM                     2
+ #define  DISCONNECT_PRIM            3
+ #define  RESET_PRIM                 4
+ 
+ #define  LBUSY_DET                  5
+ #define  LBUSY_CLR                  6
+ 
+ #define  SEND_I_C                   7
+ #define  SEND_I_R                   8
+ #define  SEND_SABME_C               9
+ #define  SEND_UA_R                  10
+ #define  SEND_DISC_C                11
+ #define  SEND_DM_R                  12
+ #define  SEND_REJ_C                 13
+ #define  SEND_REJ_R                 14
+ #define  SEND_RR_C                  15
+ #define  SEND_RR_R                  16
+ #define  SEND_RNR_C                 17
+ #define  SEND_RNR_R                 18
+ #define  SEND_FRMR_R                19
+ 
+ 
+ typedef struct
+ {
+    unsigned char p_flag, f_flag, s_flag, rmt_busy_flag;
+    unsigned char retry_count;
+    unsigned long n1, n2;
+ 
+    unsigned char vr, vs;
+    int set_vr, set_vs;
+ 
+ } ConnecInfo;
+ 
+ 
+ #define DEST_MACH_NAME_LEN 39
+ 
+ typedef struct
+ {
+    int pf_bit;
+    char dest_machine[DEST_MACH_NAME_LEN+1];
+    ConnecInfo c_info;
+ } LLC_Data;
+ 
+ 
+ #define LLC_CALL(fd, func_id, llcd)\
+    (ioctl((fd), (func_id), (llcd)) < 0? (printf("\nError in IOCTL"), 1): 0)
+ 
+ #endif
Index: kernel-acme/net/Config.in
diff -c kernel-acme/net/Config.in:1.1.1.1 kernel-acme/net/Config.in:1.1.1.1.4.1
*** kernel-acme/net/Config.in:1.1.1.1	Tue Jun 26 14:28:54 2001
--- kernel-acme/net/Config.in	Thu Aug 16 22:26:36 2001
***************
*** 62,72 ****
  if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
     tristate 'CCITT X.25 Packet Layer (EXPERIMENTAL)' CONFIG_X25
     tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
!    bool '802.2 LLC (EXPERIMENTAL)' CONFIG_LLC
     bool 'Frame Diverter (EXPERIMENTAL)' CONFIG_NET_DIVERT
- #   if [ "$CONFIG_LLC" = "y" ]; then
- #      bool '  Netbeui (EXPERIMENTAL)' CONFIG_NETBEUI
- #   fi
     if [ "$CONFIG_INET" = "y" ]; then
        tristate 'Acorn Econet/AUN protocols (EXPERIMENTAL)' CONFIG_ECONET
     fi
--- 62,72 ----
  if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
     tristate 'CCITT X.25 Packet Layer (EXPERIMENTAL)' CONFIG_X25
     tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
!    tristate 'ANSI/IEEE 802.2 Data link layer protocol' CONFIG_LLC
!    if [ "$CONFIG_LLC" != "n" ]; then
!       tristate 'The NETBEUI protocol' CONFIG_NETBEUI
!    fi
     bool 'Frame Diverter (EXPERIMENTAL)' CONFIG_NET_DIVERT
     if [ "$CONFIG_INET" = "y" ]; then
        tristate 'Acorn Econet/AUN protocols (EXPERIMENTAL)' CONFIG_ECONET
     fi
Index: kernel-acme/net/Makefile
diff -c kernel-acme/net/Makefile:1.1.1.2 kernel-acme/net/Makefile:1.1.1.2.2.1
*** kernel-acme/net/Makefile:1.1.1.2	Thu Aug 16 15:44:03 2001
--- kernel-acme/net/Makefile	Thu Aug 16 22:26:36 2001
***************
*** 7,13 ****
  
  O_TARGET :=	network.o
  
! mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda bluetooth atm netlink sched
  export-objs :=	netsyms.o
  
  subdir-y :=	core ethernet
--- 7,13 ----
  
  O_TARGET :=	network.o
  
! mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda bluetooth atm netlink sched 8022llc netbeui
  export-objs :=	netsyms.o
  
  subdir-y :=	core ethernet
***************
*** 45,50 ****
--- 45,52 ----
  subdir-$(CONFIG_ATM)		+= atm
  subdir-$(CONFIG_DECNET)		+= decnet
  subdir-$(CONFIG_ECONET)		+= econet
+ subdir-$(CONFIG_LLC)		+= 8022llc
+ subdir-$(CONFIG_NETBEUI)	+= netbeui
  
  
  obj-y	:= socket.o $(join $(subdir-y), $(patsubst %,/%.o,$(notdir $(subdir-y))))
Index: kernel-acme/net/netsyms.c
diff -c kernel-acme/net/netsyms.c:1.1.1.4 kernel-acme/net/netsyms.c:1.1.1.4.2.1
*** kernel-acme/net/netsyms.c:1.1.1.4	Thu Aug 16 18:59:24 2001
--- kernel-acme/net/netsyms.c	Thu Aug 16 22:26:36 2001
***************
*** 103,108 ****
--- 103,109 ----
  
  /* Socket layer support routines */
  EXPORT_SYMBOL(memcpy_fromiovec);
+ EXPORT_SYMBOL(memcpy_fromiovecend);
  EXPORT_SYMBOL(memcpy_tokerneliovec);
  EXPORT_SYMBOL(sock_create);
  EXPORT_SYMBOL(sock_alloc);
Index: kernel-acme/net/802/p8022.c
diff -c kernel-acme/net/802/p8022.c:1.1.1.1 kernel-acme/net/802/p8022.c:1.1.1.1.4.1
*** kernel-acme/net/802/p8022.c:1.1.1.1	Tue Jun 26 14:28:54 2001
--- kernel-acme/net/802/p8022.c	Thu Aug 16 22:26:36 2001
***************
*** 11,21 ****
   *		matches. The control byte is ignored and handling of such items
   *		is up to the routine passed the frame.
   *
!  *		Unlike the 802.3 datalink we have a list of 802.2 entries as there
!  *		are multiple protocols to demux. The list is currently short (3 or
!  *		4 entries at most). The current demux assumes this.
   */
- 
  #include <linux/module.h>
  #include <linux/netdevice.h>
  #include <linux/skbuff.h>
--- 11,20 ----
   *		matches. The control byte is ignored and handling of such items
   *		is up to the routine passed the frame.
   *
!  *		Unlike the 802.3 datalink we have a list of 802.2 entries as
!  *		there are multiple protocols to demux. The list is currently
!  *		short (3 or 4 entries at most). The current demux assumes this.
   */
  #include <linux/module.h>
  #include <linux/netdevice.h>
  #include <linux/skbuff.h>
***************
*** 25,32 ****
  #include <linux/init.h>
  #include <net/p8022.h>
  
! static struct datalink_proto *p8022_list = NULL;
  
  /*
   *	We don't handle the loopback SAP stuff, the extended
   *	802.2 command set, multicast SAP identifiers and non UI
--- 24,36 ----
  #include <linux/init.h>
  #include <net/p8022.h>
  
! extern void P8022_register_sap(unsigned char sap,
! 			       int (*rcvfunc)(struct sk_buff *,
! 					      struct net_device *,
! 					       struct packet_type *));
! extern void P8022_unregister_sap(unsigned char sap);
  
+ static struct datalink_proto *p8022_list;
  /*
   *	We don't handle the loopback SAP stuff, the extended
   *	802.2 command set, multicast SAP identifiers and non UI
***************
*** 34,124 ****
   *	IP and Appletalk phase 2. See the llc_* routines for
   *	support libraries if your protocol needs these.
   */
- 
  static struct datalink_proto *find_8022_client(unsigned char type)
  {
! 	struct datalink_proto	*proto;
! 
! 	for (proto = p8022_list;
! 		((proto != NULL) && (*(proto->type) != type));
! 		proto = proto->next)
! 		;
  
  	return proto;
  }
  
! int p8022_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt)
  {
! 	struct datalink_proto	*proto;
  
  	proto = find_8022_client(*(skb->h.raw));
! 	if (proto != NULL) 
! 	{
! 		skb->h.raw += 3;
! 		skb->nh.raw += 3;
! 		skb_pull(skb,3);
! 		return proto->rcvfunc(skb, dev, pt);
  	}
! 
! 	skb->sk = NULL;
! 	kfree_skb(skb);
! 	return 0;
  }
  
  static void p8022_datalink_header(struct datalink_proto *dl,
! 		struct sk_buff *skb, unsigned char *dest_node)
  {
! 	struct net_device	*dev = skb->dev;
! 	unsigned char	*rawp;
  
- 	rawp = skb_push(skb,3);
  	*rawp++ = dl->type[0];
  	*rawp++ = dl->type[0];
! 	*rawp = 0x03;	/* UI */
  	dev->hard_header(skb, dev, ETH_P_802_3, dest_node, NULL, skb->len);
  }
- 
- static struct packet_type p8022_packet_type =
- {
- 	0,	/* MUTTER ntohs(ETH_P_8022),*/
- 	NULL,		/* All devices */
- 	p8022_rcv,
- 	NULL,
- 	NULL,
- };
- 
- EXPORT_SYMBOL(register_8022_client);
- EXPORT_SYMBOL(unregister_8022_client);
- 
- static int __init p8022_init(void)
- {
- 	p8022_packet_type.type=htons(ETH_P_802_2);
- 	dev_add_pack(&p8022_packet_type);
- 	return 0;
- }
  
! module_init(p8022_init);
! 
! struct datalink_proto *register_8022_client(unsigned char type, int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *))
! {
! 	struct datalink_proto	*proto;
! 
! 	if (find_8022_client(type) != NULL)
! 		return NULL;
! 
! 	proto = (struct datalink_proto *) kmalloc(sizeof(*proto), GFP_ATOMIC);
! 	if (proto != NULL) {
! 		proto->type[0] = type;
! 		proto->type_len = 1;
! 		proto->rcvfunc = rcvfunc;
! 		proto->header_length = 3;
! 		proto->datalink_header = p8022_datalink_header;
! 		proto->string_name = "802.2";
! 		proto->next = p8022_list;
! 		p8022_list = proto;
  	}
! 
! 	return proto;
  }
  
  void unregister_8022_client(unsigned char type)
--- 38,105 ----
   *	IP and Appletalk phase 2. See the llc_* routines for
   *	support libraries if your protocol needs these.
   */
  static struct datalink_proto *find_8022_client(unsigned char type)
  {
! 	struct datalink_proto *proto = p8022_list;
  
+ 	while (proto && *(proto->type) != type)
+ 		proto = proto->next;
  	return proto;
  }
  
! int p8022_rcv(struct sk_buff *skb, struct net_device *dev,
! 	      struct packet_type *pt)
  {
! 	struct datalink_proto *proto;
! 	int rc = 0;
  
  	proto = find_8022_client(*(skb->h.raw));
! 	if (!proto) {
! 		skb->sk = NULL;
! 		kfree_skb(skb);
! 		goto out;
  	}
! 	skb->h.raw += 3;
! 	skb->nh.raw += 3;
! 	skb_pull(skb, 3);
! 	rc = proto->rcvfunc(skb, dev, pt);
! out:	return rc;
  }
  
  static void p8022_datalink_header(struct datalink_proto *dl,
! 				  struct sk_buff *skb, unsigned char *dest_node)
  {
! 	struct net_device *dev = skb->dev;
! 	unsigned char *rawp = skb_push(skb, 3);
  
  	*rawp++ = dl->type[0];
  	*rawp++ = dl->type[0];
! 	*rawp	= 0x03;	/* UI */
  	dev->hard_header(skb, dev, ETH_P_802_3, dest_node, NULL, skb->len);
  }
  
! struct datalink_proto *register_8022_client(unsigned char type,
! 					    int (*rcvfunc)(struct sk_buff *,
! 						    	   struct net_device *,
! 							  struct packet_type *))
! {
! 	struct datalink_proto *proto = NULL;
! 
! 	if (find_8022_client(type))
! 		goto out;
! 	proto = kmalloc(sizeof(*proto), GFP_ATOMIC);
! 	if (proto) {
! 		proto->type[0]		= type;
! 		proto->type_len		= 1;
! 		proto->rcvfunc		= rcvfunc;
! 		proto->header_length	= 3;
! 		proto->datalink_header	= p8022_datalink_header;
! 		proto->string_name	= "802.2";
! 		proto->next		= p8022_list;
! 		p8022_list		= proto;
! 		P8022_register_sap(type, p8022_rcv);
  	}
! out:	return proto;
  }
  
  void unregister_8022_client(unsigned char type)
***************
*** 128,144 ****
  
  	save_flags(flags);
  	cli();
! 
! 	while ((tmp = *clients) != NULL)
! 	{
  		if (tmp->type[0] == type) {
  			*clients = tmp->next;
  			kfree(tmp);
  			break;
- 		} else {
- 			clients = &tmp->next;
  		}
  	}
- 
  	restore_flags(flags);
  }
--- 109,126 ----
  
  	save_flags(flags);
  	cli();
! 	while (*clients) {
! 		tmp = *clients;
  		if (tmp->type[0] == type) {
  			*clients = tmp->next;
  			kfree(tmp);
+ 			P8022_unregister_sap(type);
  			break;
  		}
+ 		clients = &tmp->next;
  	}
  	restore_flags(flags);
  }
+ 
+ EXPORT_SYMBOL(register_8022_client);
+ EXPORT_SYMBOL(unregister_8022_client);
Index: kernel-acme/net/802/tr.c
diff -c kernel-acme/net/802/tr.c:1.1.1.1 kernel-acme/net/802/tr.c:1.1.1.1.4.1
*** kernel-acme/net/802/tr.c:1.1.1.1	Tue Jun 26 14:28:54 2001
--- kernel-acme/net/802/tr.c	Thu Aug 16 22:26:36 2001
***************
*** 36,42 ****
  #include <linux/init.h>
  #include <net/arp.h>
  
! static void tr_source_route(struct sk_buff *skb, struct trh_hdr *trh, struct net_device *dev);
  static void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev);
  static void rif_check_expire(unsigned long dummy);
  
--- 36,43 ----
  #include <linux/init.h>
  #include <net/arp.h>
  
! void tr_source_route(struct sk_buff *skb, struct trh_hdr *trh,
! 		     struct net_device *dev);
  static void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev);
  static void rif_check_expire(unsigned long dummy);
  
***************
*** 65,71 ****
   *	up a lot.
   */
   
! rif_cache rif_table[RIF_TABLE_SIZE]={ NULL, };
  
  static spinlock_t rif_lock = SPIN_LOCK_UNLOCKED;
  
--- 66,72 ----
   *	up a lot.
   */
   
! rif_cache rif_table[RIF_TABLE_SIZE];
  
  static spinlock_t rif_lock = SPIN_LOCK_UNLOCKED;
  
***************
*** 230,236 ****
   *	We try to do source routing... 
   */
  
! static void tr_source_route(struct sk_buff *skb,struct trh_hdr *trh,struct net_device *dev) 
  {
  	int i, slack;
  	unsigned int hash;
--- 231,238 ----
   *	We try to do source routing... 
   */
  
! void tr_source_route(struct sk_buff *skb, struct trh_hdr *trh,
! 		     struct net_device *dev) 
  {
  	int i, slack;
  	unsigned int hash;
Index: kernel-acme/net/8022llc/Makefile
diff -c /dev/null kernel-acme/net/8022llc/Makefile:1.1.4.6
*** /dev/null	Wed Sep  5 00:22:27 2001
--- kernel-acme/net/8022llc/Makefile	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,34 ----
+ ###########################################################################
+ # Makefile for the Linux 802.2 LLC (fully-functional) layer.
+ #
+ # Note 1! Dependencies are done automagically by 'make dep', which also
+ # removes any old dependencies. DON'T put your own dependencies here
+ # unless it's something special (ie not a .c file).
+ #
+ # Note 2! The CFLAGS definition is now in the main makefile...
+ #
+ # Copyright (c) 1997 by Procom Technology,Inc.
+ #		2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ #
+ # This program can be redistributed or modified under the terms of the 
+ # GNU General Public License as published by the Free Software Foundation.
+ # This program is distributed without any warranty or implied warranty
+ # of merchantability or fitness for a particular purpose.
+ #
+ # See the GNU General Public License for more details.
+ ###########################################################################
+ 
+ O_TARGET := 8022llc.o
+ 
+ obj-y := llc_if.o llc_c_ev.o llc_c_ac.o llc_mac.o llc_sap.o llc_s_st.o \
+ 	 llc_main.o llc_s_ac.o llc_conn.o llc_c_st.o llc_stat.o llc_actn.o \
+ 	 llc_s_ev.o llc_evnt.o llc_pdu.o llc_cmd_rsp.o
+ 
+ # Objects that export symbols.
+ export-objs := llc_if.o
+ 
+ ifeq ($(CONFIG_LLC),m)
+   obj-m += $(O_TARGET)
+ endif
+ 
+ include $(TOPDIR)/Rules.make
Index: kernel-acme/net/8022llc/llc_actn.c
diff -c /dev/null kernel-acme/net/8022llc/llc_actn.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:27 2001
--- kernel-acme/net/8022llc/llc_actn.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,150 ----
+ /*
+  * llc_actn.c - Implementation of actions of station component of LLC
+  *
+  * Description :
+  *   Functions in this module are implementation of station component actions.
+  *   Details of actions can be found in IEEE-802.2 standard document.
+  *   All functions have one station and one event as input argument. All of
+  *   them return 0 On success and 1 otherwise.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netdevice.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_evnt.h>
+ #include <net/llc_actn.h>
+ #include <net/llc_pdu.h>
+ #include <net/llc_mac.h>
+ 
+ static void station_ack_timer_callback(unsigned long timeout_data);
+ 
+ u16 station_ac_start_ack_timer(struct p8022_station *station,
+ 			       struct station_state_event *event)
+ {
+ 	del_timer(&station->ack_timer);
+ 	station->ack_timer.expires  = jiffies + P8022_ACK_TIME * HZ;
+ 	station->ack_timer.data     = (unsigned long)station;
+ 	station->ack_timer.function = station_ack_timer_callback;
+ 	add_timer(&station->ack_timer);
+ 	station->ack_timer_running = 1;
+ 	return 0;
+ }
+ 
+ u16 station_ac_set_retry_count_0(struct p8022_station *station,
+ 				 struct station_state_event *event)
+ {
+ 	station->retry_count = 0;
+ 	return 0;
+ }
+ 
+ u16 station_ac_increment_retry_count_by_1(struct p8022_station *station,
+ 					  struct station_state_event *event)
+ {
+ 	station->retry_count++;
+ 	return 0;
+ }
+ 
+ u16 station_ac_set_xid_r_count_0(struct p8022_station *station,
+ 				 struct station_state_event *event)
+ {
+ 	station->xid_r_count = 0;
+ 	return 0;
+ }
+ 
+ u16 station_ac_increment_xid_r_count_by_1(struct p8022_station *station,
+ 					  struct station_state_event *event)
+ {
+ 	station->xid_r_count++;
+ 	return 0;
+ }
+ 
+ u16 station_ac_send_null_dsap_xid_c(struct p8022_station *station,
+ 				    struct station_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	rc = 0;
+ 	pdu_header_init(skb, LLC_PDU_TYPE_U, 0, 0, LLC_PDU_CMD);
+ 	pdu_init_as_xid_cmd(skb, XID_NULL_CLASS_2, 127);
+ 	lan_hdrs_init(skb, station->mac_sa, station->mac_sa);
+ 	station_send_pdu(station, skb);
+ out:	return rc;
+ }
+ 
+ u16 station_ac_send_xid_r(struct p8022_station *station,
+ 			  struct station_state_event *event)
+ {
+ 	u8 mac_da[MAC_ADDR_LEN], dsap;
+ 	u16 rc = 1;
+ 	struct sk_buff *ev_skb;
+ 	struct sk_buff* skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	rc = 0;
+ 	ev_skb = event->data.pdu.skb;
+ 	skb->dev = ev_skb->dev;
+ 	pdu_decode_sa(ev_skb, mac_da);
+ 	pdu_decode_ssap(ev_skb, &dsap);
+ 	pdu_header_init(skb, LLC_PDU_TYPE_U, 0, dsap, LLC_PDU_RSP);
+ 	pdu_init_as_xid_rsp(skb, XID_NULL_CLASS_2, 127);
+ 	lan_hdrs_init(skb, station->mac_sa, mac_da);
+ 	station_send_pdu(station, skb);
+ out:	return rc;
+ }
+ 
+ u16 station_ac_send_test_r(struct p8022_station *station,
+ 			   struct station_state_event *event)
+ {
+ 	u8 mac_da[MAC_ADDR_LEN], dsap;
+ 	u16 rc = 1;
+ 	struct sk_buff *ev_skb;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	rc = 0;
+ 	ev_skb = event->data.pdu.skb;
+ 	skb->dev = ev_skb->dev;
+ 	pdu_decode_sa(ev_skb, mac_da);
+ 	pdu_decode_ssap(ev_skb, &dsap);
+ 	pdu_header_init(skb, LLC_PDU_TYPE_U, 0, dsap, LLC_PDU_RSP);
+        	pdu_init_as_test_rsp(skb, ev_skb);
+ 	lan_hdrs_init(skb, station->mac_sa, mac_da);
+ 	station_send_pdu(station, skb);
+ out:	return rc;
+ }
+ 
+ u16 station_ac_report_status(struct p8022_station *station,
+ 			     struct station_state_event *event)
+ {
+ 	return 0;
+ }
+ 
+ static void station_ack_timer_callback(unsigned long timeout_data)
+ {
+ 	struct p8022_station *station = (struct p8022_station *)timeout_data;
+ 	struct station_state_event *event;
+ 
+ 	station->ack_timer_running = 0;
+ 	event = station_get_event(station);
+ 	if (event) {
+ 		event->type = STATION_EV_TYPE_ACK_TIMER;
+ 		event->data.tmr.timer_specific = NULL;
+ 		station_send_event(station, event);
+ 	}
+ }
Index: kernel-acme/net/8022llc/llc_c_ac.c
diff -c /dev/null kernel-acme/net/8022llc/llc_c_ac.c:1.1.4.13
*** /dev/null	Wed Sep  5 00:22:27 2001
--- kernel-acme/net/8022llc/llc_c_ac.c	Thu Aug 30 19:42:34 2001
***************
*** 0 ****
--- 1,1723 ----
+ /*
+  * llc_c_ac.c - actions performed during connection state transition.
+  *
+  * Description :
+  *   Functions in this module are implementation of connection component actions
+  *   Details of actions can be found in IEEE-802.2 standard document.
+  *   All functions have one connection and one event as input argument. All of
+  *   them return 0 On success and 1 otherwise.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <asm/byteorder.h>
+ #include <linux/netdevice.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_c_ac.h>
+ #include <net/llc_c_st.h>
+ #include <net/llc_pdu.h>
+ #include <net/llc_mac.h>
+ 
+ static void conn_pf_cycle_timer_callback(unsigned long timeout_data);
+ static void conn_ack_timer_callback(unsigned long timeout_data);
+ static void conn_rej_timer_callback(unsigned long timeout_data);
+ static void conn_busy_timer_callback(unsigned long timeout_data);
+ static u16 conn_ac_increment_vs_by_1(struct p8022_connection *conn,
+ 				     struct conn_state_event *event);
+ static u16 process_timer_event(struct p8022_connection *conn,
+ 			       struct conn_state_event *event);
+ static u16 conn_ac_data_confirm(struct p8022_connection *conn,
+ 				struct conn_state_event *event);
+ 
+ #define INCORRECT 0
+ 
+ u16 conn_ac_clear_remote_busy(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	if (conn->remote_busy_flag) {
+ 		u8 nr;
+ 		pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 		conn->remote_busy_flag = 0;
+ 		del_timer(&conn->busy_state_timer);
+ 		conn->busy_state_running = 0;
+ 		nr = LLC_I_GET_NR(rx_pdu);
+ 		conn_resend_i_pdu_as_cmd(conn, nr, 0);
+ 	}
+ 	return 0;
+ }
+ 
+ u16 conn_ac_connect_indication(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = event->data.pdu.skb;
+ 	prim_data_u *prim_data = Ind_prim.data;
+ 	struct prim_if_block *prim = &Ind_prim;
+ 	struct p8022_sap *sap;
+ 
+ 	pdu_decode_dsap(skb, &prim_data->conn.dest_addr.lsap);
+ 	sap = llc_sap_find(prim_data->conn.dest_addr.lsap);
+ 	if (sap) {
+ 		pdu_decode_sa(skb, conn->remote_dl_addr.mac);
+ 		pdu_decode_da(skb, conn->local_dl_addr.mac);
+ 		conn->local_dev = skb->dev;
+ 		prim_data->conn.priority = 0;
+ 		prim_data->conn.connection = conn;
+ 		memcpy(&prim_data->conn.dest_addr, &conn->local_dl_addr,
+ 		       sizeof(address_t));
+ 		memcpy(&prim_data->conn.source_addr, &conn->remote_dl_addr,
+ 		       sizeof(address_t));
+ 		prim->data = prim_data;
+ 		prim_data->conn.device = skb->dev;
+ 		prim->primitive = P8022_CONNECT_PRIM;
+ 		prim->sap = conn->parent_sap;
+ 		event->flag = 1;
+ 		event->ind_prim = prim;
+ 		rc = 0;
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_connect_confirm(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	prim_data_u *prim_data = Cfm_prim.data;
+ 	struct prim_if_block *prim = &Cfm_prim;
+ 	struct p8022_sap *sap = conn->parent_sap;
+ 
+ 	prim_data->conn.connection = conn;
+ 	prim_data->conn.priority = 0;
+ 	prim_data->conn.status = event->status;
+ 	prim_data->conn.link_no = conn->link_no;
+ 	prim->data = prim_data;
+ 	prim->primitive = P8022_CONNECT_PRIM;
+ 	prim->sap = sap;
+ 	event->flag = 1;
+ 	event->cfm_prim = prim;
+ 	return 0;
+ }
+ 
+ static u16 conn_ac_data_confirm(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	struct prim_if_block *prim = &Cfm_prim;
+ 	prim_data_u *prim_data = Cfm_prim.data;
+ 
+ 	prim_data->data.connection = conn;
+ 	prim_data->data.priority = 0;
+ 	prim_data->data.link_no = conn->link_no;
+ 	prim_data->data.status = P8022_STATUS_RECEIVED;
+ 	prim_data->data.skb = NULL;
+ 	prim->data = prim_data;
+ 	prim->primitive = P8022_DATA_PRIM;
+ 	prim->sap = conn->parent_sap;
+ 	event->flag = 1;
+ 	event->cfm_prim = prim;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_data_indication(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	return conn_rtn_pdu(conn, event->data.pdu.skb, event);
+ }
+ 
+ u16 conn_ac_disconnect_indication(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u8 reason = 0;
+ 	u16 rc = 1;
+ 	prim_data_u *prim_data = Ind_prim.data;
+ 	struct prim_if_block *prim = &Ind_prim;
+ 
+ 	if (event->type == CONN_EV_TYPE_PDU) {
+ 		pdu_un_t *rx_pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 		if (!LLC_PDU_IS_RSP(rx_pdu) &&
+ 		    !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+ 		    LLC_U_PDU_RSP(rx_pdu) == LLC_2_PDU_RSP_DM) {
+ 			reason = P8022_DISC_REASON_RX_DM_RSP_PDU;
+ 			rc = 0;
+ 		} else if (!LLC_PDU_IS_CMD(rx_pdu) &&
+ 			   !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+ 			   LLC_U_PDU_CMD(rx_pdu) == LLC_2_PDU_CMD_DISC) {
+ 			reason = P8022_DISC_REASON_RX_DISC_CMD_PDU;
+ 			rc = 0;
+ 		}
+ 	} else if (event->type == CONN_EV_TYPE_ACK_TIMER) {
+ 		reason = P8022_DISC_REASON_ACK_TIMER_EXPIRED;
+ 		rc = 0;
+ 	} else {
+ 		reason = 0;
+ 		rc = 1;
+ 	}
+ 	if (!rc) {
+ 		prim_data->disc.connection = conn;
+ 		prim_data->disc.reason = reason;
+ 		prim_data->disc.link_no = conn->link_no;
+ 		prim->data = prim_data;
+ 		prim->primitive = P8022_DISCONNECT_PRIM;
+ 		prim->sap = conn->parent_sap;
+ 		event->flag = 1;
+ 		event->ind_prim = prim;
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_disconnect_confirm(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	prim_data_u *prim_data = Cfm_prim.data;
+ 	struct prim_if_block *prim = &Cfm_prim;
+ 
+ 	prim_data->disc.connection = conn;
+ 	prim_data->disc.reason = event->status;
+ 	prim_data->disc.link_no = conn->link_no;
+ 	prim->data = prim_data;
+ 	prim->primitive = P8022_DISCONNECT_PRIM;
+ 	prim->sap = conn->parent_sap;
+ 	event->flag = 1;
+ 	event->cfm_prim = prim;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_reset_indication(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	u8 reason = 0;
+ 	u16 rc = 1;
+ 	pdu_un_t *rx_pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 	prim_data_u *prim_data = Ind_prim.data;
+ 	struct prim_if_block *prim = &Ind_prim;
+ 
+ 	switch (event->type) {
+ 		case CONN_EV_TYPE_PDU:
+ 			if (!LLC_PDU_IS_RSP(rx_pdu) &&
+ 			    !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+ 			    LLC_U_PDU_RSP(rx_pdu) == LLC_2_PDU_RSP_FRMR) {
+ 				reason = P8022_RESET_REASON_LOCAL;
+ 				rc = 0;
+ 			} else if (!LLC_PDU_IS_CMD(rx_pdu) &&
+ 				   !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+ 				   LLC_U_PDU_CMD(rx_pdu) ==
+ 				   			LLC_2_PDU_CMD_SABME) {
+ 				reason = P8022_RESET_REASON_REMOTE;
+ 				rc = 0;
+ 			} else {
+ 				reason = 0;
+ 				rc  = 1;
+ 			}
+ 			break;
+ 		case CONN_EV_TYPE_ACK_TIMER:
+ 		case CONN_EV_TYPE_P_TIMER:
+ 		case CONN_EV_TYPE_REJ_TIMER:
+ 		case CONN_EV_TYPE_BUSY_TIMER:
+ 			if (conn->retry_count > conn->n2) {
+ 				reason = P8022_RESET_REASON_LOCAL;
+ 				rc = 0;
+ 			} else
+ 				rc = 1;
+ 			break;
+ 	}
+ 	if (!rc) {
+ 		prim_data->res.connection = conn;
+ 		prim_data->res.reason = reason;
+ 		prim_data->res.link_no = conn->link_no;
+ 		prim->data = prim_data;
+ 		prim->primitive = P8022_RESET_PRIM;
+ 		prim->sap = conn->parent_sap;
+ 		event->flag = 1;
+ 		event->ind_prim = prim;
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_reset_confirm(struct p8022_connection *conn,
+ 			  struct conn_state_event *event)
+ {
+ 	prim_data_u *prim_data = Cfm_prim.data;
+ 	struct prim_if_block *prim = &Cfm_prim;
+ 
+ 	prim_data->res.connection = conn;
+ 	prim_data->res.link_no = conn->link_no;
+ 	prim->data = prim_data;
+ 	prim->primitive = P8022_RESET_PRIM;
+ 	prim->sap = conn->parent_sap;
+ 	event->flag = 1;
+ 	event->cfm_prim = prim;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_report_status(struct p8022_connection *conn,
+ 			  struct conn_state_event *event)
+ {
+ 	return 0;
+ }
+ 
+ u16 conn_ac_clear_remote_busy_if_f_eq_1(struct p8022_connection *conn,
+ 					struct conn_state_event *event)
+ {
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	if (!LLC_PDU_IS_RSP(rx_pdu) &&
+ 	    !LLC_PDU_TYPE_IS_I(rx_pdu) &&
+ 	    !LLC_I_PF_IS_1(rx_pdu) && conn->ack_pf)
+ 		conn_ac_clear_remote_busy(conn, event);
+ 	return 0;
+ }
+ 
+ u16 conn_ac_stop_rej_timer_if_data_flag_eq_2(struct p8022_connection *conn,
+ 					     struct conn_state_event *event)
+ {
+ 	if (conn->data_flag == 2) {
+ 		del_timer(&conn->reject_sent_timer);
+ 		conn->reject_sent_running = 0;
+ 	}
+ 	return 0;
+ }
+ 
+ u16 conn_ac_send_disc_cmd_p_set_x(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		u8 p_bit = 1;
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 		pdu_init_as_disc_cmd(skb, p_bit);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 			      conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	conn_ac_set_p_flag_1(conn, event);
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_dm_rsp_f_set_p(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		struct sk_buff *rx_skb = event->data.pdu.skb;
+ 		u8 f_bit;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_decode_pf_bit(rx_skb, &f_bit);
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_dm_rsp(skb, f_bit);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 			      conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_dm_rsp_f_set_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 1;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_dm_rsp(skb, f_bit);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 			      conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_dm_rsp_f_set_f_flag(struct p8022_connection *conn,
+ 				     struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = conn->f_flag;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_dm_rsp(skb, f_bit);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 			      conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_frmr_rsp_f_set_x(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u8 f_bit;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb, *ev_skb = event->data.pdu.skb;
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev_skb->nh.raw;
+ 
+ 	conn->rx_pdu_hdr = (u32)*((u32 *)rx_pdu);
+ 	if (!LLC_PDU_IS_CMD(rx_pdu))
+ 		pdu_decode_pf_bit(ev_skb, &f_bit);
+ 	else
+ 		f_bit = 0;
+ 	skb = frame_pdu_allocate();
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_frmr_rsp(skb, rx_pdu, f_bit, conn->vS,
+ 				     conn->vR, INCORRECT);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 			      conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_resend_frmr_rsp_f_set_0(struct p8022_connection *conn,
+ 				    struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		pdu_sn_t *rx_pdu = (pdu_sn_t *)&conn->rx_pdu_hdr;
+ 		u8 f_bit = 0;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_frmr_rsp(skb, rx_pdu, f_bit, conn->vS,
+ 				     conn->vR, INCORRECT);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 			      conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_resend_frmr_rsp_f_set_p(struct p8022_connection *conn,
+ 				    struct conn_state_event *event)
+ {
+ 	u8 f_bit;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb;
+ 
+ 	pdu_decode_pf_bit(event->data.pdu.skb, &f_bit);
+ 	skb = frame_pdu_allocate();
+ 	if (skb) {
+ 		pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_frmr_rsp(skb, rx_pdu, f_bit, conn->vS,
+ 				     conn->vR, INCORRECT);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 			      conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_i_cmd_p_set_1(struct p8022_connection *conn, struct conn_state_event *event)
+ {
+ 	u8 p_bit = 1;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = event->data.prim.data->data->data.skb;
+ 	struct p8022_sap *sap = conn->parent_sap;
+ 
+ 	pdu_header_init(skb, LLC_PDU_TYPE_I, sap->local_dl_addr.lsap,
+ 			conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	pdu_init_as_i_cmd(skb, p_bit, conn->vS, conn->vR);
+ 	lan_hdrs_init(skb, conn->local_dev->dev_addr, conn->remote_dl_addr.mac);
+         rc = conn_send_pdu(conn, skb);
+         if (!rc)
+    		conn_ac_increment_vs_by_1(conn, event);
+    	return rc;
+ }
+ 
+ u16 conn_ac_send_i_cmd_p_set_0(struct p8022_connection *conn, struct conn_state_event *event)
+ {
+ 	u8 p_bit = 0;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = event->data.prim.data->data->data.skb;
+ 	struct p8022_sap *sap = conn->parent_sap;
+ 
+ 	pdu_header_init(skb, LLC_PDU_TYPE_I, sap->local_dl_addr.lsap,
+ 			conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	pdu_init_as_i_cmd(skb, p_bit, conn->vS, conn->vR);
+ 	lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 		      conn->remote_dl_addr.mac);
+ 	rc = conn_send_pdu(conn, skb);
+         if (!rc)
+ 		conn_ac_increment_vs_by_1(conn,event);
+ 	return rc;
+ }
+ 
+ u16 conn_ac_resend_i_cmd_p_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 nr = LLC_I_GET_NR(rx_pdu);
+ 
+ 	return conn_resend_i_pdu_as_cmd(conn, nr, 1);
+ }
+ 
+ u16 conn_ac_resend_i_cmd_p_set_1_or_send_rr(struct p8022_connection *conn,
+ 					    struct conn_state_event *event)
+ {
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 nr = LLC_I_GET_NR(rx_pdu);
+ 	u16 rc = conn_ac_send_rr_cmd_p_set_1(conn, event);
+ 
+ 	if (!rc)
+ 		rc = conn_resend_i_pdu_as_cmd(conn, nr, 0);
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_i_xxx_x_set_0(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	u8 p_bit = 0;
+ 	u16 rc;
+ 	struct sk_buff *skb = event->data.prim.data->data->data.skb;
+ 	struct p8022_sap *sap = conn->parent_sap;
+ 
+ 	pdu_header_init(skb, LLC_PDU_TYPE_I, sap->local_dl_addr.lsap,
+ 			conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	pdu_init_as_i_cmd(skb, p_bit, conn->vS, conn->vR);
+ 	lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 		      conn->remote_dl_addr.mac);
+ 	rc = conn_send_pdu(conn, skb);
+ 	if (!rc)
+ 		conn_ac_increment_vs_by_1(conn, event);
+ 	return rc;
+ }
+ 
+ u16 conn_ac_resend_i_xxx_x_set_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 nr = LLC_I_GET_NR(rx_pdu);
+ 
+ 	return conn_resend_i_pdu_as_cmd(conn, nr, 0);
+ }
+ 
+ u16 conn_ac_resend_i_xxx_x_set_0_or_send_rr(struct p8022_connection *conn,
+ 					    struct conn_state_event *event)
+ {
+ 	u8 nr;
+ 	u8 f_bit = 0;
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	if (rc) {
+ 		nr = LLC_I_GET_NR(rx_pdu);
+ 		rc = conn_resend_i_pdu_as_cmd(conn, nr, f_bit);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_resend_i_rsp_f_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 nr = LLC_I_GET_NR(rx_pdu);
+ 
+ 	return conn_resend_i_pdu_as_rsp(conn, nr, 1);
+ }
+ 
+ u16 conn_ac_send_rej_cmd_p_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 p_bit = 1;
+ 
+ 		skb->dev = conn->local_dev;
+ 		rc = pdu_header_init(skb, LLC_PDU_TYPE_S,
+ 				     sap->local_dl_addr.lsap,
+ 				     conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 		pdu_init_as_rej_cmd(skb, p_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rej_rsp_f_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		u8 f_bit = 1;
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rej_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+                 rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rej_xxx_x_set_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 0;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rej_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rnr_cmd_p_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 p_bit = 1;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 		pdu_init_as_rnr_cmd(skb, p_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rnr_rsp_f_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 1;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rnr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rnr_xxx_x_set_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		u8 f_bit = 0;
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rnr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_set_remote_busy(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	if (!conn->remote_busy_flag) {
+ 		conn->remote_busy_flag = 1;
+ 		conn->busy_state_timer.expires  = jiffies +
+ 						  P8022_BUSY_TIME * HZ;
+ 		conn->busy_state_timer.data	= (unsigned long)conn;
+ 		conn->busy_state_timer.function = conn_busy_timer_callback;
+ 		add_timer(&conn->busy_state_timer);
+ 		conn->busy_state_running = 1;
+ 	}
+ 	return 0;
+ }
+ 
+ u16 conn_ac_optional_send_rnr_xxx_x_set_0(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 0;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S,
+ 				sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rnr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rr_cmd_p_set_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		u8 p_bit = 1;
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 		pdu_init_as_rr_cmd(skb, p_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_ack_cmd_p_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		u8 p_bit = 1;
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 		pdu_init_as_rr_cmd(skb, p_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rr_rsp_f_set_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 1;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_ack_rsp_f_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 1;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_rr_xxx_x_set_0(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 0;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_ack_xxx_x_set_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = 0;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S,
+ 				sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_sabme_cmd_p_set_x(struct p8022_connection *conn,
+ 				   struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 	u8 p_bit = 1;
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 		pdu_init_as_sabme_cmd(skb, p_bit);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	conn->p_flag = p_bit;
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_ua_rsp_f_set_f_flag(struct p8022_connection *conn,
+ 				     struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = conn->f_flag;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_ua_rsp(skb, f_bit);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_send_ua_rsp_f_set_p(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	u8 f_bit;
+ 	u16 rc = 1;
+ 	struct sk_buff *rx_skb = event->data.pdu.skb;
+ 	struct sk_buff *skb;
+ 
+ 	pdu_decode_pf_bit(rx_skb, &f_bit);
+ 	skb = frame_pdu_allocate();
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_ua_rsp(skb, f_bit);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ac_set_s_flag_0(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	conn->s_flag = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_s_flag_1(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	conn->s_flag = 1;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_start_p_timer(struct p8022_connection *conn,
+ 			  struct conn_state_event *event)
+ {
+ 	conn->p_flag = 1;
+ 	del_timer(&conn->pf_cycle_timer);
+ 	conn->pf_cycle_timer.expires  = jiffies + P8022_P_TIME * HZ;
+ 	conn->pf_cycle_timer.data     = (unsigned long)conn;
+ 	conn->pf_cycle_timer.function = conn_pf_cycle_timer_callback;
+ 	add_timer(&conn->pf_cycle_timer);
+ 	conn->pf_cycle_running = 1;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: conn_ac_send_ack_if_needed
+  *
+  * Description:
+  *  Checks number of received PDUs which have not been acknowledged, yet, If
+  *  number of them reaches to "npta"(Number of PDUs To Acknowledge) then sends
+  *  an RR response as acknowledgement for them.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_send_ack_if_needed(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	u8 pf_bit;
+ 	struct sk_buff *skb = event->data.pdu.skb;
+ 
+ 	pdu_decode_pf_bit(skb, &pf_bit);
+ 	conn->ack_pf |= pf_bit & 1;
+ 	if (!conn->ack_must_be_send) {
+ 		conn->first_pdu_Ns = conn->vR;
+ 		conn->ack_must_be_send = 1;
+ 		conn->ack_pf = pf_bit & 1;
+ 	}
+ 	if (((conn->vR - conn->first_pdu_Ns + 129) % 128) >= conn->npta) {
+ 		conn_ac_send_rr_rsp_f_set_ackpf(conn, event);
+ 		conn->ack_must_be_send	= 0;
+ 		conn->ack_pf		= 0;
+ 		conn_ac_increase_npta_value(conn, event);
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Function: conn_ac_reset_sendack_flag
+  *
+  * Description:
+  *  This action resets ack_must_be_send flag of given connection, this flag
+  *  indicates if there is any PDU which has not been acknowledged yet.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_reset_sendack_flag(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	conn->ack_must_be_send = conn->ack_pf = 0;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: conn_ac_send_i_rsp_f_set_ackpf
+  *
+  * Description:
+  *  Sends an I response PDU with f-bit set to ack_pf flag as acknowledge to
+  *  all received PDUs which have not been acknowledged, yet. ack_pf flag
+  *  is set to one if one PDU with p-bit set to one is received.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_send_i_rsp_f_set_ackpf(struct p8022_connection *conn,
+ 				   struct conn_state_event *event)
+ {
+ 	u16 rc;
+ 	struct sk_buff *skb = event->data.prim.data->data->data.skb;
+ 	u8 p_bit = conn->ack_pf;
+ 	struct p8022_sap *sap = conn->parent_sap;
+ 
+ 	pdu_header_init(skb, LLC_PDU_TYPE_I, sap->local_dl_addr.lsap,
+ 			conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	pdu_init_as_i_cmd(skb, p_bit, conn->vS, conn->vR);
+ 	lan_hdrs_init(skb, conn->local_dev->dev_addr,
+ 		      conn->remote_dl_addr.mac);
+ 	rc = conn_send_pdu(conn, skb);
+         if (!rc)
+ 		conn_ac_increment_vs_by_1(conn, event);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: conn_ac_send_i_as_ack
+  *
+  * Description:
+  *  This action sends an I-format PDU as acknowledge to received PDUs which
+  *  have not been acknowledged, yet, if there is any. By using of this
+  *  action number of acknowledgements decreases, this technic is called
+  *  pigy backing.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_send_i_as_ack(struct p8022_connection *conn,
+ 			  struct conn_state_event *event)
+ {
+ 	if (conn->ack_must_be_send) {
+ 		conn_ac_send_i_rsp_f_set_ackpf(conn,event);
+ 		conn->ack_must_be_send = 0 ;
+ 		conn->ack_pf = 0;
+ 	} else
+ 		conn_ac_send_i_cmd_p_set_0(conn, event);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: conn_ac_send_rr_rsp_f_set_ackpf
+  *
+  * Description:
+  *  This action sends an RR response with f-bit set to ack_pf flag as
+  *  acknowledge to all received PDUs which have not been acknowledged, yet,
+  *  if there is any. ack_pf flag indicates if a PDU has been received with
+  *  p-bit set to one.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_send_rr_rsp_f_set_ackpf(struct p8022_connection *conn,
+ 				    struct conn_state_event *event)
+ {
+ 	int rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (skb) {
+ 		struct p8022_sap *sap = conn->parent_sap;
+ 		u8 f_bit = conn->ack_pf;
+ 
+ 		skb->dev = conn->local_dev;
+ 		pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 				conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 		pdu_init_as_rr_rsp(skb, f_bit, conn->vR);
+ 		lan_hdrs_init(skb, conn->local_dev->dev_addr,
+                               conn->remote_dl_addr.mac);
+ 		rc = conn_send_pdu(conn, skb);
+ 	}
+ 	return rc;
+ }
+ 
+ /*
+  * Function: conn_ac_increase_npta_value
+  *
+  * Description:
+  *  After "inc_cntr" times calling of this action, "npta" increase by one.
+  *  this action tries to make vale of "npta" greater as possible; number of
+  *  acknowledgements decreases by increasing of "npta".
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_increase_npta_value(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	if (!conn->inc_cntr) {
+ 		conn->dec_step = 0;
+ 		conn->dec_cntr = conn->inc_cntr = 2;
+ 		++conn->npta;
+ 		if (conn->npta > 127)
+ 			conn->npta = 127 ;
+ 	} else
+ 		--conn->inc_cntr;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: conn_ac_adjust_npta_by_rr
+  *
+  * Description:
+  *  After receiving "dec_cntr" times RR command, this action decreases "npta"
+  *  by one.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_adjust_npta_by_rr(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	if (!conn->connect_step && !conn->remote_busy_flag) {
+ 		if (!conn->dec_step) {
+ 			if (!conn->dec_cntr) {
+ 				conn->inc_cntr = conn->dec_cntr = 2;
+ 				if (conn->npta > 0)
+ 					conn->npta = conn->npta - 1;
+ 			} else
+ 				conn->dec_cntr -=1;
+ 		}
+ 	} else
+ 		conn->connect_step = 0 ;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: conn_ac_adjust_npta_by_rnr
+  *
+  * Description:
+  *  After receiving "dec_cntr" times RNR command, this action decreases "npta"
+  *  by one.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_adjust_npta_by_rnr(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	if (conn->remote_busy_flag)
+ 		if (!conn->dec_step) {
+ 			if (!conn->dec_cntr) {
+ 				conn->inc_cntr = conn->dec_cntr = 2;
+ 				if (conn->npta > 0)
+ 					--conn->npta;
+ 			} else
+ 				--conn->dec_cntr;
+ 		}
+ 	return 0;
+ }
+ 
+ 
+ /*
+  * Function: conn_ac_decrease_transmit_window_size
+  *
+  * Description:
+  *  After receiving of a REJ command or response, transmit window size is
+  *  decreased by number of PDUs which are outstanding yet.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_decrease_transmit_window_size(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	u8 unacked_pdu = skb_queue_len(&conn->pdu_unack_q);
+ 
+ 	conn->k -= unacked_pdu;
+ 	if (conn->k < 2)
+ 		conn->k = 2;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: conn_ac_increase_transmit_window_size
+  *
+  * Description:
+  *  After receiving an RR response with f-bit set to one, transmit window size
+  *  is increased by one.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 conn_ac_increase_transmit_window_size(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	conn->k += 1;
+ 	if (conn->k > 128)
+ 		conn->k = 128 ;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_stop_all_timers(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	del_timer(&conn->pf_cycle_timer);
+ 	conn->pf_cycle_running = 0;
+ 	del_timer(&conn->ack_timer);
+ 	conn->ack_running = 0;
+ 	del_timer(&conn->reject_sent_timer);
+ 	conn->reject_sent_running = 0;
+ 	del_timer(&conn->busy_state_timer);
+ 	conn->busy_state_running = 0;
+ 	conn->ack_must_be_send = 0;
+ 	conn->ack_pf = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_stop_other_timers(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	del_timer(&conn->reject_sent_timer);
+ 	conn->reject_sent_running = 0;
+ 	del_timer(&conn->pf_cycle_timer);
+ 	conn->pf_cycle_running = 0;
+ 	del_timer(&conn->busy_state_timer);
+ 	conn->busy_state_running = 0;
+ 	conn->ack_must_be_send = 0;
+ 	conn->ack_pf = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_start_ack_timer(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	del_timer(&conn->ack_timer);
+ 	conn->ack_timer.expires  = jiffies + P8022_ACK_TIME * HZ;
+ 	conn->ack_timer.data	 = (unsigned long)conn;
+ 	conn->ack_timer.function = conn_ack_timer_callback;
+ 	add_timer(&conn->ack_timer);
+ 	conn->ack_running = 1;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_start_rej_timer(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	del_timer(&conn->reject_sent_timer);
+ 	conn->reject_sent_timer.expires  = jiffies + P8022_REJ_TIME * HZ;
+ 	conn->reject_sent_timer.data     = (unsigned long)conn;
+ 	conn->reject_sent_timer.function = conn_rej_timer_callback;
+ 	add_timer(&conn->reject_sent_timer);
+ 	conn->reject_sent_running = 1;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_start_ack_timer_if_not_running(struct p8022_connection *conn,
+ 					   struct conn_state_event *event)
+ {
+ 	if (!conn->ack_running) {
+ 		conn->ack_timer.expires  = jiffies + P8022_ACK_TIME * HZ;
+ 		conn->ack_timer.data 	 = (unsigned long)conn;
+ 		conn->ack_timer.function = conn_ack_timer_callback;
+ 		add_timer(&conn->ack_timer);
+ 		conn->ack_running = 1;
+ 	}
+ 	return 0;
+ }
+ 
+ u16 conn_ac_stop_ack_timer(struct p8022_connection *conn,
+ 			   struct conn_state_event *event)
+ {
+ 	del_timer(&conn->ack_timer);
+ 	conn->ack_running = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_stop_p_timer(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	del_timer(&conn->pf_cycle_timer);
+ 	conn->pf_cycle_running = 0;
+ 	conn->p_flag = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_stop_rej_timer(struct p8022_connection *conn,
+ 			   struct conn_state_event *event)
+ {
+ 	del_timer(&conn->reject_sent_timer);
+ 	conn->reject_sent_running = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_update_nr_received(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	u16 nbr_acked;
+ 	u16 nbr_unack_pdus = 0;
+ 	u8 fbit;
+ 	struct sk_buff *skb = event->data.pdu.skb;
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	conn->last_nr = PDU_SUPV_GET_Nr(rx_pdu);
+ 	nbr_acked = conn_remove_acked_pdus(conn, conn->last_nr,
+ 					   &nbr_unack_pdus);
+         /* On loopback we don't queue I frames in unack_pdu_q queue. */
+ 	if (nbr_acked > 0 || (conn->local_dev->flags & IFF_LOOPBACK)) {
+ 		conn->retry_count = 0;
+ 		del_timer(&conn->ack_timer);
+ 		conn->ack_running = 0;
+ 		if (conn->failed_data_req) {
+ 			/* already, we did not accept data from upper
+ 			 * layer(tx_window full or unacceptable state). now, we
+ 			 * can send data and must inform to upper layer. */
+ 			conn->failed_data_req = 0;
+ 			conn_ac_data_confirm(conn, event);
+ 		}
+ 		if (nbr_unack_pdus) {
+ 			conn->ack_timer.expires  = jiffies +
+ 						   P8022_ACK_TIME * HZ;
+                 	conn->ack_timer.data 	 = (unsigned long)conn;
+                 	conn->ack_timer.function = conn_ack_timer_callback;
+                 	add_timer(&conn->ack_timer);
+ 			conn->ack_running = 1;
+ 	       }
+ 	} else if (conn->failed_data_req) {
+ 		pdu_decode_pf_bit(skb, &fbit);
+ 		if (fbit == 1) {
+ 			conn->failed_data_req = 0;
+ 			conn_ac_data_confirm(conn, event);
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ u16 conn_ac_update_p_flag(struct p8022_connection *conn,
+ 			  struct conn_state_event *event)
+ {
+ 	struct sk_buff *skb = event->data.pdu.skb;
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)skb->nh.raw;
+ 	u8 f_bit;
+ 
+ 	if (!LLC_PDU_IS_RSP(rx_pdu) &&
+ 	    !pdu_decode_pf_bit(skb, &f_bit) && f_bit) {
+ 		conn->p_flag = 0;
+ 		conn_ac_stop_p_timer(conn, event);
+ 	}
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_data_flag_2(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	conn->data_flag = 2;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_data_flag_0(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	conn->data_flag = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_data_flag_1(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	conn->data_flag = 1;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_data_flag_1_if_data_flag_eq_0(struct p8022_connection *conn,
+ 					      struct conn_state_event *event)
+ {
+ 	if (!conn->data_flag)
+ 		conn->data_flag = 1;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_p_flag_0(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	conn->p_flag = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_p_flag_1(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	conn->p_flag = 1;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_remote_busy_0(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	conn->remote_busy_flag = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_cause_flag_0(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	conn->cause_flag = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_cause_flag_1(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	conn->cause_flag = 1;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_retry_count_0(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	conn->retry_count = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_increment_retry_count_by_1(struct p8022_connection *conn,
+ 				       struct conn_state_event *event)
+ {
+ 	conn->retry_count++;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_vr_0(struct p8022_connection *conn,
+ 		     struct conn_state_event *event)
+ {
+ 	conn->vR = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_increment_vr_by_1(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	conn->vR = PDU_GET_NEXT_Vr(conn->vR);
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_vs_0(struct p8022_connection *conn,
+ 		     struct conn_state_event *event)
+ {
+ 	conn->vS = 0;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_vs_nr(struct p8022_connection *conn,
+ 		      struct conn_state_event *event)
+ {
+ 	conn->vS = conn->last_nr;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_increment_vs_by_1(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	conn->vS = (conn->vS + 1) % 128;
+ 	return 0;
+ }
+ 
+ u16 conn_ac_set_f_flag_p(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	pdu_decode_pf_bit(event->data.pdu.skb, &conn->f_flag);
+ 	return 0;
+ }
+ 
+ void conn_pf_cycle_timer_callback(unsigned long timeout_data)
+ {
+ 	struct p8022_connection *conn = (struct p8022_connection *)timeout_data;
+ 	struct conn_state_event *event;
+ 
+ 	conn->pf_cycle_running = 0;
+ 	event = conn_alloc_event(conn);
+ 	if (event) {
+ 		event->type = CONN_EV_TYPE_P_TIMER;
+ 		event->data.tmr.timer_specific = NULL;
+ 		process_timer_event(conn, event);
+ 	}
+ }
+ 
+ static void conn_busy_timer_callback(unsigned long timeout_data)
+ {
+ 	struct p8022_connection *conn = (struct p8022_connection *)timeout_data;
+ 	struct conn_state_event *event;
+ 
+ 	conn->busy_state_running = 0;
+ 	event = conn_alloc_event(conn);
+ 	if (event) {
+ 		event->type = CONN_EV_TYPE_BUSY_TIMER;
+ 		event->data.tmr.timer_specific = NULL;
+ 		process_timer_event(conn, event);
+ 	}
+ }
+ 
+ void conn_ack_timer_callback(unsigned long timeout_data)
+ {
+ 	struct p8022_connection *conn = (struct p8022_connection *)timeout_data;
+ 	struct conn_state_event *event;
+ 
+ 	conn->ack_running = 0;
+ 	event = conn_alloc_event(conn);
+ 	if (event) {
+ 		event->type = CONN_EV_TYPE_ACK_TIMER;
+ 		event->data.tmr.timer_specific = NULL;
+ 		process_timer_event(conn, event);
+ 	}
+ }
+ 
+ static void conn_rej_timer_callback(unsigned long timeout_data)
+ {
+ 	struct p8022_connection *conn = (struct p8022_connection *)timeout_data;
+ 	struct conn_state_event *event;
+ 
+ 	conn->reject_sent_running = 0;
+ 	event = conn_alloc_event(conn);
+ 	if (event) {
+ 		event->type = CONN_EV_TYPE_REJ_TIMER;
+ 		event->data.tmr.timer_specific = NULL;
+ 		process_timer_event(conn, event);
+ 	}
+ }
+ 
+ u16 conn_ac_reset_vs(struct p8022_connection *conn,
+ 		     struct conn_state_event *event)
+ {
+ 	conn->X = conn->vS;
+ 	conn_ac_set_vs_nr(conn,event);
+ 	return 0;
+ }
+ 
+ u16 conn_ac_update_vs(struct p8022_connection *conn,
+ 		      struct conn_state_event *event)
+ {
+ 	pdu_sn_t *rx_pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 nr = PDU_SUPV_GET_Nr(rx_pdu);
+ 
+ 	if (circular_between(conn->vS, nr, conn->X))
+ 		conn_ac_set_vs_nr(conn,event);
+ 	return 0;
+ }
+ 
+ /*
+  * non-standard actions; these not contained in IEEE specification; for
+  * our own usage
+  */
+ /*
+  * Function :
+  *  conn_disconnect
+  * Description :
+  *  this function removes connection from list of it's SAP and
+  *  returns it to connection pool.
+  * Parameters :
+  *  struct p8022_connection *conn : closed connection.
+  *  conn_stat_event_t *event : occurred event.
+  * Returns :
+  *  always 0.
+  */
+ 
+ u16 conn_disconnect(struct p8022_connection *conn,
+ 		    struct conn_state_event *event)
+ {
+ 	sap_unassign_conn(conn->parent_sap, conn);
+ 	llc_connection_free(conn);
+ 	return 0;
+ }
+ 
+ /*
+  * Function :
+  *  conn_reset
+  * Description :
+  *  this function stop all timers, empty all queues and reset all flags.
+  * Parameters :
+  *  struct p8022_connection *conn : reseting connection.
+  *  conn_stat_event_t *event : occurred event.
+  * Returns :
+  *  always 0.
+  */
+ u16 conn_reset(struct p8022_connection *conn, struct conn_state_event *event)
+ {
+ 	llc_connection_reset(conn);
+ 	return 0;
+ }
+ 
+ /*
+  * Function :
+  *  circular_between
+  * Description :
+  *  This function designates that b is between a and c or not (for example,
+  *  0 is between 127 and 1).
+  * Parameters :
+  *  a,b,c : three number (unsigned char) between 0 and 255.
+  * Returns :
+  *  1 : if b is between a and c.
+  *  0 : otherwise
+  */
+ u8 circular_between(u8 a, u8 b, u8 c)
+ {
+ 	b = b - a;
+ 	c = c - a;
+ 	return b <= c;
+ }
+ 
+ /*
+  * Function :
+  *  process_timer_event
+  * Description :
+  *  This function is called from timer callback functions.
+  *  When connection is busy (during sending a data frame) timer expiration event
+  *  must be queued. otherwise this event can be sent to connection state
+  *  machine. Queued events will process by process_rxframes_events function
+  *  after sending data frame.
+  * Parameters :
+  *  struct p8022_connection *conn : active connection.
+  *  conn_stat_event_t *event : occurred event.
+  * Returns :
+  *  1 : failure.
+  *  0 : succes.
+  */
+ static u16 process_timer_event(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	u16 rc = 0;
+ 
+ 	if (conn->state == CONN_OUT_OF_SVC) {
+ 		printk(KERN_WARNING "timer called on closed connection\n");
+ 		conn_free_event(conn, event);
+ 		goto out;
+ 	}
+ 	if (conn->busy > 0) {
+ 		struct p8022_rx_object *rx_obj = kmalloc(sizeof(*rx_obj),
+ 							 GFP_ATOMIC);
+ 
+ 		if (rx_obj) {
+ 			rx_obj->desc = P8022_EVENT;
+ 			rx_obj->obj.event = event;
+ 			spin_lock_bh(&conn->log_q.lock);
+ 			list_add_tail(&rx_obj->node, &conn->log_q.list);
+ 			spin_unlock_bh(&conn->log_q.lock);
+ 		} else {
+ 			conn_free_event(conn, event);
+ 			rc = 1;
+ 		}
+ 	} else
+ 		rc = conn_send_event(conn, event);
+ out:	return rc;
+ }
Index: kernel-acme/net/8022llc/llc_c_ev.c
diff -c /dev/null kernel-acme/net/8022llc/llc_c_ev.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:27 2001
--- kernel-acme/net/8022llc/llc_c_ev.c	Thu Aug 30 19:42:35 2001
***************
*** 0 ****
--- 1,908 ----
+ /*
+  * llc_c_ev.c - Connection component state transition event qualifiers
+  *
+  * A 'state' consists of a number of possible event matching functions,
+  * the actions associated with each being executed when that event is
+  * matched; a 'state machine' accepts events in a serial fashion from an
+  * event queue. Each event is passed to each successive event matching
+  * function until a match is made (the event matching function returns
+  * success, or '0') or the list of event matching functions is exhausted.
+  * If a match is made, the actions associated with the event are executed
+  * and the state is changed to that event's transition state. Before some
+  * events are recognized, even after a match has been made, a certain
+  * number of 'event qualifier' functions must also be executed. If these
+  * all execute successfully, then the event is finally executed.
+  *
+  * These event functions must return 0 for success, to show a matched
+  * event, of 1 if the event does not match. Event qualifier functions
+  * must return a 0 for success or a non-zero for failure. Each function
+  * is simply responsible for verifying one single thing and returning
+  * either a success or failure.
+  *
+  * All of followed event functions are described in 802.2 LLC Protocol
+  * standard document except two functions that we added that will explain
+  * in their comments, at below.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/types.h>
+ #include <linux/netdevice.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_pdu.h>
+ 
+ extern u16 circular_between(u8 a, u8 b, u8 c);
+ 
+ /*
+  * Function: llc_util_ns_inside_rx_window
+  *
+  * Description:
+  *  Checks if sequence number of received PDU is in range of receive window.
+  *
+  * Parameters:
+  *  u8 ns : This argument is sequence number of received pdu.
+  *  u8 vr : This argument is sequence number which receiver expects
+  *  	to receive.
+  *  u8 rw : This argument is receive window size of receiver.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ static u16 llc_util_ns_inside_rx_window(u8 ns, u8 vr, u8 rw)
+ {
+ 	return !circular_between(vr, ns, (vr + rw - 1) % LLC_2_SEQ_NBR_MODULO);
+ }
+ 
+ /*
+  * Function: llc_util_nr_inside_tx_window
+  *
+  * Description:
+  *  This routine checks if N(R) of received PDU is in range of transmit
+  *  window; on the other hand checks if received PDU acknowledges some
+  *  outstanding PDUs that are in transmit window.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection.
+  *  u8 nr : This argument is N(R) of received PDU.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ static u16 llc_util_nr_inside_tx_window(struct p8022_connection *conn, u8 nr)
+ {
+ 	u8 nr1, nr2;
+ 	struct sk_buff *skb;
+ 	pdu_sn_t *pdu;
+ 
+ 	if (conn->local_dev->flags & IFF_LOOPBACK)
+ 		return 0;
+ 	if (!skb_queue_len(&conn->pdu_unack_q))
+ 		return 1;
+ 	skb = skb_peek(&conn->pdu_unack_q);
+ 	pdu = (pdu_sn_t *)skb->nh.raw;
+ 	nr1 = LLC_I_GET_NS(pdu);
+ 	skb = skb_peek_tail(&conn->pdu_unack_q);
+ 	pdu = (pdu_sn_t *)skb->nh.raw;
+ 	nr2 = LLC_I_GET_NS(pdu);
+ 	return !circular_between(nr1, nr, (nr2 + 1) % LLC_2_SEQ_NBR_MODULO);
+ }
+ 
+ u16 conn_ev_connect_request(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	return event->data.prim.prim == P8022_CONNECT_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ }
+ 
+ u16 conn_ev_connect_response(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	return event->data.prim.prim == P8022_CONNECT_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_RESPONSE ? 0 : 1;
+ }
+ 
+ u16 conn_ev_data_request(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	return event->data.prim.prim == P8022_DATA_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ }
+ 
+ u16 conn_ev_disconnect_request(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	return event->data.prim.prim == P8022_DISCONNECT_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ }
+ 
+ u16 conn_ev_reset_request(struct p8022_connection *conn,
+ 			  struct conn_state_event *event)
+ {
+ 	return event->data.prim.prim == P8022_RESET_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ }
+ 
+ u16 conn_ev_reset_response(struct p8022_connection *conn,
+ 			   struct conn_state_event *event)
+ {
+ 	return event->data.prim.prim == P8022_RESET_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_RESPONSE ? 0 : 1;
+ }
+ 
+ u16 conn_ev_local_busy_detected(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	return event->type == CONN_EV_TYPE_SIMPLE &&
+ 	       event->data.a.event == CONN_EV_LOCAL_BUSY_DETECTED ? 0 : 1;
+ }
+ 
+ u16 conn_ev_local_busy_cleared(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	return event->type == CONN_EV_TYPE_SIMPLE &&
+ 	       event->data.a.event == CONN_EV_LOCAL_BUSY_CLEARED ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_bad_pdu(struct p8022_connection *conn,
+ 		       struct conn_state_event *event)
+ {
+ 	return 1;
+ }
+ 
+ u16 conn_ev_rx_disc_cmd_pbit_set_x(struct p8022_connection *conn,
+ 				   struct conn_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_CMD(pdu) == LLC_2_PDU_CMD_DISC ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_dm_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_RSP(pdu) == LLC_2_PDU_RSP_DM ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_frmr_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				   struct conn_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_RSP(pdu) == LLC_2_PDU_RSP_FRMR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_cmd_pbit_set_0(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_0(pdu) && LLC_I_GET_NS(pdu) == conn->vR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_cmd_pbit_set_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_1(pdu) && LLC_I_GET_NS(pdu) == conn->vR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vr = conn->vR;
+ 	u8 ns = LLC_I_GET_NS(pdu);
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_0(pdu) && ns != vr &&
+ 	       !llc_util_ns_inside_rx_window(ns, vr, conn->rw) ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vr = conn->vR;
+ 	u8 ns = LLC_I_GET_NS(pdu);
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_1(pdu) && ns != vr &&
+ 	       !llc_util_ns_inside_rx_window(ns, vr, conn->rw) ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_cmd_pbit_set_x_inval_ns(struct p8022_connection *conn,
+ 					 struct conn_state_event *event)
+ {
+ 	pdu_sn_t * pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vr = conn->vR;
+ 	u8 ns = LLC_I_GET_NS(pdu);
+ 	u16 rc = !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) && ns != vr &&
+ 		 llc_util_ns_inside_rx_window(ns, vr, conn->rw) ? 0 : 1;
+ 	if (!rc)
+ 		printk(KERN_WARNING "rx_i_cmd_p_bit_set_x_inval_ns matched,"
+ 		       "state = %d, ns = %d, vr = %d\n", conn->state, ns, vr);
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_i_rsp_fbit_set_0(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_0(pdu) && LLC_I_GET_NS(pdu) == conn->vR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_rsp_fbit_set_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_1(pdu) && LLC_I_GET_NS(pdu) == conn->vR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       LLC_I_GET_NS(pdu) == conn->vR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vr = conn->vR;
+ 	u8 ns = LLC_I_GET_NS(pdu);
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_0(pdu) && ns != vr &&
+ 	       !llc_util_ns_inside_rx_window(ns, vr, conn->rw) ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vr = conn->vR;
+ 	u8 ns = LLC_I_GET_NS(pdu);
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+ 	       !LLC_I_PF_IS_1(pdu) && ns != vr &&
+ 	       !llc_util_ns_inside_rx_window(ns, vr, conn->rw) ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_rsp_fbit_set_x_unexpd_ns(struct p8022_connection *conn,
+ 					  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vr = conn->vR;
+ 	u8 ns = LLC_I_GET_NS(pdu);
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) && ns != vr &&
+ 	       !llc_util_ns_inside_rx_window(ns, vr, conn->rw) ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_i_rsp_fbit_set_x_inval_ns(struct p8022_connection *conn,
+ 					 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vr = conn->vR;
+ 	u8 ns = LLC_I_GET_NS(pdu);
+ 	u16 rc = !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) && ns != vr &&
+ 		 llc_util_ns_inside_rx_window(ns, vr, conn->rw) ? 0 : 1;
+ 	if (!rc)
+ 		printk(KERN_WARNING "conn_ev_rx_i_rsp_fbit_set_x_inval_ns "
+ 		       "matched : state = %d, ns = %d, vr = %d\n",
+ 		       conn->state, ns, vr);
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_rej_cmd_pbit_set_0(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_0(pdu) &&
+ 	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_REJ ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rej_cmd_pbit_set_1(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_1(pdu) &&
+ 	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_REJ ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rej_rsp_fbit_set_0(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_0(pdu) &&
+ 	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_REJ ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rej_rsp_fbit_set_1(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_1(pdu) &&
+ 	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_REJ ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rej_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_REJ ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rnr_cmd_pbit_set_0(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_0(pdu) &&
+ 	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RNR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rnr_cmd_pbit_set_1(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_1(pdu) &&
+ 	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RNR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rnr_rsp_fbit_set_0(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_0(pdu) &&
+ 	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RNR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rnr_rsp_fbit_set_1(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_1(pdu) &&
+ 	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RNR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rr_cmd_pbit_set_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_0(pdu) &&
+ 	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rr_cmd_pbit_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_1(pdu) &&
+ 	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rr_rsp_fbit_set_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_0(pdu) &&
+ 	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_rr_rsp_fbit_set_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+ 	       !LLC_S_PF_IS_1(pdu) &&
+ 	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RR ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_sabme_cmd_pbit_set_x(struct p8022_connection *conn,
+ 				    struct conn_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_CMD(pdu) == LLC_2_PDU_CMD_SABME ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_ua_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_RSP(pdu) == LLC_2_PDU_RSP_UA ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rx_xxx_cmd_pbit_set_1(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	if (!LLC_PDU_IS_CMD(pdu)) {
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+ 			if (!LLC_I_PF_IS_1(pdu))
+ 				rc = 0;
+ 		} else if (!LLC_PDU_TYPE_IS_U(pdu) && !LLC_U_PF_IS_1(pdu))
+ 			rc = 0;
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_xxx_cmd_pbit_set_0(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	if (!LLC_PDU_IS_CMD(pdu)) {
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+ 			if (!LLC_I_PF_IS_0(pdu))
+ 				rc = 0;
+ 		} else if (!LLC_PDU_TYPE_IS_U(pdu))
+ 			switch (LLC_U_PDU_CMD(pdu)) {
+ 				case LLC_2_PDU_CMD_SABME:
+ 				case LLC_2_PDU_CMD_DISC:
+ 					if (!LLC_U_PF_IS_0(pdu))
+ 						rc = 0;
+ 					break;
+ 			}
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_xxx_cmd_pbit_set_x(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	if (!LLC_PDU_IS_CMD(pdu)) {
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu))
+ 			rc = 0;
+ 		else if (!LLC_PDU_TYPE_IS_U(pdu))
+ 			switch (LLC_U_PDU_CMD(pdu)) {
+ 				case LLC_2_PDU_CMD_SABME:
+ 				case LLC_2_PDU_CMD_DISC:
+ 					rc = 0;
+ 					break;
+ 			}
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_xxx_rsp_fbit_set_1(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	if (!LLC_PDU_IS_RSP(pdu)) {
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+ 			if (!LLC_I_PF_IS_1(pdu))
+ 				rc = 0;
+ 		} else if (!LLC_PDU_TYPE_IS_U(pdu))
+ 			switch (LLC_U_PDU_RSP(pdu)) {
+ 				case LLC_2_PDU_RSP_UA:
+ 				case LLC_2_PDU_RSP_DM:
+ 				case LLC_2_PDU_RSP_FRMR:
+ 					if (!LLC_U_PF_IS_1(pdu))
+ 						rc = 0;
+ 					break;
+ 			}
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_xxx_rsp_fbit_set_x(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	if (!LLC_PDU_IS_RSP(pdu)) {
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu))
+ 			rc = 0;
+ 		else if (!LLC_PDU_TYPE_IS_U(pdu))
+ 			switch (LLC_U_PDU_RSP(pdu)) {
+ 				case LLC_2_PDU_RSP_UA:
+ 				case LLC_2_PDU_RSP_DM:
+ 				case LLC_2_PDU_RSP_FRMR:
+ 					rc = 0;
+ 					break;
+ 			}
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_xxx_yyy(struct p8022_connection *conn,
+ 		       struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu))
+ 		rc = 0;
+ 	else if (!LLC_PDU_TYPE_IS_U(pdu))
+ 		switch (LLC_U_PDU_CMD(pdu)) {
+ 			case LLC_2_PDU_CMD_SABME:
+ 			case LLC_2_PDU_CMD_DISC:
+ 			case LLC_2_PDU_RSP_UA:
+ 			case LLC_2_PDU_RSP_DM:
+ 			case LLC_2_PDU_RSP_FRMR:
+ 				rc = 0;
+ 				break;
+ 		}
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_zzz_cmd_pbit_set_x_inval_nr(struct p8022_connection *conn,
+ 					   struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vs = conn->vS;
+ 	u8 nr = LLC_I_GET_NR(pdu);
+ 
+ 	if (!LLC_PDU_IS_CMD(pdu)) {
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+ 			if (nr != vs &&
+ 			    llc_util_nr_inside_tx_window(conn, nr)) {
+ 				printk(KERN_ERR "conn_ev_rx_zzz_cmd_inv_nr "
+ 				       "matched,state = %d, vs = %d, nr = %d\n",
+ 				       conn->state,vs,nr);
+ 				rc = 0;
+ 			}
+ 		}
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_zzz_rsp_fbit_set_x_inval_nr(struct p8022_connection *conn,
+ 					   struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 	u8 vs = conn->vS;
+ 	u8 nr = LLC_I_GET_NR(pdu);
+ 
+ 	if (!LLC_PDU_IS_RSP(pdu)) {
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+ 			if (nr != vs &&
+ 			    llc_util_nr_inside_tx_window(conn, nr)) {
+ 				rc = 0;
+ 				printk(KERN_ERR "conn_ev_rx_zzz_fbit_set"
+ 					"_x_inval_nr matched, state = %d, "
+ 					"vs = %d, nr = %d\n",
+ 					conn->state, vs, nr);
+ 			}
+ 		}
+ 	}
+ 	return rc;
+ }
+ 
+ u16 conn_ev_rx_any_frame(struct p8022_connection *conn,
+ 			 struct conn_state_event *event)
+ {
+ 	return 0;
+ }
+ 
+ u16 conn_ev_p_timer_expired(struct p8022_connection *conn,
+ 			    struct conn_state_event *event)
+ {
+ 	return event->type == CONN_EV_TYPE_P_TIMER ? 0 : 1;
+ }
+ 
+ u16 conn_ev_ack_timer_expired(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	return event->type == CONN_EV_TYPE_ACK_TIMER ? 0 : 1;
+ }
+ 
+ u16 conn_ev_rej_timer_expired(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 	return event->type == CONN_EV_TYPE_REJ_TIMER ? 0 : 1;
+ }
+ 
+ u16 conn_ev_busy_timer_expired(struct p8022_connection *conn,
+ 			       struct conn_state_event *event)
+ {
+ 	return event->type == CONN_EV_TYPE_BUSY_TIMER ? 0 : 1;
+ }
+ 
+ u16 conn_ev_any_timer_expired(struct p8022_connection *conn,
+ 			      struct conn_state_event *event)
+ {
+ 
+ 	return event->type == CONN_EV_TYPE_P_TIMER ||
+ 	       event->type == CONN_EV_TYPE_ACK_TIMER ||
+ 	       event->type == CONN_EV_TYPE_REJ_TIMER ||
+ 	       event->type == CONN_EV_TYPE_BUSY_TIMER ? 0 : 1;
+ }
+ 
+ u16 conn_ev_init_p_f_cycle(struct p8022_connection *conn,
+ 			   struct conn_state_event *event)
+ {
+ 	return 1;
+ }
+ 
+ u16 conn_ev_tx_buffer_full(struct p8022_connection *conn,
+ 			   struct conn_state_event *event)
+ {
+ 	return event->type == CONN_EV_TYPE_SIMPLE &&
+ 	       event->data.a.event == CONN_EV_TX_BUFF_FULL ? 0 : 1;
+ }
+ 
+ /* --------------------- EVENT QUALIFIER FUNCTIONS ----------------------- *
+  *
+  * these functions simply verify the value of a state flag associated with
+  * the connection and return either a 0 for success or a non-zero value
+  * for not-success; verify the event is the type we expect
+  *
+  * ----------------------------------------------------------------------- */
+ 
+ u16 conn_ev_qlfy_data_flag_eq_1(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	return conn->data_flag == 1 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_data_flag_eq_0(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	return conn->data_flag == 0 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_data_flag_eq_2(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	return conn->data_flag == 2 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_p_flag_eq_1(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	return conn->p_flag == 1 ? 0 : 1;
+ }
+ 
+ /*
+  * Function: conn_ev_qlfy_last_frame_eq_1
+  *
+  * Description:
+  *  This function determines when frame which is sent, is last frame of
+  *  transmit window, if it is then this function return zero else return one.
+  *  This function is used for sending last frame of transmit window as
+  *  I-format command with p-bit set to one.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : If frame is last frame.
+  *  1 : If frame isn't last frame.
+  */
+ u16 conn_ev_qlfy_last_frame_eq_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	return skb_queue_len(&conn->pdu_unack_q) + 1 == conn->k ? 0 : 1;
+ }
+ 
+ /*
+  * Function: conn_ev_qlfy_last_frame_eq_0
+  *
+  * Description:
+  *  This function determines when frame which is sent, isn't last frame of
+  *  transmit window, if it isn't then this function return zero else return
+  *  one.
+  *
+  * Parameters:
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  struct conn_state_event *event : This argument points to current event.
+  *
+  * Returns:
+  *  0 : If frame isn't last frame.
+  *  1 : If frame is last frame.
+  */
+ u16 conn_ev_qlfy_last_frame_eq_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	return skb_queue_len(&conn->pdu_unack_q) + 1 == conn->k ? 1 : 0;
+ }
+ 
+ u16 conn_ev_qlfy_p_flag_eq_0(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	return conn->p_flag == 0 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_p_flag_eq_f(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	u8 f_bit;
+ 	struct sk_buff *skb;
+ 
+ 	if (event->type == CONN_EV_TYPE_PDU)
+ 		skb = event->data.pdu.skb;
+ 	else
+ 		skb = event->data.prim.data->data->conn.skb;
+ 	pdu_decode_pf_bit(skb, &f_bit);
+ 	return conn->p_flag == f_bit ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_remote_busy_eq_0(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	return conn->remote_busy_flag == 0 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_remote_busy_eq_1(struct p8022_connection *conn,
+ 				  struct conn_state_event *event)
+ {
+ 	return conn->remote_busy_flag == 1 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_retry_count_lt_n2(struct p8022_connection *conn,
+ 				   struct conn_state_event *event)
+ {
+ 	return conn->retry_count < conn->n2 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_retry_count_gte_n2(struct p8022_connection *conn,
+ 				    struct conn_state_event *event)
+ {
+ 	return conn->retry_count >= conn->n2 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_s_flag_eq_1(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	return conn->s_flag == 1 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_s_flag_eq_0(struct p8022_connection *conn,
+ 			     struct conn_state_event *event)
+ {
+ 	return conn->s_flag == 0 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_cause_flag_eq_1(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	return conn->cause_flag == 1 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_cause_flag_eq_0(struct p8022_connection *conn,
+ 				 struct conn_state_event *event)
+ {
+ 	return conn->cause_flag == 0 ? 0 : 1;
+ }
+ 
+ u16 conn_ev_qlfy_init_p_f_cycle(struct p8022_connection *conn,
+ 				struct conn_state_event *event)
+ {
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_connect(struct p8022_connection *conn,
+ 				    struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_CONNECT;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_disconnect(struct p8022_connection *conn,
+ 				       struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_DISCONNECT;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_impossible(struct p8022_connection *conn,
+ 				       struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_IMPOSSIBLE;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_failed(struct p8022_connection *conn,
+ 				   struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_FAILED;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_remote_busy(struct p8022_connection *conn,
+ 					struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_REMOTE_BUSY;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_received(struct p8022_connection *conn,
+ 				     struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_RECEIVED;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_refuse(struct p8022_connection *conn,
+ 				   struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_REFUSE;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_conflict(struct p8022_connection *conn,
+ 				     struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_CONFLICT;
+ 	return 0;
+ }
+ 
+ u16 conn_ev_qlfy_set_status_reset_done(struct p8022_connection *conn,
+ 				       struct conn_state_event *event)
+ {
+ 	event->status = P8022_STATUS_RESET_DONE;
+ 	return 0;
+ }
Index: kernel-acme/net/8022llc/llc_c_st.c
diff -c /dev/null kernel-acme/net/8022llc/llc_c_st.c:1.1.4.6
*** /dev/null	Wed Sep  5 00:22:27 2001
--- kernel-acme/net/8022llc/llc_c_st.c	Tue Aug 28 01:32:08 2001
***************
*** 0 ****
--- 1,5609 ----
+ /*
+  * llc_c_st.c - This module contains state transition of connection component.
+  *
+  * Description of event functions and actions there is in 802.2 LLC standard,
+  * or in "llc_c_ac.c" and "llc_c_ev.c" modules.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/skbuff.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_c_ac.h>
+ #include <net/llc_c_st.h>
+ #include <net/llc_pdu.h>
+ 
+ #define NO_EVENT_QUALIFIERS    NULL
+ #define NO_TRANSITION_ACTIONS  NULL
+ 
+ /* ----------------- COMMON CONNECTION STATE transitions ----------------- *
+  * Common transitions for
+  * CONN_STATE_NORMAL,
+  * CONN_STATE_BUSY,
+  * CONN_STATE_REJECT,
+  * CONN_STATE_AWAIT,
+  * CONN_STATE_AWAIT_BUSY  and
+  * CONN_STATE_AWAIT_REJECT  states
+  */
+ /*
+  * State transitions for
+  * CONN_EV_DISCONNECT_REQUEST event
+  */
+ static conn_action_t common_actions_1[] = {
+ 	conn_ac_send_disc_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_1 = {
+ 	conn_ev_disconnect_request,
+ 	CONN_STATE_D_CONN,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RESET_REQUEST event
+  */
+ static conn_action_t common_actions_2[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_2 = {
+ 	conn_ev_reset_request,
+ 	CONN_STATE_RESET,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_SABME_CMD_Pbit_SET_X event
+  */
+ static conn_action_t common_actions_3[] = {
+ 	conn_ac_stop_all_timers,
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	conn_ac_reset_indication,
+ 	conn_ac_set_p_flag_0,
+ 	conn_ac_set_remote_busy_0,
+ 	conn_reset,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_3 = {
+ 	conn_ev_rx_sabme_cmd_pbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DISC_CMD_Pbit_SET_X event
+  */
+ static conn_action_t common_actions_4[] = {
+ 	conn_ac_stop_all_timers,
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	conn_ac_disconnect_indication,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_4 = {
+ 	conn_ev_rx_disc_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_FRMR_RSP_Fbit_SET_X event
+  */
+ static conn_action_t common_actions_5[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_reset_indication,
+ 	conn_ac_set_cause_flag_0,
+ 	conn_reset,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_5 = {
+ 	conn_ev_rx_frmr_rsp_fbit_set_x,
+ 	CONN_STATE_RESET,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_5
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DM_RSP_Fbit_SET_X event
+  */
+ static conn_action_t common_actions_6[] = {
+ 	conn_ac_disconnect_indication,
+ 	conn_ac_stop_all_timers,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_6 = {
+ 	conn_ev_rx_dm_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	NO_EVENT_QUALIFIERS,
+         common_actions_6
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_ZZZ_CMD_Pbit_SET_X_INVAL_Nr event
+  */
+ static conn_action_t common_actions_7a[] = {
+ 	conn_ac_send_frmr_rsp_f_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_7a = {
+ 	conn_ev_rx_zzz_cmd_pbit_set_x_inval_nr,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_7a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_X_INVAL_Ns event
+  */
+ static conn_action_t common_actions_7b[] = {
+ 	conn_ac_send_frmr_rsp_f_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_7b = {
+ 	conn_ev_rx_i_cmd_pbit_set_x_inval_ns,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_7b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_ZZZ_RSP_Fbit_SET_X_INVAL_Nr event
+  */
+ static conn_action_t common_actions_8a[] = {
+ 	conn_ac_send_frmr_rsp_f_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_8a = {
+ 	conn_ev_rx_zzz_rsp_fbit_set_x_inval_nr,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_8a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_X_INVAL_Ns event
+  */
+ static conn_action_t common_actions_8b[] = {
+ 	conn_ac_send_frmr_rsp_f_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_8b = {
+ 	conn_ev_rx_i_rsp_fbit_set_x_inval_ns,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_8b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_BAD_PDU event
+  */
+ static conn_action_t common_actions_8c[] = {
+ 	conn_ac_send_frmr_rsp_f_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_8c = {
+ 	conn_ev_rx_bad_pdu,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_8c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_UA_RSP_Fbit_SET_X event
+  */
+ static conn_action_t common_actions_9[] = {
+ 	conn_ac_send_frmr_rsp_f_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_9 = {
+ 	conn_ev_rx_ua_rsp_fbit_set_x,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	common_actions_9
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_XXX_RSP_Fbit_SET_1 event
+  */
+ #if 0
+ static conn_event_qfyr_t common_ev_qfyrs_10[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t common_actions_10[] = {
+ 	conn_ac_send_frmr_rsp_f_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_10 = {
+ 	conn_ev_rx_xxx_rsp_fbit_set_1,
+ 	CONN_STATE_ERROR,
+ 	common_ev_qfyrs_10,
+ 	common_actions_10
+ };
+ #endif
+ 
+ /*
+  * State transitions for
+  * CONN_EV_P_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t common_ev_qfyrs_11a[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t common_actions_11a[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_11a = {
+ 	conn_ev_p_timer_expired,
+ 	CONN_STATE_RESET,
+ 	common_ev_qfyrs_11a,
+ 	common_actions_11a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t common_ev_qfyrs_11b[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t common_actions_11b[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_11b = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_RESET,
+ 	common_ev_qfyrs_11b,
+ 	common_actions_11b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_REJ_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t common_ev_qfyrs_11c[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t common_actions_11c[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_11c = {
+ 	conn_ev_rej_timer_expired,
+ 	CONN_STATE_RESET,
+ 	common_ev_qfyrs_11c,
+ 	common_actions_11c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_BUSY_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t common_ev_qfyrs_11d[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t common_actions_11d[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_stop_other_timers,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t common_state_transition_11d = {
+ 	conn_ev_busy_timer_expired,
+ 	CONN_STATE_RESET,
+ 	common_ev_qfyrs_11d,
+ 	common_actions_11d
+ };
+ 
+ /*
+  * Common dummy state transition; must be last entry for all state
+  * transition groups
+  */
+ static conn_state_transition_t common_state_transition_n = {
+ 	NULL,
+ 	0,
+ 	NULL,
+ 	NULL
+ };
+ 
+ /* --------------------- CONN_STATE_ADM transitions ---------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_CONNECT_REQUEST event
+  */
+ static conn_action_t adm_actions_1[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_s_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t adm_state_transition_1 = {
+ 	conn_ev_connect_request,
+ 	CONN_STATE_SETUP,
+ 	NO_EVENT_QUALIFIERS,
+ 	adm_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_SABME_CMD_Pbit_SET_X event
+  */
+ static conn_action_t adm_actions_2[] = {
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_p_flag_0,
+ 	conn_ac_set_remote_busy_0,
+ 	conn_ac_connect_indication,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t adm_state_transition_2 = {
+ 	conn_ev_rx_sabme_cmd_pbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	adm_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DISC_CMD_Pbit_SET_X event
+  */
+ static conn_action_t adm_actions_3[] = {
+ 	conn_ac_send_dm_rsp_f_set_p,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t adm_state_transition_3 = {
+ 	conn_ev_rx_disc_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	NO_EVENT_QUALIFIERS,
+ 	adm_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_XXX_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t adm_actions_4[] = {
+ 	conn_ac_send_dm_rsp_f_set_1,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t adm_state_transition_4 = {
+ 	conn_ev_rx_xxx_cmd_pbit_set_1,
+ 	CONN_STATE_ADM,
+ 	NO_EVENT_QUALIFIERS,
+ 	adm_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_XXX_YYY event
+  */
+ static conn_action_t adm_actions_5[] = {
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t adm_state_transition_5 = {
+ 	conn_ev_rx_any_frame,
+ 	CONN_OUT_OF_SVC,
+ 	NO_EVENT_QUALIFIERS,
+ 	adm_actions_5
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *adm_state_transitions[] = {
+ 	&adm_state_transition_1,     // Request
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,  // local_busy
+ 	&common_state_transition_n,  // init_pf_cycle
+ 	&common_state_transition_n,  // timer
+ 	&adm_state_transition_2,     // Receive frame
+ 	&adm_state_transition_3,
+ 	&adm_state_transition_4,
+ 	&adm_state_transition_5,
+ 	&common_state_transition_n
+ };
+ 
+ /* ---------------------  CONN_STATE_SETUP transitions ------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_RX_SABME_CMD_Pbit_SET_X event
+  */
+ static conn_action_t setup_actions_1[] = {
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_set_s_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t setup_state_transition_1 = {
+ 	conn_ev_rx_sabme_cmd_pbit_set_x,
+ 	CONN_STATE_SETUP,
+ 	NO_EVENT_QUALIFIERS,
+ 	setup_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_UA_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t setup_ev_qfyrs_2[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	conn_ev_qlfy_set_status_connect,
+ 	NULL
+ };
+ 
+ static conn_action_t setup_actions_2[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_set_remote_busy_0,
+ 	conn_ac_connect_confirm,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t setup_state_transition_2 = {
+ 	conn_ev_rx_ua_rsp_fbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	setup_ev_qfyrs_2,
+ 	setup_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t setup_ev_qfyrs_3[] = {
+ 	conn_ev_qlfy_s_flag_eq_1,
+ 	conn_ev_qlfy_set_status_connect,
+ 	NULL
+ };
+ 
+ static conn_action_t setup_actions_3[] = {
+ 	conn_ac_set_p_flag_0,
+ 	conn_ac_set_remote_busy_0,
+ 	conn_ac_connect_confirm,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t setup_state_transition_3 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_NORMAL,
+ 	setup_ev_qfyrs_3,
+ 	setup_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DISC_CMD_Pbit_SET_X event
+  */
+ static conn_event_qfyr_t setup_ev_qfyrs_4[] = {
+ 	conn_ev_qlfy_set_status_disconnect,
+ 	NULL
+ };
+ 
+ static conn_action_t setup_actions_4[] = {
+ 	conn_ac_send_dm_rsp_f_set_p,
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_connect_confirm,
+  	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t setup_state_transition_4 = {
+ 	conn_ev_rx_disc_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	setup_ev_qfyrs_4,
+ 	setup_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DM_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t setup_ev_qfyrs_5[] = {
+ 	conn_ev_qlfy_set_status_disconnect,
+ 	NULL
+ };
+ 
+ static conn_action_t setup_actions_5[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_connect_confirm,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t setup_state_transition_5 = {
+ 	conn_ev_rx_dm_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	setup_ev_qfyrs_5,
+ 	setup_actions_5
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t setup_ev_qfyrs_7[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	conn_ev_qlfy_s_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t setup_actions_7[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t setup_state_transition_7 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_SETUP,
+ 	setup_ev_qfyrs_7,
+ 	setup_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t setup_ev_qfyrs_8[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	conn_ev_qlfy_s_flag_eq_0,
+ 	conn_ev_qlfy_set_status_failed,
+ 	NULL
+ };
+ 
+ static conn_action_t setup_actions_8[] = {
+ 	conn_ac_connect_confirm,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t setup_state_transition_8 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_ADM,
+ 	setup_ev_qfyrs_8,
+ 	setup_actions_8
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *setup_state_transitions[] = {
+ 	&common_state_transition_n,  // Request
+ 	&common_state_transition_n,  // local busy
+ 	&common_state_transition_n,  // init_pf_cycle
+ 	&setup_state_transition_3,   // Timer
+ 	&setup_state_transition_7,
+ 	&setup_state_transition_8,
+ 	&common_state_transition_n,
+ 	&setup_state_transition_1,    // Receive frame
+ 	&setup_state_transition_2,
+ 	&setup_state_transition_4,
+ 	&setup_state_transition_5,
+ 	&common_state_transition_n
+ };
+ 
+ /* -------------------- CONN_STATE_NORMAL transitions -------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_1[] = {
+ 	conn_ev_qlfy_remote_busy_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_last_frame_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_1[] = {
+ 	conn_ac_send_i_as_ack,
+ 	conn_ac_start_ack_timer_if_not_running,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_1 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_1,
+ 	normal_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_2[] = {
+ 	conn_ev_qlfy_remote_busy_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_last_frame_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_2[] = {
+ 	conn_ac_send_i_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_2 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_2,
+ 	normal_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_2_1[] = {
+ 	conn_ev_qlfy_remote_busy_eq_1,
+ 	conn_ev_qlfy_set_status_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_2_1[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_2_1 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_2_1,
+ 	normal_actions_2_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_DETECTED event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_3[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_3[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rnr_xxx_x_set_0,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_3 = {
+ 	conn_ev_local_busy_detected,
+ 	CONN_STATE_BUSY,
+ 	normal_ev_qfyrs_3,
+ 	normal_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_DETECTED event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_4[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_4[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rnr_xxx_x_set_0,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_4 = {
+ 	conn_ev_local_busy_detected,
+ 	CONN_STATE_BUSY,
+ 	normal_ev_qfyrs_4,
+ 	normal_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_5a[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_5a[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_5a = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	normal_ev_qfyrs_5a,
+ 	normal_actions_5a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_5b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_5b[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_5b = {
+ 	conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	normal_ev_qfyrs_5b,
+ 	normal_actions_5b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_5c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_5c[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_5c = {
+ 	conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	normal_ev_qfyrs_5c,
+ 	normal_actions_5c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_6a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_6a[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_6a = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	normal_ev_qfyrs_6a,
+ 	normal_actions_6a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_6b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_6b[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_6b = {
+ 	conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	normal_ev_qfyrs_6b,
+ 	normal_actions_6b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t normal_actions_7[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rej_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_7 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_8a[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_8[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	conn_ac_send_ack_if_needed,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_8a = {
+ 	conn_ev_rx_i_rsp_fbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_8a,
+ 	normal_actions_8
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_8b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_8b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_8b,
+ 	normal_actions_8
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_9a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_9a[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_ack_if_needed,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_9a = {
+ 	conn_ev_rx_i_rsp_fbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_9a,
+ 	normal_actions_9a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_9b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_9b[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_ack_if_needed,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_9b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_9b,
+ 	normal_actions_9b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t normal_actions_10[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_send_ack_rsp_f_set_1,
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_data_indication,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_10 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_10
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t normal_actions_11a[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_11a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_11a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t normal_actions_11b[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_11b = {
+ 	conn_ev_rx_rr_rsp_fbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_11b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_1 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_11c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_11c[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_increase_transmit_window_size,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_11c = {
+ 	conn_ev_rx_rr_rsp_fbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_11c,
+ 	normal_actions_11c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t normal_actions_12[] = {
+ 	conn_ac_send_ack_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_adjust_npta_by_rr,
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_12 = {
+ 	conn_ev_rx_rr_cmd_pbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_12
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t normal_actions_13a[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_13a = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_13a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t normal_actions_13b[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_13b = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_13b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_1 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_13c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_13c[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_13c = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_13c,
+ 	normal_actions_13c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t normal_actions_14[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_adjust_npta_by_rnr,
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_14 = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_14
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_15a[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_15a[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_decrease_transmit_window_size,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_15a = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_15a,
+ 	normal_actions_15a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_15b[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_15b[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_decrease_transmit_window_size,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_15b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_15b,
+ 	normal_actions_15b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_16a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_16a[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_decrease_transmit_window_size,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_16a = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_16a,
+ 	normal_actions_16a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_0 event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_16b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_16b[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_decrease_transmit_window_size,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_16b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_16b,
+ 	normal_actions_16b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t normal_actions_17[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_decrease_transmit_window_size,
+ 	conn_ac_resend_i_rsp_f_set_1,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_17 = {
+ 	conn_ev_rx_rej_cmd_pbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	normal_actions_17
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_INIT_P_F_CYCLE event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_18[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_18[] = {
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_18 = {
+ 	conn_ev_init_p_f_cycle,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_18,
+ 	normal_actions_18
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_P_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_19[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_19[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_reset_vs,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_19 = {
+ 	conn_ev_p_timer_expired,
+ 	CONN_STATE_AWAIT,
+ 	normal_ev_qfyrs_19,
+ 	normal_actions_19
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_20a[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_20a[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_reset_vs,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_20a = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_AWAIT,
+ 	normal_ev_qfyrs_20a,
+ 	normal_actions_20a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_BUSY_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_20b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_20b[] = {
+ 	conn_ac_reset_sendack_flag,
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_reset_vs,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_20b = {
+ 	conn_ev_busy_timer_expired,
+ 	CONN_STATE_AWAIT,
+ 	normal_ev_qfyrs_20b,
+ 	normal_actions_20b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_TX_BUFF_FULL event
+  */
+ static conn_event_qfyr_t normal_ev_qfyrs_21[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t normal_actions_21[] = {
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t normal_state_transition_21 = {
+ 	conn_ev_tx_buffer_full,
+ 	CONN_STATE_NORMAL,
+ 	normal_ev_qfyrs_21,
+ 	normal_actions_21
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *normal_state_transitions[] = {
+ 	&normal_state_transition_1,     // Requests
+ 	&normal_state_transition_2,
+ 	&normal_state_transition_2_1,
+ 	&common_state_transition_1,
+ 	&common_state_transition_2,
+ 	&common_state_transition_n,
+ 	&normal_state_transition_21,
+ 	&normal_state_transition_3,     // Local busy
+ 	&normal_state_transition_4,
+ 	&common_state_transition_n,
+ 	&normal_state_transition_18,    // Init pf cycle
+ 	&common_state_transition_n,
+ 	&common_state_transition_11a,   // Timers
+ 	&common_state_transition_11b,
+ 	&common_state_transition_11c,
+ 	&common_state_transition_11d,
+ 	&normal_state_transition_19,
+ 	&normal_state_transition_20a,
+ 	&normal_state_transition_20b,
+ 	&common_state_transition_n,
+ 	&normal_state_transition_8b,    // Receive frames
+ 	&normal_state_transition_9b,
+ 	&normal_state_transition_10,
+ 	&normal_state_transition_11b,
+ 	&normal_state_transition_11c,
+ 	&normal_state_transition_5a,
+ 	&normal_state_transition_5b,
+ 	&normal_state_transition_5c,
+ 	&normal_state_transition_6a,
+ 	&normal_state_transition_6b,
+ 	&normal_state_transition_7,
+ 	&normal_state_transition_8a,
+ 	&normal_state_transition_9a,
+ 	&normal_state_transition_11a,
+ 	&normal_state_transition_12,
+ 	&normal_state_transition_13a,
+ 	&normal_state_transition_13b,
+ 	&normal_state_transition_13c,
+ 	&normal_state_transition_14,
+ 	&normal_state_transition_15a,
+ 	&normal_state_transition_15b,
+ 	&normal_state_transition_16a,
+ 	&normal_state_transition_16b,
+ 	&normal_state_transition_17,
+ 	&common_state_transition_3,
+ 	&common_state_transition_4,
+ 	&common_state_transition_5,
+ 	&common_state_transition_6,
+ 	&common_state_transition_7a,
+ 	&common_state_transition_7b,
+ 	&common_state_transition_8a,
+ 	&common_state_transition_8b,
+ 	&common_state_transition_8c,
+ 	&common_state_transition_9,
+ 	//&common_state_transition_10,
+ 	&common_state_transition_n
+ };
+ 
+ /* --------------------- CONN_STATE_BUSY transitions --------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_1[] = {
+ 	conn_ev_qlfy_remote_busy_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_1[] = {
+ 	conn_ac_send_i_xxx_x_set_0,
+ 	conn_ac_start_ack_timer_if_not_running,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_1 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_1,
+ 	busy_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_2[] = {
+ 	conn_ev_qlfy_remote_busy_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_2[] = {
+ 	conn_ac_send_i_xxx_x_set_0,
+ 	conn_ac_start_ack_timer_if_not_running,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_2 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_2,
+ 	busy_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_2_1[] = {
+ 	conn_ev_qlfy_remote_busy_eq_1,
+ 	conn_ev_qlfy_set_status_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_2_1[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_2_1 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_2_1,
+ 	busy_actions_2_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_3[] = {
+ 	conn_ev_qlfy_data_flag_eq_1,
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_3[] = {
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_3 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_REJECT,
+ 	busy_ev_qfyrs_3,
+ 	busy_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_4[] = {
+ 	conn_ev_qlfy_data_flag_eq_1,
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_4[] = {
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_4 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_REJECT,
+ 	busy_ev_qfyrs_4,
+ 	busy_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_5[] = {
+ 	conn_ev_qlfy_data_flag_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_5[] = {
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_5 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_NORMAL,
+ 	busy_ev_qfyrs_5,
+ 	busy_actions_5
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_6[] = {
+ 	conn_ev_qlfy_data_flag_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_6[] = {
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_6 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_NORMAL,
+ 	busy_ev_qfyrs_6,
+ 	busy_actions_6
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_7[] = {
+ 	conn_ev_qlfy_data_flag_eq_2,
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_7[] = {
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_7 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_REJECT,
+ 	busy_ev_qfyrs_7,
+ 	busy_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_8[] = {
+ 	conn_ev_qlfy_data_flag_eq_2,
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_8[] = {
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_8 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_REJECT,
+ 	busy_ev_qfyrs_8,
+ 	busy_actions_8
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_X_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_9a[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_9a[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_data_flag_1_if_data_flag_eq_0,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_9a = {
+ 	conn_ev_rx_i_rsp_fbit_set_x_unexpd_ns,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_9a,
+ 	busy_actions_9a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_9b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_9b[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_data_flag_1_if_data_flag_eq_0,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_9b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_9b,
+ 	busy_actions_9b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_10a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_10a[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_data_flag_1_if_data_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_10a = {
+ 	conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_10a,
+ 	busy_actions_10a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_10b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_10b[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_data_flag_1_if_data_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_10b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_10b,
+ 	busy_actions_10b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t busy_actions_11[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_data_flag_1_if_data_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_11 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_11
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t busy_actions_12[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer_if_data_flag_eq_2,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_12 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_12
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_13a[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_13a[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer_if_data_flag_eq_2,
+ 	conn_ac_set_data_flag_0,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_13a = {
+ 	conn_ev_rx_i_rsp_fbit_set_x,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_13a,
+ 	busy_actions_13a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_13b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_13b[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer_if_data_flag_eq_2,
+ 	conn_ac_set_data_flag_0,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_13b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_13b,
+ 	busy_actions_13b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_14a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_14a[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer_if_data_flag_eq_2,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_14a = {
+ 	conn_ev_rx_i_rsp_fbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_14a,
+ 	busy_actions_14a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_14b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_14b[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer_if_data_flag_eq_2,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_14b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_14b,
+ 	busy_actions_14b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t busy_actions_15a[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_15a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_15a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t busy_actions_15b[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_15b = {
+ 	conn_ev_rx_rr_rsp_fbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_15b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_1 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_15c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_15c[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_15c = {
+ 	conn_ev_rx_rr_rsp_fbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_15c,
+ 	busy_actions_15c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t busy_actions_16[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_16 = {
+ 	conn_ev_rx_rr_cmd_pbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_16
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t busy_actions_17a[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_17a = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_17a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t busy_actions_17b[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_17b = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_17b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_1 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_17c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_17c[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_17c = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_17c,
+ 	busy_actions_17c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t busy_actions_18[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_18 = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_18
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_19a[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_19a[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_19a = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_19a,
+ 	busy_actions_19a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_19b[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_19b[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_19b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_x,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_19b,
+ 	busy_actions_19b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_20a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_20a[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_20a = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_20a,
+ 	busy_actions_20a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_0 event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_20b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_20b[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_20b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_0,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_20b,
+ 	busy_actions_20b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t busy_actions_21[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_21 = {
+ 	conn_ev_rx_rej_cmd_pbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	busy_actions_21
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_INIT_P_F_CYCLE event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_22[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_22[] = {
+  	conn_ac_send_rnr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_22 = {
+ 	conn_ev_init_p_f_cycle,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_22,
+ 	busy_actions_22
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_P_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_23[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_23[] = {
+ 	conn_ac_send_rnr_cmd_p_set_1,
+ 	conn_ac_reset_vs,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_23 = {
+ 	conn_ev_p_timer_expired,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	busy_ev_qfyrs_23,
+ 	busy_actions_23
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_24a[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_24a[] = {
+ 	conn_ac_send_rnr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	conn_ac_reset_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_24a = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	busy_ev_qfyrs_24a,
+ 	busy_actions_24a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_BUSY_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_24b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_24b[] = {
+ 	conn_ac_send_rnr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	conn_ac_reset_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_24b = {
+ 	conn_ev_busy_timer_expired,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	busy_ev_qfyrs_24b,
+ 	busy_actions_24b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_REJ_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_25[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_25[] = {
+ 	conn_ac_send_rnr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	conn_ac_reset_vs,
+ 	conn_ac_set_data_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_25 = {
+ 	conn_ev_rej_timer_expired,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	busy_ev_qfyrs_25,
+ 	busy_actions_25
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_REJ_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t busy_ev_qfyrs_26[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t busy_actions_26[] = {
+ 	conn_ac_set_data_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t busy_state_transition_26 = {
+ 	conn_ev_rej_timer_expired,
+ 	CONN_STATE_BUSY,
+ 	busy_ev_qfyrs_26,
+ 	busy_actions_26
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *busy_state_transitions[] = {
+ 	&common_state_transition_1,      // Request
+ 	&common_state_transition_2,
+ 	&busy_state_transition_1,
+ 	&busy_state_transition_2,
+ 	&busy_state_transition_2_1,
+ 	&common_state_transition_n,
+ 	&busy_state_transition_3,        // Local busy
+ 	&busy_state_transition_4,
+ 	&busy_state_transition_5,
+ 	&busy_state_transition_6,
+ 	&busy_state_transition_7,
+ 	&busy_state_transition_8,
+ 	&common_state_transition_n,
+ 	&busy_state_transition_22,       // Initiate PF cycle
+ 	&common_state_transition_n,
+ 	&common_state_transition_11a,    // Timer
+ 	&common_state_transition_11b,
+ 	&common_state_transition_11c,
+ 	&common_state_transition_11d,
+ 	&busy_state_transition_23,
+ 	&busy_state_transition_24a,
+ 	&busy_state_transition_24b,
+ 	&busy_state_transition_25,
+ 	&busy_state_transition_26,
+ 	&common_state_transition_n,
+ 	&busy_state_transition_9a,       // Receive frame
+ 	&busy_state_transition_9b,
+ 	&busy_state_transition_10a,
+ 	&busy_state_transition_10b,
+ 	&busy_state_transition_11,
+ 	&busy_state_transition_12,
+ 	&busy_state_transition_13a,
+ 	&busy_state_transition_13b,
+ 	&busy_state_transition_14a,
+ 	&busy_state_transition_14b,
+ 	&busy_state_transition_15a,
+ 	&busy_state_transition_15b,
+ 	&busy_state_transition_15c,
+ 	&busy_state_transition_16,
+ 	&busy_state_transition_17a,
+ 	&busy_state_transition_17b,
+ 	&busy_state_transition_17c,
+ 	&busy_state_transition_18,
+ 	&busy_state_transition_19a,
+ 	&busy_state_transition_19b,
+ 	&busy_state_transition_20a,
+ 	&busy_state_transition_20b,
+ 	&busy_state_transition_21,
+ 	&common_state_transition_3,
+ 	&common_state_transition_4,
+ 	&common_state_transition_5,
+ 	&common_state_transition_6,
+ 	&common_state_transition_7a,
+ 	&common_state_transition_7b,
+ 	&common_state_transition_8a,
+ 	&common_state_transition_8b,
+ 	&common_state_transition_8c,
+ 	&common_state_transition_9,
+ 	// &common_state_transition_10,
+ 	&common_state_transition_n
+ };
+ 
+ /* -------------------- CONN_STATE_REJECT transitions -------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_1[] = {
+ 	conn_ev_qlfy_remote_busy_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_1[] = {
+ 	conn_ac_send_i_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_1 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_1,
+ 	reject_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_2[] = {
+ 	conn_ev_qlfy_remote_busy_eq_0,
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_2[] = {
+ 	conn_ac_send_i_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_2 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_2,
+ 	reject_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_2_1[] = {
+ 	conn_ev_qlfy_remote_busy_eq_1,
+ 	conn_ev_qlfy_set_status_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_2_1[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_2_1 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_2_1,
+ 	reject_actions_2_1
+ };
+ 
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_DETECTED event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_3[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_3[] = {
+ 	conn_ac_send_rnr_xxx_x_set_0,
+ 	conn_ac_set_data_flag_2,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_3 = {
+ 	conn_ev_local_busy_detected,
+ 	CONN_STATE_BUSY,
+ 	reject_ev_qfyrs_3,
+ 	reject_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_DETECTED event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_4[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_4[] = {
+ 	conn_ac_send_rnr_xxx_x_set_0,
+ 	conn_ac_set_data_flag_2,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_4 = {
+ 	conn_ev_local_busy_detected,
+ 	CONN_STATE_BUSY,
+ 	reject_ev_qfyrs_4,
+ 	reject_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t reject_actions_5a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_5a = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_5a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t reject_actions_5b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_5b = {
+ 	conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_5b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_5c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_5c[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_5c = {
+ 	conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_5c,
+ 	reject_actions_5c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t reject_actions_6[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_6 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_6
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_7a[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_7a[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_send_ack_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	conn_ac_stop_rej_timer,
+ 	NULL
+ 
+ };
+ 
+ static conn_state_transition_t reject_state_transition_7a = {
+ 	conn_ev_rx_i_rsp_fbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	reject_ev_qfyrs_7a,
+ 	reject_actions_7a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_7b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_7b[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_send_ack_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy_if_f_eq_1,
+ 	conn_ac_stop_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_7b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	reject_ev_qfyrs_7b,
+ 	reject_actions_7b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0 event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_8a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_8a[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_ack_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_8a = {
+ 	conn_ev_rx_i_rsp_fbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	reject_ev_qfyrs_8a,
+ 	reject_actions_8a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_8b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_8b[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_ack_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_8b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_NORMAL,
+ 	reject_ev_qfyrs_8b,
+ 	reject_actions_8b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t reject_actions_9[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_ack_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_stop_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_9 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_9
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t reject_actions_10a[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_10a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_0,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_10a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t reject_actions_10b[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_10b = {
+ 	conn_ev_rx_rr_rsp_fbit_set_0,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_10b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_1 event
+  */
+ static conn_event_qfyr_t   reject_ev_qfyrs_10c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_10c[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_10c = {
+ 	conn_ev_rx_rr_rsp_fbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_10c,
+ 	reject_actions_10c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t reject_actions_11[] = {
+ 	conn_ac_send_ack_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_11 = {
+ 	conn_ev_rx_rr_cmd_pbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_11
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t reject_actions_12a[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_12a = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_0,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_12a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t reject_actions_12b[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_12b = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_0,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_12b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_1 event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_12c[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_12c[] = {
+ 	conn_ac_update_p_flag,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_12c = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_12c,
+ 	reject_actions_12c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t reject_actions_13[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_13 = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_13
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_14a[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_14a[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_14a = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_14a,
+ 	reject_actions_14a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_X event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_14b[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_14b[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_14b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_x,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_14b,
+ 	reject_actions_14b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_15a[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_15a[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_15a = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_15a,
+ 	reject_actions_15a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_0 event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_15b[] = {
+ 	conn_ev_qlfy_p_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_15b[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_15b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_0,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_15b,
+ 	reject_actions_15b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t reject_actions_16[] = {
+ 	conn_ac_set_vs_nr,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_resend_i_rsp_f_set_1,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_16 = {
+ 	conn_ev_rx_rej_cmd_pbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	reject_actions_16
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_INIT_P_F_CYCLE event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_17[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_17[] = {
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_17 = {
+ 	conn_ev_init_p_f_cycle,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_17,
+ 	reject_actions_17
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_REJ_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_18[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_18[] = {
+ 	conn_ac_send_rej_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_18 = {
+ 	conn_ev_rej_timer_expired,
+ 	CONN_STATE_REJECT,
+ 	reject_ev_qfyrs_18,
+ 	reject_actions_18
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_P_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_19[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_19[] = {
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	conn_ac_reset_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_19 = {
+ 	conn_ev_p_timer_expired,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	reject_ev_qfyrs_19,
+ 	reject_actions_19
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_20a[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_20a[] = {
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	conn_ac_reset_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_20a = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	reject_ev_qfyrs_20a,
+ 	reject_actions_20a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_BUSY_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reject_ev_qfyrs_20b[] = {
+ 	conn_ev_qlfy_p_flag_eq_0,
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t reject_actions_20b[] = {
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	conn_ac_reset_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reject_state_transition_20b = {
+ 	conn_ev_busy_timer_expired,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	reject_ev_qfyrs_20b,
+ 	reject_actions_20b
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *reject_state_transitions[] = {
+ 	&common_state_transition_1,      // Request
+ 	&common_state_transition_2,
+ 	&common_state_transition_n,
+ 	&reject_state_transition_1,
+ 	&reject_state_transition_2,
+ 	&reject_state_transition_2_1,
+ 	&reject_state_transition_3,      // Local busy
+ 	&reject_state_transition_4,
+ 	&common_state_transition_n,
+ 	&reject_state_transition_17,     // Initiate PF cycle
+ 	&common_state_transition_n,
+ 	&common_state_transition_11a,    // Timer
+ 	&common_state_transition_11b,
+ 	&common_state_transition_11c,
+ 	&common_state_transition_11d,
+ 	&reject_state_transition_18,
+ 	&reject_state_transition_19,
+ 	&reject_state_transition_20a,
+ 	&reject_state_transition_20b,
+ 	&common_state_transition_n,
+ 	&common_state_transition_3,      // Receive frame
+ 	&common_state_transition_4,
+ 	&common_state_transition_5,
+ 	&common_state_transition_6,
+ 	&common_state_transition_7a,
+ 	&common_state_transition_7b,
+ 	&common_state_transition_8a,
+ 	&common_state_transition_8b,
+ 	&common_state_transition_8c,
+ 	&common_state_transition_9,
+ 	// &common_state_transition_10,
+ 	&reject_state_transition_5a,
+ 	&reject_state_transition_5b,
+ 	&reject_state_transition_5c,
+ 	&reject_state_transition_6,
+ 	&reject_state_transition_7a,
+ 	&reject_state_transition_7b,
+ 	&reject_state_transition_8a,
+ 	&reject_state_transition_8b,
+ 	&reject_state_transition_9,
+ 	&reject_state_transition_10a,
+ 	&reject_state_transition_10b,
+ 	&reject_state_transition_10c,
+ 	&reject_state_transition_11,
+ 	&reject_state_transition_12a,
+ 	&reject_state_transition_12b,
+ 	&reject_state_transition_12c,
+ 	&reject_state_transition_13,
+ 	&reject_state_transition_14a,
+ 	&reject_state_transition_14b,
+ 	&reject_state_transition_15a,
+ 	&reject_state_transition_15b,
+ 	&reject_state_transition_16,
+ 	&common_state_transition_n
+ };
+ 
+ /* -------------------- CONN_STATE_AWAIT transitions --------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_DATA_REQUEST event
+  */
+ static conn_event_qfyr_t await_ev_qfyrs_1_0[] = {
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t await_actions_1_0[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_1_0 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_AWAIT,
+ 	await_ev_qfyrs_1_0,
+ 	await_actions_1_0
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_DETECTED event
+  */
+ static conn_action_t await_actions_1[] = {
+ 	conn_ac_send_rnr_xxx_x_set_0,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_1 = {
+ 	conn_ev_local_busy_detected,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t await_actions_2[] = {
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_2 = {
+ 	conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t await_actions_3a[] = {
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_3a = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_3a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t await_actions_3b[] = {
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_3b = {
+ 	conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_3b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t await_actions_4[] = {
+ 	conn_ac_send_rej_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_start_rej_timer,
+ 	conn_ac_start_p_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_4 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_actions_5[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_resend_i_xxx_x_set_0_or_send_rr,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_5 = {
+ 	conn_ev_rx_i_rsp_fbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_5
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_actions_6a[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_6a = {
+ 	conn_ev_rx_i_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_6a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_actions_6b[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_6b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_6b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_actions_7[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_7 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_actions_8a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_8a = {
+ 	conn_ev_rx_rr_rsp_fbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_8a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_actions_8b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_8b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_8b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_actions_9a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_9a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_9a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_actions_9b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_9b = {
+ 	conn_ev_rx_rr_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_9b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_actions_9c[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_9c = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_9c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_actions_9d[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_9d = {
+ 	conn_ev_rx_rej_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_9d
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_actions_10a[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_10a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_10a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_actions_10b[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_10b = {
+ 	conn_ev_rx_rej_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_10b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_actions_11[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_11 = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_11
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_actions_12a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_12a = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_12a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_actions_12b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_12b = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_12b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_actions_13[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_13 = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_actions_13
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_P_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t await_ev_qfyrs_14[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t await_actions_14[] = {
+ 	conn_ac_send_rr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_state_transition_14 = {
+ 	conn_ev_p_timer_expired,
+ 	CONN_STATE_AWAIT,
+ 	await_ev_qfyrs_14,
+ 	await_actions_14
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *await_state_transitions[] = {
+ 	&common_state_transition_1,      // Request
+ 	&common_state_transition_2,
+ 	&await_state_transition_1_0,
+ 	&common_state_transition_n,
+ 	&await_state_transition_1,       // Local busy
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,      // Initiate PF Cycle
+ 	&common_state_transition_11a,    // Timer
+ 	&common_state_transition_11b,
+ 	&common_state_transition_11c,
+ 	&common_state_transition_11d,
+ 	&await_state_transition_14,
+ 	&common_state_transition_n,
+ 	&common_state_transition_3,      // Receive frame
+ 	&common_state_transition_4,
+ 	&common_state_transition_5,
+ 	&common_state_transition_6,
+ 	&common_state_transition_7a,
+ 	&common_state_transition_7b,
+ 	&common_state_transition_8a,
+ 	&common_state_transition_8b,
+ 	&common_state_transition_8c,
+ 	&common_state_transition_9,
+ 	// &common_state_transition_10,
+ 	&await_state_transition_2,
+ 	&await_state_transition_3a,
+ 	&await_state_transition_3b,
+ 	&await_state_transition_4,
+ 	&await_state_transition_5,
+ 	&await_state_transition_6a,
+ 	&await_state_transition_6b,
+ 	&await_state_transition_7,
+ 	&await_state_transition_8a,
+ 	&await_state_transition_8b,
+ 	&await_state_transition_9a,
+ 	&await_state_transition_9b,
+ 	&await_state_transition_9c,
+ 	&await_state_transition_9d,
+ 	&await_state_transition_10a,
+ 	&await_state_transition_10b,
+ 	&await_state_transition_11,
+ 	&await_state_transition_12a,
+ 	&await_state_transition_12b,
+ 	&await_state_transition_13,
+ 	&common_state_transition_n
+ };
+ 
+ /* ------------------ CONN_STATE_AWAIT_BUSY transitions ------------------ */
+ /*
+  * State transitions for
+  * CONN_EV_DATA_CONN_REQUEST event
+  */
+ static conn_event_qfyr_t await_busy_ev_qfyrs_1_0[] = {
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t await_busy_actions_1_0[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_1_0 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	await_busy_ev_qfyrs_1_0,
+ 	await_busy_actions_1_0
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t await_busy_ev_qfyrs_1[] = {
+ 	conn_ev_qlfy_data_flag_eq_1,
+ 	NULL
+ };
+ 
+ static conn_action_t await_busy_actions_1[] = {
+ 	conn_ac_send_rej_xxx_x_set_0,
+ 	conn_ac_start_rej_timer,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_1 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	await_busy_ev_qfyrs_1,
+ 	await_busy_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t await_busy_ev_qfyrs_2[] = {
+ 	conn_ev_qlfy_data_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t await_busy_actions_2[] = {
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_2 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_AWAIT,
+ 	await_busy_ev_qfyrs_2,
+ 	await_busy_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_CLEARED event
+  */
+ static conn_event_qfyr_t await_busy_ev_qfyrs_3[] = {
+ 	conn_ev_qlfy_data_flag_eq_2,
+ 	NULL
+ };
+ 
+ static conn_action_t await_busy_actions_3[] = {
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_3 = {
+ 	conn_ev_local_busy_cleared,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	await_busy_ev_qfyrs_3,
+ 	await_busy_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t await_busy_actions_4[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_set_data_flag_1,
+ 	conn_ac_clear_remote_busy,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_4 = {
+ 	conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t await_busy_actions_5a[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_data_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_5a = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_5a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t await_busy_actions_5b[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_data_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_5b = {
+ 	conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_5b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t await_busy_actions_6[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_data_flag_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_6 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_6
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_7[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_data_flag_0,
+ 	conn_ac_clear_remote_busy,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_7 = {
+ 	conn_ev_rx_i_rsp_fbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_8a[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_8a = {
+ 	conn_ev_rx_i_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_8a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_8b[] = {
+ 	conn_ac_optional_send_rnr_xxx_x_set_0,
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_8b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_8b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_9[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_data_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_9 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_9
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_10a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_10a = {
+ 	conn_ev_rx_rr_rsp_fbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_10a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_10b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_10b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_10b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_11a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_11a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_11a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_11b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_11b = {
+ 	conn_ev_rx_rr_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_11b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_11c[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_11c = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_11c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_11d[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_11d = {
+ 	conn_ev_rx_rej_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_11d
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_12a[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_12a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_12a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_12b[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_12b = {
+ 	conn_ev_rx_rej_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_12b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_13[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_13 = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_1,
+ 	CONN_STATE_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_13
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_14a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_14a = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_14a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_busy_actions_14b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_14b = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_14b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_busy_actions_15[] = {
+ 	conn_ac_send_rnr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_15 = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_busy_actions_15
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_P_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t await_busy_ev_qfyrs_16[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t await_busy_actions_16[] = {
+ 	conn_ac_send_rnr_cmd_p_set_1,
+ 	conn_ac_start_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_busy_state_transition_16 = {
+ 	conn_ev_p_timer_expired,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	await_busy_ev_qfyrs_16,
+ 	await_busy_actions_16
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *await_busy_state_transitions[] = {
+ 	&common_state_transition_1,          // Request
+ 	&common_state_transition_2,
+ 	&await_busy_state_transition_1_0,
+ 	&common_state_transition_n,
+ 	&await_busy_state_transition_1,      // Local busy
+ 	&await_busy_state_transition_2,
+ 	&await_busy_state_transition_3,
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,          // Initiate PF cycle
+ 	&common_state_transition_11a,        // Timer
+ 	&common_state_transition_11b,
+ 	&common_state_transition_11c,
+ 	&common_state_transition_11d,
+ 	&await_busy_state_transition_16,
+ 	&common_state_transition_n,
+ 	&await_busy_state_transition_4,      // Receive frame
+ 	&await_busy_state_transition_5a,
+ 	&await_busy_state_transition_5b,
+ 	&await_busy_state_transition_6,
+ 	&await_busy_state_transition_7,
+ 	&await_busy_state_transition_8a,
+ 	&await_busy_state_transition_8b,
+ 	&await_busy_state_transition_9,
+ 	&await_busy_state_transition_10a,
+ 	&await_busy_state_transition_10b,
+ 	&await_busy_state_transition_11a,
+ 	&await_busy_state_transition_11b,
+ 	&await_busy_state_transition_11c,
+ 	&await_busy_state_transition_11d,
+ 	&await_busy_state_transition_12a,
+ 	&await_busy_state_transition_12b,
+ 	&await_busy_state_transition_13,
+ 	&await_busy_state_transition_14a,
+ 	&await_busy_state_transition_14b,
+ 	&await_busy_state_transition_15,
+ 	&common_state_transition_3,
+ 	&common_state_transition_4,
+ 	&common_state_transition_5,
+ 	&common_state_transition_6,
+ 	&common_state_transition_7a,
+ 	&common_state_transition_7b,
+ 	&common_state_transition_8a,
+ 	&common_state_transition_8b,
+ 	&common_state_transition_8c,
+ 	&common_state_transition_9,
+ 	// &common_state_transition_10,
+ 	&common_state_transition_n
+ };
+ 
+ /* ----------------- CONN_STATE_AWAIT_REJECT transitions ----------------- */
+ /*
+  * State transitions for
+  * CONN_EV_DATA_CONN_REQUEST event
+  */
+ static conn_event_qfyr_t await_reject_ev_qfyrs_1_0[] = {
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t await_reject_actions_1_0[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_reject_state_transition_1_0 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	await_reject_ev_qfyrs_1_0,
+ 	await_reject_actions_1_0
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_LOCAL_BUSY_DETECTED event
+  */
+ static conn_action_t await_rejct_actions_1[] = {
+ 	conn_ac_send_rnr_xxx_x_set_0,
+ 	conn_ac_set_data_flag_2,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_1 = {
+ 	conn_ev_local_busy_detected,
+ 	CONN_STATE_AWAIT_BUSY,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t await_rejct_actions_2a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_2a = {
+ 	conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_2a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event
+  */
+ static conn_action_t await_rejct_actions_2b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_2b = {
+ 	conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_2b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t await_rejct_actions_3[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_3 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_4[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_stop_rej_timer,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_resend_i_xxx_x_set_0_or_send_rr,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_4 = {
+ 	conn_ev_rx_i_rsp_fbit_set_1,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_5a[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	conn_ac_stop_rej_timer,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_5a = {
+ 	conn_ev_rx_i_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_5a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_5b[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_rr_xxx_x_set_0,
+ 	conn_ac_stop_rej_timer,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_5b = {
+ 	conn_ev_rx_i_cmd_pbit_set_0,     CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,             await_rejct_actions_5b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_6[] = {
+ 	conn_ac_increment_vr_by_1,
+ 	conn_ac_data_indication,
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_stop_rej_timer,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_6 = {
+ 	conn_ev_rx_i_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_6
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_7a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_7a = {
+ 	conn_ev_rx_rr_rsp_fbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_7a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_7b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_7b = {
+ 	conn_ev_rx_rej_rsp_fbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_7b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event
+  */
+ static conn_action_t await_rejct_actions_7c[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_resend_i_xxx_x_set_0,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_7c = {
+ 	conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_7c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_8a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_8a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_8a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_8b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_8b = {
+ 	conn_ev_rx_rr_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_8b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_8c[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_8c = {
+ 	conn_ev_rx_rej_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_8c
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_8d[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_8d = {
+ 	conn_ev_rx_rej_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_8d
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_9a[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_9a = {
+ 	conn_ev_rx_rr_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_9a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_REJ_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_9b[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_clear_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_9b = {
+ 	conn_ev_rx_rej_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_9b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_10[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_10 = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_1,
+ 	CONN_STATE_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_10
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_11a[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_11a = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_0,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_11a
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_RSP_Fbit_SET_0 event
+  */
+ static conn_action_t await_rejct_actions_11b[] = {
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_11b = {
+ 	conn_ev_rx_rnr_rsp_fbit_set_0,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_11b
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_RNR_CMD_Pbit_SET_1 event
+  */
+ static conn_action_t await_rejct_actions_12[] = {
+ 	conn_ac_send_rr_rsp_f_set_1,
+ 	conn_ac_update_nr_received,
+ 	conn_ac_update_vs,
+ 	conn_ac_set_remote_busy,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_12 = {
+ 	conn_ev_rx_rnr_cmd_pbit_set_1,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	NO_EVENT_QUALIFIERS,
+ 	await_rejct_actions_12
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_P_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t await_rejct_ev_qfyrs_13[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t await_rejct_actions_13[] = {
+ 	conn_ac_send_rej_cmd_p_set_1,
+ 	conn_ac_stop_p_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t await_rejct_state_transition_13 = {
+ 	conn_ev_p_timer_expired,
+ 	CONN_STATE_AWAIT_REJECT,
+ 	await_rejct_ev_qfyrs_13,
+ 	await_rejct_actions_13
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *await_rejct_state_transitions[] = {
+ 	&await_reject_state_transition_1_0,
+ 	&common_state_transition_1,          // requests
+ 	&common_state_transition_2,
+ 	&common_state_transition_n,
+ 	&await_rejct_state_transition_1,     // local busy
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,          // Initiate PF cycle
+ 	&await_rejct_state_transition_13,    // timers
+ 	&common_state_transition_11a,
+ 	&common_state_transition_11b,
+ 	&common_state_transition_11c,
+ 	&common_state_transition_11d,
+ 	&common_state_transition_n,
+ 	&await_rejct_state_transition_2a,    // receive frames
+ 	&await_rejct_state_transition_2b,
+ 	&await_rejct_state_transition_3,
+ 	&await_rejct_state_transition_4,
+ 	&await_rejct_state_transition_5a,
+ 	&await_rejct_state_transition_5b,
+ 	&await_rejct_state_transition_6,
+ 	&await_rejct_state_transition_7a,
+ 	&await_rejct_state_transition_7b,
+ 	&await_rejct_state_transition_7c,
+ 	&await_rejct_state_transition_8a,
+ 	&await_rejct_state_transition_8b,
+ 	&await_rejct_state_transition_8c,
+ 	&await_rejct_state_transition_8d,
+ 	&await_rejct_state_transition_9a,
+ 	&await_rejct_state_transition_9b,
+ 	&await_rejct_state_transition_10,
+ 	&await_rejct_state_transition_11a,
+ 	&await_rejct_state_transition_11b,
+ 	&await_rejct_state_transition_12,
+ 	&common_state_transition_3,
+ 	&common_state_transition_4,
+ 	&common_state_transition_5,
+ 	&common_state_transition_6,
+ 	&common_state_transition_7a,
+ 	&common_state_transition_7b,
+ 	&common_state_transition_8a,
+ 	&common_state_transition_8b,
+ 	&common_state_transition_8c,
+ 	&common_state_transition_9,
+ 	// &common_state_transition_10,
+ 	&common_state_transition_n
+ };
+ 
+ /* -------------------- CONN_STATE_D_CONN transitions -------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_RX_SABME_CMD_Pbit_SET_X event,cause_flag = 1
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_1[] = {
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_conflict,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_1[] = {
+ 	conn_ac_send_dm_rsp_f_set_p,
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_disconnect_confirm,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_1 = {
+ 	conn_ev_rx_sabme_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_1,
+ 	d_conn_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_SABME_CMD_Pbit_SET_X event,cause_flag = 0
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_1_1[] = {
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_conflict,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_1_1[] = {
+ 	conn_ac_send_dm_rsp_f_set_p,
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_1_1 = {
+ 	conn_ev_rx_sabme_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_1_1,
+ 	d_conn_actions_1_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_UA_RSP_Fbit_SET_X event,cause_flag = 1
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_2[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_disconnect,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_2[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_disconnect_confirm,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_2 = {
+ 	conn_ev_rx_ua_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_2,
+ 	d_conn_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_UA_RSP_Fbit_SET_X event,cause_flag = 0
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_2_1[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_disconnect,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_2_1[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_2_1 = {
+ 	conn_ev_rx_ua_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_2_1,
+ 	d_conn_actions_2_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DISC_CMD_Pbit_SET_X event
+  */
+ static conn_action_t d_conn_actions_3[] = {
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_3 = {
+ 	conn_ev_rx_disc_cmd_pbit_set_x,
+ 	CONN_STATE_D_CONN,
+ 	NO_EVENT_QUALIFIERS,
+ 	d_conn_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DM_RSP_Fbit_SET_X event,cause_flag = 1
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_4[] = {
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_disconnect,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_4[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_disconnect_confirm,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_4 = {
+ 	conn_ev_rx_dm_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_4,
+ 	d_conn_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DM_RSP_Fbit_SET_X event,cause_flag = 0
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_4_1[] = {
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_disconnect,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_4_1[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_4_1 = {
+ 	conn_ev_rx_dm_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_4_1,
+ 	d_conn_actions_4_1
+ };
+ 
+ /*
+  * State transition for
+  * CONN_EV_DATA_CONN_REQUEST event
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_5[] = {
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_5[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_5 = {
+ 	conn_ev_data_request, CONN_STATE_D_CONN,
+ 	d_conn_ev_qfyrs_5, d_conn_actions_5
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_6[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_6[] = {
+ 	conn_ac_send_disc_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_6 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_D_CONN,
+ 	d_conn_ev_qfyrs_6,
+ 	d_conn_actions_6
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event,cause_flag = 1
+  */
+ static conn_event_qfyr_t d_conn_ev_qfyrs_7[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_failed,
+ 	NULL
+ };
+ 
+ static conn_action_t d_conn_actions_7[] = {
+ 	conn_ac_disconnect_confirm,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_7 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_7,
+ 	d_conn_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event, cause_flag = 0
+  */
+ static conn_event_qfyr_t   d_conn_ev_qfyrs_8[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2, 	
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_failed,
+ 	NULL
+ };
+ 
+ static conn_action_t       d_conn_actions_8[] = {
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t d_conn_state_transition_8 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_ADM,
+ 	d_conn_ev_qfyrs_8,
+ 	d_conn_actions_8
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t * d_conn_state_transitions[] = {
+ 	&d_conn_state_transition_5,      // Request
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,      // Local busy
+ 	&common_state_transition_n,      // Initiate PF cycle
+ 	&d_conn_state_transition_6,      // Timer
+ 	&d_conn_state_transition_7,
+ 	&d_conn_state_transition_8,
+ 	&common_state_transition_n,
+ 	&d_conn_state_transition_1,      // Receive frame
+ 	&d_conn_state_transition_1_1,
+ 	&d_conn_state_transition_2,
+ 	&d_conn_state_transition_2_1,
+ 	&d_conn_state_transition_3,
+ 	&d_conn_state_transition_4,
+ 	&d_conn_state_transition_4_1,
+ 	&common_state_transition_n
+ };
+ 
+ /* -------------------- CONN_STATE_RESET transitions --------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_RX_SABME_CMD_Pbit_SET_X event
+  */
+ static conn_action_t reset_actions_1[] = {
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_set_s_flag_1,
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_1 = {
+ 	conn_ev_rx_sabme_cmd_pbit_set_x,
+ 	CONN_STATE_RESET,
+ 	NO_EVENT_QUALIFIERS,
+ 	reset_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_UA_RSP_Fbit_SET_X event,cause_flag = 1
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_2[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_connect,
+ 	NULL
+ };
+ 
+ static conn_action_t reset_actions_2[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_reset_confirm,
+ 	conn_ac_set_remote_busy_0,
+ 	conn_reset,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_2 = {
+ 	conn_ev_rx_ua_rsp_fbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	reset_ev_qfyrs_2,
+ 	reset_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_UA_RSP_Fbit_SET_X event, cause_flag = 0
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_2_1[] = {
+ 	conn_ev_qlfy_p_flag_eq_f,
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_reset_done,
+ 	NULL
+ };
+ 
+ static conn_action_t reset_actions_2_1[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_update_p_flag,
+ 	conn_ac_reset_confirm,
+ 	conn_ac_set_remote_busy_0,
+ 	conn_reset,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_2_1 = {
+ 	conn_ev_rx_ua_rsp_fbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	reset_ev_qfyrs_2_1,
+ 	reset_actions_2_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_3[] = {
+ 	conn_ev_qlfy_s_flag_eq_1,
+ 	conn_ev_qlfy_set_status_reset_done,
+ 	NULL
+ };
+ 
+ static conn_action_t reset_actions_3[] = {
+ 	conn_ac_set_p_flag_0,
+ 	conn_ac_set_remote_busy_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_3 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_NORMAL,
+ 	reset_ev_qfyrs_3,
+ 	reset_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DISC_CMD_Pbit_SET_X event, cause_flag = 1
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_4[] = {
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_disconnect,
+ 	NULL
+ };
+ static conn_action_t reset_actions_4[] = {
+ 	conn_ac_send_dm_rsp_f_set_p,
+ 	conn_ac_disconnect_indication,
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_4 = {
+ 	conn_ev_rx_disc_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	reset_ev_qfyrs_4,
+ 	reset_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DISC_CMD_Pbit_SET_X event, cause_flag = 0
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_4_1[] = {
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t reset_actions_4_1[] = {
+ 	conn_ac_send_dm_rsp_f_set_p,
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_4_1 = {
+ 	conn_ev_rx_disc_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	reset_ev_qfyrs_4_1,
+ 	reset_actions_4_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DM_RSP_Fbit_SET_X event, cause_flag = 1
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_5[] = {
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_disconnect,
+  	NULL
+ };
+ 
+ static conn_action_t reset_actions_5[] = {
+ 	conn_ac_disconnect_indication,
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_5 = {
+ 	conn_ev_rx_dm_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	reset_ev_qfyrs_5,
+ 	reset_actions_5
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DM_RSP_Fbit_SET_X event, cause_flag = 0
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_5_1[] = {
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t reset_actions_5_1[] = {
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_5_1 = {
+ 	conn_ev_rx_dm_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	reset_ev_qfyrs_5_1,
+ 	reset_actions_5_1
+ };
+ 
+ /*
+  * State transitions for
+  * DATA_CONN_REQUEST event
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_6[] = {
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t reset_actions_6[] = {
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_6 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_RESET,
+ 	reset_ev_qfyrs_6,
+ 	reset_actions_6
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_7[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	conn_ev_qlfy_s_flag_eq_0,
+ 	NULL
+ };
+ 
+ static conn_action_t reset_actions_7[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_7 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_RESET,
+ 	reset_ev_qfyrs_7,
+ 	reset_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_8[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	conn_ev_qlfy_s_flag_eq_0,
+ 	conn_ev_qlfy_cause_flag_eq_1,
+ 	conn_ev_qlfy_set_status_failed,
+ 	NULL
+ };
+ static conn_action_t reset_actions_8[] = {
+ 	conn_ac_disconnect_indication,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_8 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_ADM,
+ 	reset_ev_qfyrs_8,
+ 	reset_actions_8
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t reset_ev_qfyrs_8_1[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	conn_ev_qlfy_s_flag_eq_0,
+ 	conn_ev_qlfy_cause_flag_eq_0,
+ 	conn_ev_qlfy_set_status_failed,
+ 	NULL
+ };
+ static conn_action_t reset_actions_8_1[] = {
+ 	conn_ac_disconnect_indication,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t reset_state_transition_8_1 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_ADM,
+ 	reset_ev_qfyrs_8_1,
+ 	reset_actions_8_1
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *reset_state_transitions[] = {
+ 	&reset_state_transition_6,       // Request
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,      // Local busy
+ 	&common_state_transition_n,      // Initiate PF cycle
+ 	&reset_state_transition_3,       // Timer
+ 	&reset_state_transition_7,
+ 	&reset_state_transition_8,
+ 	&reset_state_transition_8_1,
+ 	&common_state_transition_n,
+ 	&reset_state_transition_1,       // Receive frame
+ 	&reset_state_transition_2,
+ 	&reset_state_transition_2_1,
+ 	&reset_state_transition_4,
+ 	&reset_state_transition_4_1,
+ 	&reset_state_transition_5,
+ 	&reset_state_transition_5_1,
+ 	&common_state_transition_n
+ };
+ 
+ /* -------------------- CONN_STATE_ERROR transitions --------------------- */
+ /*
+  * State transitions for
+  * CONN_EV_RX_SABME_CMD_Pbit_SET_X event
+  */
+ static conn_action_t error_actions_1[] = {
+ 	conn_ac_set_vs_0,
+ 	conn_ac_set_vr_0,
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	conn_ac_reset_indication,
+ 	conn_ac_set_p_flag_0,
+ 	conn_ac_set_remote_busy_0,
+ 	conn_ac_stop_ack_timer,
+ 	conn_reset,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_1 = {
+ 	conn_ev_rx_sabme_cmd_pbit_set_x,
+ 	CONN_STATE_NORMAL,
+ 	NO_EVENT_QUALIFIERS,
+ 	error_actions_1
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DISC_CMD_Pbit_SET_X event
+  */
+ static conn_action_t error_actions_2[] = {
+ 	conn_ac_send_ua_rsp_f_set_p,
+ 	conn_ac_disconnect_indication,
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_2 = {
+ 	conn_ev_rx_disc_cmd_pbit_set_x,
+ 	CONN_STATE_ADM,
+ 	NO_EVENT_QUALIFIERS,
+ 	error_actions_2
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_DM_RSP_Fbit_SET_X event
+  */
+ static conn_action_t error_actions_3[] = {
+ 	conn_ac_disconnect_indication,
+ 	conn_ac_stop_ack_timer,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_3 = {
+ 	conn_ev_rx_dm_rsp_fbit_set_x,
+ 	CONN_STATE_ADM,
+ 	NO_EVENT_QUALIFIERS,
+ 	error_actions_3
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_FRMR_RSP_Fbit_SET_X event
+  */
+ static conn_action_t error_actions_4[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_4 = {
+ 	conn_ev_rx_frmr_rsp_fbit_set_x,
+ 	CONN_STATE_RESET,
+ 	NO_EVENT_QUALIFIERS,
+ 	error_actions_4
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_XXX_CMD_Pbit_SET_X event
+  */
+ static conn_action_t error_actions_5[] = {
+ 	conn_ac_resend_frmr_rsp_f_set_p,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_5 = {
+ 	conn_ev_rx_xxx_cmd_pbit_set_x,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	error_actions_5
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_RX_XXX_RSP_Fbit_SET_X event
+  */
+ static conn_state_transition_t error_state_transition_6 = {
+ 	conn_ev_rx_xxx_rsp_fbit_set_x,
+ 	CONN_STATE_ERROR,
+ 	NO_EVENT_QUALIFIERS,
+ 	NO_TRANSITION_ACTIONS
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t error_ev_qfyrs_7[] = {
+ 	conn_ev_qlfy_retry_count_lt_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t       error_actions_7[] = {
+ 	conn_ac_resend_frmr_rsp_f_set_0,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_increment_retry_count_by_1,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_7 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_ERROR,
+ 	error_ev_qfyrs_7,
+ 	error_actions_7
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_ACK_TIMER_EXPIRED event
+  */
+ static conn_event_qfyr_t error_ev_qfyrs_8[] = {
+ 	conn_ev_qlfy_retry_count_gte_n2,
+ 	NULL
+ };
+ 
+ static conn_action_t error_actions_8[] = {
+ 	conn_ac_send_sabme_cmd_p_set_x,
+ 	conn_ac_set_s_flag_0,
+ 	conn_ac_start_ack_timer,
+ 	conn_ac_set_retry_count_0,
+ 	conn_ac_set_cause_flag_0,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_8 = {
+ 	conn_ev_ack_timer_expired,
+ 	CONN_STATE_RESET,
+ 	error_ev_qfyrs_8,
+ 	error_actions_8
+ };
+ 
+ /*
+  * State transitions for
+  * CONN_EV_DATA_CONN_REQUEST event
+  */
+ static conn_event_qfyr_t error_ev_qfyrs_9[] = {
+ 	conn_ev_qlfy_set_status_refuse,
+ 	NULL
+ };
+ 
+ static conn_action_t error_actions_9[] = {
+    NULL
+ };
+ 
+ static conn_state_transition_t error_state_transition_9 = {
+ 	conn_ev_data_request,
+ 	CONN_STATE_ERROR,
+ 	error_ev_qfyrs_9,
+ 	error_actions_9
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *error_state_transitions[] = {
+ 	&error_state_transition_9,       // Request
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,      // Local busy
+ 	&common_state_transition_n,      // Initiate PF cycle
+ 	&error_state_transition_7,       // Timer
+ 	&error_state_transition_8,
+ 	&common_state_transition_n,
+ 	&error_state_transition_1,       // Receive frame
+ 	&error_state_transition_2,
+ 	&error_state_transition_3,
+ 	&error_state_transition_4,
+ 	&error_state_transition_5,
+ 	&error_state_transition_6,
+ 	&common_state_transition_n
+ };
+ 
+ /* ------------------- CONN_STATE_TEMP transitions ----------------- */
+ /*
+  * State transitions for
+  * CONN_EV_DISCONNECT_REQUEST event
+  */
+ static conn_action_t temp_actions_1[] = {
+ 	conn_ac_stop_all_timers,
+ 	conn_ac_send_disc_cmd_p_set_x,
+ 	conn_disconnect,
+ 	NULL
+ };
+ 
+ static conn_state_transition_t temp_state_transition_1 = {
+ 	conn_ev_disconnect_request,
+ 	CONN_STATE_ADM,
+ 	NO_EVENT_QUALIFIERS,
+ 	temp_actions_1
+ };
+ 
+ /*
+  * Array of pointers;
+  * one to each transition
+  */
+ static conn_state_transition_t *temp_state_transitions[] = {
+ 	&temp_state_transition_1,        /* requests */
+ 	&common_state_transition_n,
+ 	&common_state_transition_n,      /* local busy */
+ 	&common_state_transition_n,      /* init_pf_cycle */
+ 	&common_state_transition_n,      /* timer */
+ 	&common_state_transition_n       /* recieve */
+ };
+ 
+ /* Connection State Transition Table */
+ conn_state_t Connection_state_table[] = {
+ 	{ CONN_STATE_ADM,	   adm_state_transitions,        "adm" },
+ 	{ CONN_STATE_SETUP,	   setup_state_transitions,      "setup" },
+ 	{ CONN_STATE_NORMAL,	   normal_state_transitions,     "normal" },
+ 	{ CONN_STATE_BUSY,	   busy_state_transitions,       "busy" },
+ 	{ CONN_STATE_REJECT,	   reject_state_transitions,     "reject" },
+ 	{ CONN_STATE_AWAIT,	   await_state_transitions,      "await" },
+ 	{ CONN_STATE_AWAIT_BUSY,   await_busy_state_transitions, "await_busy" },
+ 	{ CONN_STATE_AWAIT_REJECT, await_rejct_state_transitions, "await_rej" },
+ 	{ CONN_STATE_D_CONN,	   d_conn_state_transitions,     "d_conn" },
+ 	{ CONN_STATE_RESET,	   reset_state_transitions,      "reset" },
+ 	{ CONN_STATE_ERROR,	   error_state_transitions,      "error" },
+ 	{ CONN_STATE_TEMP,	   temp_state_transitions,       "temp" }
+ };
Index: kernel-acme/net/8022llc/llc_cmd_rsp.c
diff -c /dev/null kernel-acme/net/8022llc/llc_cmd_rsp.c:1.1.4.4
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_cmd_rsp.c	Mon Aug 20 22:19:57 2001
***************
*** 0 ****
--- 1,394 ----
+ /*
+  * llc_cmd_rsp.c - This module includes llc commands and responses
+  * 		   implementation.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netdevice.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_c_ac.h>
+ #include <net/llc_c_st.h>
+ #include <net/llc_pdu.h>
+ #include <net/llc_mac.h>
+ 
+ u16 conn_ac_send_disc_c(struct p8022_connection *conn,
+ 			struct conn_state_event *event, int p_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	skb->data = skb->tail = skb->head;
+ 	skb->len = 0;
+ 	skb_reserve(skb, 50);
+ 	/* initialize PDU header for DISC command PDU */
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_disc_cmd(skb, p_bit);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_dm_r(struct p8022_connection *conn,
+ 		      struct conn_state_event *event, int f_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_dm_rsp(skb, f_bit);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_rej_c(struct p8022_connection *conn,
+ 		       struct conn_state_event *event, int p_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_rej_cmd(skb, p_bit, conn->vR);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_sabme_c(struct p8022_connection *conn,
+ 			 struct conn_state_event *event, int p_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_sabme_cmd(skb, p_bit);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_ua_r(struct p8022_connection *conn,
+ 		      struct conn_state_event *event, int f_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	skb->data = skb->tail = skb->head;
+ 	skb->len = 0;
+ 	skb_reserve(skb, 50);
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_ua_rsp(skb, f_bit);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_rr_c(struct p8022_connection *conn,
+ 		      struct conn_state_event *event, int p_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_rr_cmd(skb, p_bit, conn->vR);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_rr_r(struct p8022_connection *conn,
+ 		      struct conn_state_event *event, int f_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_rr_rsp(skb, f_bit, conn->vR);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_rej_r(struct p8022_connection *conn,
+ 		       struct conn_state_event *event, int f_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_rej_rsp(skb, f_bit, conn->vR);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_frmr_r(struct p8022_connection *conn,
+ 			struct conn_state_event *event, int f_bit)
+ {
+ 	pdu_sn_t *rx_pdu = NULL;
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_frmr_rsp(skb, rx_pdu, f_bit, conn->vS, conn->vR, 0);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_rnr_c(struct p8022_connection *conn,
+ 		       struct conn_state_event *event, int p_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_rnr_cmd(skb, p_bit, conn->vR);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_rnr_r(struct p8022_connection *conn,
+ 		       struct conn_state_event *event, int f_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (!skb)
+ 		goto out;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_S, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto err;
+ 	rc = pdu_init_as_rnr_rsp(skb, f_bit, conn->vR);
+ 	if (rc)
+ 		goto err;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto err;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_i_c(struct p8022_connection *conn,
+ 		     struct conn_state_event *event, int p_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = alloc_skb(128, GFP_ATOMIC);
+ 
+ 	if (!skb)
+ 		goto out;
+ 	skb_reserve(skb, 50);
+ 	skb->nh.raw = skb->h.raw = skb->data;
+ 	skb->protocol = htons(ETH_P_802_2);
+ 	skb->dev = dev_base->next;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_I,
+ 			     sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto out_skb;
+ 	rc = pdu_init_as_i_cmd(skb, p_bit, conn->vS, conn->vR);
+ 	if (rc)
+ 		goto out_skb;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto out_skb;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ out_skb:
+ 	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ u16 conn_ac_send_i_r(struct p8022_connection *conn,
+ 		     struct conn_state_event *event, int f_bit)
+ {
+ 	struct p8022_sap *sap;
+ 	u16 rc = 1;
+ 	struct sk_buff *skb = alloc_skb(128, GFP_ATOMIC);
+ 
+ 	if (!skb)
+ 		goto out;
+ 	skb_reserve(skb, 50);
+ 	skb->nh.raw = skb->h.raw = skb->data;
+ 	skb->protocol = htons(ETH_P_802_2);
+ 	skb->dev = dev_base->next;
+ 	sap = conn->parent_sap;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_I, sap->local_dl_addr.lsap,
+ 			     conn->remote_dl_addr.lsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto out_skb;
+ 	rc = pdu_init_as_i_cmd(skb, f_bit, conn->vS, conn->vR);
+ 	if (rc)
+ 		goto out_skb;
+ 	rc = lan_hdrs_init(skb, sap->parent_station->mac_sa,
+ 			   conn->remote_dl_addr.mac);
+ 	if (rc)
+ 		goto out_skb;
+ 	rc = conn_send_pdu(conn, skb);
+ out:	return rc;
+ out_skb:
+ 	kfree_skb(skb);
+ 	goto out;
+ }
Index: kernel-acme/net/8022llc/llc_conn.c
diff -c /dev/null kernel-acme/net/8022llc/llc_conn.c:1.1.4.11
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_conn.c	Tue Aug 28 01:32:08 2001
***************
*** 0 ****
--- 1,622 ----
+ /*
+  * llc_conn.c - Driver routines for connection component.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netdevice.h>
+ #include <linux/interrupt.h>
+ #include <linux/init.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_c_ac.h>
+ #include <net/llc_c_st.h>
+ #include <net/llc_mac.h>
+ #include <net/llc_pdu.h>
+ #include <net/llc_s_ev.h>
+ 
+ static u16 conn_send_pdus(struct p8022_connection *conn);
+ static u16 conn_next_state(struct p8022_connection *conn,
+ 			   struct conn_state_event *event);
+ static u16 execute_conn_transition_actions(struct p8022_connection *conn,
+ 					   conn_state_transition_t *transition,
+ 					   struct conn_state_event *event);
+ static conn_state_transition_t *qualify_conn_event(struct p8022_connection *conn,
+ 						struct conn_state_event *event);
+ 
+ /* Offset table on connection states transition diagram */
+ u16 Offset_table[NBR_CONN_STATES][NBR_CONN_EV];
+ 
+ /*
+  * Function : conn_alloc_event
+  *
+  * Description :
+  *  this function allocates an event
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to connection that event must
+  *				    extract from it's
+  *  pool.
+  *  void **event : pointer to allocated event (output argument).
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ struct conn_state_event *conn_alloc_event(struct p8022_connection *conn)
+ {
+ 	struct conn_state_event *event = NULL;
+ 
+ 	/* verify connection is valid, active and open */
+ 	if (conn->state != CONN_OUT_OF_SVC) {
+ 		/* get event structure to build a station event */
+ 		event = kmalloc(sizeof(*event), GFP_ATOMIC);
+ 		if (event)
+ 			memset(event, 0, sizeof(*event));
+ 	}
+ 	return event;
+ }
+ 
+ /*
+  * Function : conn_send_event
+  *
+  * Description :
+  *  this function sends an event to connection state machine. after processing
+  *  event (executing it's actions and changing state), upper layer will be
+  *  indicated or confirmed, if needed.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to active connection.
+  *  void *event : pointer to occurred event.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ u16 conn_send_event(struct p8022_connection *conn,
+ 		    struct conn_state_event *event)
+ {
+ 	/* sending event to state machine */
+ 	int rc = conn_service(conn, event);
+ 	u8 flag = event->flag;
+ 	struct prim_if_block *ind_prim = event->ind_prim;
+ 	struct prim_if_block *cfm_prim = event->cfm_prim;
+ 
+ 	conn_free_event(conn, event);
+ 	if (!flag)   /* indicate or confirm required */
+ 		goto out;
+ 	if (ind_prim) /* indication required */
+ 		conn->parent_sap->indicate(ind_prim);
+ 	if (!cfm_prim)  /* confirmation required */
+ 		goto out;
+ 	/* data confirm has preconditions */
+ 	if (cfm_prim->primitive != P8022_DATA_PRIM)
+ 		conn->parent_sap->confirm(cfm_prim);
+ 	else if (!data_accept_state(conn->state)) {
+ 		/* in this state , we can send I pdu */
+ 		if (conn->data_ret_val && conn->busy)
+ 			conn->data_ret_val = -ERESTART;
+ 		else {
+ 			rc = conn->parent_sap->confirm(cfm_prim);
+ 			if (rc) /* confirmation didn't accept by upper layer */
+ 				conn->failed_data_req = 1;
+ 		}
+ 	} else
+ 		conn->failed_data_req = 1;
+ out:	return rc;
+ }
+ 
+ u16 conn_service(struct p8022_connection *conn, struct conn_state_event *event)
+ {
+ 	return conn_next_state(conn, event);
+ }
+ 
+ u16 conn_send_pdu(struct p8022_connection *conn, struct sk_buff *skb)
+ {
+ 	/* queue PDU to send to MAC layer */
+ 	skb_queue_tail(&conn->mac_pdu_q, skb);
+ 	conn_send_pdus(conn);
+ 	return 0;
+ }
+ 
+ /*
+  * Function : conn_rtn_pdu
+  *
+  * Description :
+  *  this function sends received data pdu to upper layer (by using indicate
+  *  function).
+  *  this function prepares service parameters ( prim and prim_data). calling
+  *  indication function will be done in conn_send_event.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to active connection.
+  *  struct sk_buff *skb : received data frame.
+  *  void *event : pointer to occurred event.
+  *
+  * Returns :
+  *  0
+  */
+ u16 conn_rtn_pdu(struct p8022_connection *conn, struct sk_buff *skb,
+ 		 struct conn_state_event *event)
+ {
+ 	struct prim_if_block *prim = &Ind_prim;
+ 	prim_data_u *prim_data = Ind_prim.data;
+ 
+ 	prim_data->data.connection	= conn;
+ 	prim_data->data.priority	= 0;
+ 	prim_data->data.skb		= skb;
+ 	prim_data->data.link_no		= conn->link_no;
+ 	prim->data	= prim_data;
+ 	prim->primitive = P8022_DATA_PRIM;
+ 	prim->sap	= conn->parent_sap;
+ 	event->flag = 1;
+ 	/* saving prepared prim in event for future use in conn_send_event  */
+ 	event->ind_prim = prim;
+ 	return 0;
+ }
+ 
+ /*
+  * Function : conn_resend_i_pdu_as_cmd
+  *
+  * Description :
+  *  re-send all unacknowledged I PDUs, starting with the NR; send
+  *  first as command PDU with P bit equal first_p_bit; if more than one
+  *  send subsequent as command PDUs with P bit equal zero (0).
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to active connection.
+  *  nr : NR
+  *  first_p_bit : p_bit value of first pdu.
+  *
+  * Returns :
+  *  0
+  */
+ u16 conn_resend_i_pdu_as_cmd(struct p8022_connection *conn, u8 nr,
+ 			     u8 first_p_bit)
+ {
+ 	struct sk_buff *skb;
+ 	pdu_sn_t *pdu;
+ 	u16 nbr_unack_pdus;
+ 	u8 howmany_resend = 0;
+ 
+ 	conn_remove_acked_pdus(conn, nr, &nbr_unack_pdus);
+ 	if (!nbr_unack_pdus)
+ 		goto out;
+ 	/*
+ 	 * process unack PDUs only if unack queue is not empty; remove
+ 	 * appropriate PDUs, fix them up, and put them on mac_pdu_q.
+ 	 */
+ 	while ((skb = skb_dequeue(&conn->pdu_unack_q)) != NULL) {
+ 		pdu = (pdu_sn_t *)skb->nh.raw;
+ 		pdu_set_cmd_rsp(skb, LLC_PDU_CMD);
+ 		pdu_set_pf_bit(skb, first_p_bit);
+ 		skb_queue_tail(&conn->mac_pdu_q, skb);
+ 		first_p_bit = 0;
+ 		conn->vS = LLC_I_GET_NS(pdu);
+ 		howmany_resend++;
+ 	}
+ 	if (howmany_resend > 0)
+ 		conn->vS = (conn->vS + 1) % LLC_2_SEQ_NBR_MODULO;
+ 	/* any PDUs to re-send are queued up; start sending to MAC */
+ 	conn_send_pdus(conn);
+ out:   	return 0;
+ }
+ 
+ /*
+  * Function : conn_resend_i_pdu_as_rsp
+  *
+  * Description :
+  *  re-send all unacknowledged I PDUs, starting with the NR; send
+  *  first as response PDU with F bit equal first_f_bit; if more than one
+  *  send subsequent as response PDUs with F bit equal zero (0).
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to active connection.
+  *  nr : NR
+  *  first_f_bit : f_bit value of first pdu.
+  *
+  * Returns :
+  *  0
+  */
+ u16 conn_resend_i_pdu_as_rsp(struct p8022_connection *conn, u8 nr,
+ 			     u8 first_f_bit)
+ {
+ 	struct sk_buff *skb;
+ 	pdu_sn_t *pdu;
+ 	u16 nbr_unack_pdus;
+ 	u8 howmany_resend = 0;
+ 
+ 	conn_remove_acked_pdus(conn, nr, &nbr_unack_pdus);
+ 	if (!nbr_unack_pdus)
+ 		goto out;
+ 	/*
+ 	 * process unack PDUs only if unack queue is not empty; remove
+ 	 * appropriate PDUs, fix them up, and put them on mac_pdu_q
+ 	 */
+ 	while ((skb = skb_dequeue(&conn->pdu_unack_q)) != NULL) {
+ 		pdu = (pdu_sn_t *)skb->nh.raw;
+ 		pdu_set_cmd_rsp(skb, LLC_PDU_RSP);
+ 		pdu_set_pf_bit(skb, first_f_bit);
+ 		skb_queue_tail(&conn->mac_pdu_q, skb);
+ 		first_f_bit = 0;
+ 		conn->vS = LLC_I_GET_NS(pdu);
+ 		howmany_resend++;
+ 	}
+ 	if (howmany_resend > 0)
+ 		conn->vS = (conn->vS + 1) % LLC_2_SEQ_NBR_MODULO;
+ 	/* any PDUs to re-send are queued up; start sending to MAC */
+ 	conn_send_pdus(conn);
+ out:	return 0;
+ }
+ 
+ /*
+  * Function : conn_remove_acked_pdus
+  *
+  * Description :
+  *  removes acknowledged pdus from transmit queue (pdu_unack_q).
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to active connection.
+  *  nr : NR
+  *  how_many_unacked : size of pdu_unack_q after removing acked pdus.
+  *
+  * Returns :
+  *  number of pdus that removed from queue.
+  */
+ u16 conn_remove_acked_pdus(struct p8022_connection *conn, u8 nr,
+ 			   u16 *how_many_unacked)
+ {
+ 	int pdu_pos, i;
+ 	struct sk_buff *skb;
+ 	pdu_sn_t *pdu;
+ 	u16 nbr_acked = 0;
+ 	int q_len = skb_queue_len(&conn->pdu_unack_q);
+ 
+ 	if (!q_len)
+ 		goto out;
+ 	skb = skb_peek(&conn->pdu_unack_q);
+ 	pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+         /* finding position of last acked pdu in queue */
+ 	pdu_pos = ((int)LLC_2_SEQ_NBR_MODULO + (int)nr -
+ 			(int)LLC_I_GET_NS(pdu)) % LLC_2_SEQ_NBR_MODULO;
+ 
+ 	for (i = 0; i < pdu_pos && i < q_len; i++) {
+ 		skb = skb_dequeue(&conn->pdu_unack_q);
+ 		if (skb)
+ 			kfree_skb(skb);
+ 		nbr_acked++;
+ 	}
+ out:	*how_many_unacked = skb_queue_len(&conn->pdu_unack_q);
+ 	return nbr_acked;
+ }
+ 
+ /*
+  * Function : conn_send_pdus
+  *
+  * Description :
+  *  sends queued pdus to MAC layer for transmition.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to active connection.
+  *
+  * Returns :
+  *  0
+  */
+ static u16 conn_send_pdus(struct p8022_connection *conn)
+ {
+ 	struct sk_buff *skb;
+ 
+ 	while ((skb = skb_dequeue(&conn->mac_pdu_q)) != NULL) {
+ 		pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 		if (!LLC_PDU_TYPE_IS_I(pdu) &&
+ 		    !(skb->dev->flags & IFF_LOOPBACK))
+ 			skb_queue_tail(&conn->pdu_unack_q, skb);
+ 		mac_send_pdu(skb);
+ 		if (LLC_PDU_TYPE_IS_I(pdu) || (skb->dev->flags & IFF_LOOPBACK))
+ 			kfree_skb(skb);
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Function : conn_free_event
+  *
+  * Description :
+  *  free allocated event
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to active connection.
+  *  struct conn_state_event *event : freed event.
+  *
+  * Returns :
+  *  0
+  */
+ void conn_free_event(struct p8022_connection *conn,
+ 		     struct conn_state_event *event)
+ {
+ 	if (event->type == CONN_EV_TYPE_PDU) {
+ 		/* free the frame that binded to this event */
+ 		pdu_sn_t *pdu = (pdu_sn_t *)event->data.pdu.skb->nh.raw;
+ 
+ 		if (LLC_PDU_TYPE_IS_I(pdu) || !event->flag || !event->ind_prim)
+ 			kfree_skb(event->data.pdu.skb);
+ 	}
+ 	/* free event structure to free list of the same */
+ 	kfree(event);
+ }
+ 
+ /*
+  * Function : conn_next_state
+  *
+  * Description :
+  *  This function finds transition that matches with happened event, then
+  *  executes related actions and finally changes state of connection.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to connection.
+  *  struct conn_state_event *event : happened event.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static u16 conn_next_state(struct p8022_connection *conn,
+ 			   struct conn_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	conn_state_transition_t *transition;
+ 
+ 	if (conn->state > NBR_CONN_STATES)
+ 		goto out;
+ 	transition = qualify_conn_event(conn, event);
+ 	if (transition) {
+ 		rc = execute_conn_transition_actions(conn, transition, event);
+ 		if (!rc && transition->next_state != NO_STATE_CHANGE)
+ 			conn->state = transition->next_state;
+ 	} else
+ 		rc = 0;
+ out:	return rc;
+ }
+ 
+ /*
+  * Function : qualify_conn_event
+  *
+  * Description :
+  *  This function finds transition that matches with happened event.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to connection.
+  *  sap_state_event_t *event : happened event.
+  *
+  * Returns :
+  *  pointer to found transition : success.
+  *  NULL : failure.
+  */
+ static conn_state_transition_t *qualify_conn_event(struct p8022_connection *conn,
+ 						 struct conn_state_event *event)
+ {
+ 	conn_state_transition_t **next_transition;
+ 	conn_event_qfyr_t *next_qualifier;
+ 	conn_state_t *curr_state = &Connection_state_table[conn->state - 1];
+ 
+        /*
+    	* search thru events for this state until list exhausted or until
+     	* no more
+     	*/
+ 	for (next_transition = curr_state->transitions +
+ 		find_offset(conn->state - 1, event->type);
+ 	     (*next_transition)->event; next_transition++) {
+ 		if (!((*next_transition)->event)(conn, event)) {
+ 			/*
+ 			 * got POSSIBLE event match; the event may require
+ 			 * qualification based on the values of a number of
+ 			 * state flags; if all qualifications are met (i.e.,
+ 			 * if all qualifying functions return success, or 0,
+ 			 * then this is THE event we're looking for
+ 			 */
+ 			for (next_qualifier =
+ 					   (*next_transition)->event_qualifiers;
+ 			     next_qualifier && *next_qualifier &&
+ 				!(*next_qualifier)(conn, event);
+                              next_qualifier++);
+ 			if (!next_qualifier || !*next_qualifier)
+ 				/*
+ 				 * all qualifiers executed successfully; this is
+ 				 * our transition; return it so we can perform
+ 				 * the associated actions and change the state.
+ 				 */
+ 				return *next_transition;
+ 		}
+ 	}
+ 	return NULL;
+ }
+ 
+ /*
+  * Function : execute_conn_transition_actions
+  *
+  * Description :
+  *  This function executes actions that is related to happened event.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to connection.
+  *  conn_state_transition_t *transition : pointer to transition that it's
+  *  actions must be performed.
+  *  struct conn_state_event *event : happened event.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure of at least one action.
+  *
+  */
+ static u16 execute_conn_transition_actions(struct p8022_connection *conn,
+ 					   conn_state_transition_t *transition,
+ 					   struct conn_state_event *event)
+ {
+ 	u16 rc = 0;
+ 	conn_action_t *next_action;
+ 
+ 	for (next_action = transition->event_actions;
+ 	     next_action && *next_action; next_action++)
+ 		if ((*next_action)(conn, event))
+ 			rc = 1;
+ 	return rc;
+ }
+ 
+ /*
+  * Function : find_conn
+  *
+  * Description :
+  *  This function search connection list of the SAP and finds connection
+  *  based on remote MAC and SAP address.
+  *
+  * Parameters :
+  *  SAP_t *sap : pointer to SAP.
+  *  address_t *remote_addr : address of remote LLC (MAC+SAP).
+  *  void **conn_ptr : found connection.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : connection not found.
+  */
+ struct p8022_connection *find_conn(struct p8022_sap *sap,
+ 				   address_t *remote_addr)
+ {
+ 	struct p8022_connection *conn = NULL;
+ 	struct list_head *entry;
+ 
+ 	spin_lock_bh(&sap->connection_list.lock);
+ 	list_for_each(entry, &sap->connection_list.list) {
+ 		conn = list_entry(entry, struct p8022_connection, node);
+ 		if (!memcmp(conn->remote_dl_addr.mac, remote_addr->mac,
+ 			    MAC_ADDR_LEN))
+ 			break;
+ 	}
+ 	if (entry == &sap->connection_list.list) /* not found */
+ 		conn = NULL;
+ 	spin_unlock_bh(&sap->connection_list.lock);
+ 	return conn;
+ }
+ 
+ /*
+  * Function : data_accept_state
+  *
+  * Description :
+  *  This function designates that in this state we can send data or not.
+  *
+  * Parameters :
+  *  u8 state : state of connection.
+  *
+  * Returns :
+  *  0 : OK.
+  *  1 : No, we can't.
+  *
+  */
+ u8 data_accept_state(u8 state)
+ {
+ 	if (state != CONN_STATE_NORMAL && state != CONN_STATE_BUSY &&
+ 	    state != CONN_STATE_REJECT )
+ 		return 1; /* data_conn_refuse */
+ 	return 0;
+ }
+ 
+ /*
+  * Function : find_next_offset
+  *
+  * Description :
+  *  This function finds offset of next category of transitions in transition
+  *  table.
+  *
+  * Parameters :
+  *  conn_state_t *state : pointer to state table.
+  *  u16 offset : start offset.
+  *
+  * Returns :
+  *  start index of next category.
+  *
+  */
+ u16 find_next_offset(conn_state_t *state, u16 offset)
+ {
+ 	u16 cnt = 0;
+ 	conn_state_transition_t **next_transition;
+ 
+ 	for (next_transition = state->transitions + offset;
+ 	     (*next_transition)->event; next_transition++)
+ 		++cnt;
+ 	return cnt;
+ }
+ 
+ /*
+  * Function : build_offset_table
+  *
+  * Description :
+  *  This function fills offset table of connection state transition table
+  *  (Offset_table).
+  *
+  * Parameters :
+  *  none.
+  *
+  * Returns :
+  *  none.
+  */
+ void __init build_offset_table(void)
+ {
+ 	conn_state_t *curr_state;
+ 	u16 state, ev_type, next_offset;
+ 
+ 	memset(Offset_table, 0, sizeof(Offset_table));
+ 	for (state = 0; state < NBR_CONN_STATES; state++) {
+ 		curr_state = &Connection_state_table[state];
+ 		next_offset = 0;
+ 		for (ev_type = 0; ev_type < NBR_CONN_EV; ev_type++) {
+ 			Offset_table[state][ev_type] = next_offset;
+ 			next_offset += find_next_offset(curr_state,
+ 							next_offset) + 1;
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Function : find_offset
+  *
+  * Description :
+  *  This function finds start offset of desired category of transitions.
+  *
+  * Parameters :
+  *  u16 state : state of connection.
+  *  u16 event_type : type of happened event.
+  *
+  * Returns :
+  *  desired start offset.
+  */
+ u16 find_offset(u16 state, u16 event_type)
+ {
+ 	u16 rc = 0;
+ 	/* at this stage, Offset_table[..][2] is not important. it is for
+ 	 * init_pf_cycle and I don't know what is it. */
+ 	switch (event_type) {
+ 		case CONN_EV_TYPE_PRIM:
+ 			rc = Offset_table[state][0]; break;
+ 		case CONN_EV_TYPE_PDU:
+ 			rc = Offset_table[state][4]; break;
+ 		case CONN_EV_TYPE_SIMPLE:
+ 			rc = Offset_table[state][1]; break;
+ 		case CONN_EV_TYPE_P_TIMER:
+ 		case CONN_EV_TYPE_ACK_TIMER:
+ 		case CONN_EV_TYPE_REJ_TIMER:
+ 		case CONN_EV_TYPE_BUSY_TIMER:
+ 			rc = Offset_table[state][3]; break;
+ 	}
+ 	return rc;
+ }
Index: kernel-acme/net/8022llc/llc_evnt.c
diff -c /dev/null kernel-acme/net/8022llc/llc_evnt.c:1.1.4.3
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_evnt.c	Fri Aug 24 03:05:03 2001
***************
*** 0 ****
--- 1,114 ----
+ /*
+  * llc_evnt.c - LLC station component event match functions
+  * Description :
+  *   Functions in this module are implementation of station component events.
+  *   Details of events can be found in IEEE-802.2 standard document.
+  *   All functions have one station and one event as input argument. All of
+  *   them return 0 On success and 1 otherwise.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/skbuff.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_evnt.h>
+ #include <net/llc_pdu.h>
+ #include <linux/skbuff.h>
+ 
+ u16 stat_ev_enable_with_dup_addr_check(struct p8022_station *station,
+ 				       struct station_state_event *event)
+ {
+ 	return event->type == STATION_EV_TYPE_SIMPLE &&
+ 	       event->data.a.event ==
+ 	       			STATION_EV_ENABLE_WITH_DUP_ADDR_CHECK ? 0 : 1;
+ }
+ 
+ u16 stat_ev_enable_without_dup_addr_check(struct p8022_station *station,
+ 					  struct station_state_event *event)
+ {
+ 	return event->type == STATION_EV_TYPE_SIMPLE &&
+ 	       event->data.a.event ==
+ 			STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK ? 0 : 1;
+ }
+ 
+ u16 stat_ev_ack_timer_expired_lt_retry_count_max_retry(struct p8022_station *station,
+ 					      struct station_state_event *event)
+ {
+ 	return event->type == STATION_EV_TYPE_ACK_TIMER &&
+ 	       station->retry_count < station->maximum_retry ? 0 : 1;
+ }
+ 
+ u16 stat_ev_ack_timer_expired_eq_retry_count_max_retry(struct p8022_station *station,
+ 					      struct station_state_event *event)
+ {
+ 	return event->type == STATION_EV_TYPE_ACK_TIMER &&
+ 		station->retry_count == station->maximum_retry ? 0 : 1;
+ }
+ 
+ u16 stat_ev_rx_null_dsap_xid_c(struct p8022_station *station,
+ 			       struct station_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == STATION_EV_TYPE_PDU &&
+ 	       !LLC_PDU_IS_CMD(pdu) &&			/* command PDU */
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+ 	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_XID &&
+ 	       !pdu->dsap ? 0 : 1;			/* NULL DSAP value */
+ }
+ 
+ u16 stat_ev_rx_null_dsap_0_xid_r_xid_r_count_eq(struct p8022_station *station,
+ 					      struct station_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == STATION_EV_TYPE_PDU &&
+ 	       !LLC_PDU_IS_RSP(pdu) &&			/* response PDU */
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+ 	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID &&
+ 	       !pdu->dsap &&				/* NULL DSAP value */
+ 	       !station->xid_r_count ? 0 : 1;
+ }
+ 
+ u16 stat_ev_rx_null_dsap_1_xid_r_xid_r_count_eq(struct p8022_station *station,
+ 					      struct station_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == STATION_EV_TYPE_PDU &&
+ 	       !LLC_PDU_IS_RSP(pdu) &&			/* response PDU */
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+ 	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID &&
+ 	       !pdu->dsap &&				/* NULL DSAP value */
+ 	       station->xid_r_count == 1 ? 0 : 1;
+ }
+ 
+ u16 stat_ev_rx_null_dsap_test_c(struct p8022_station *station,
+ 			        struct station_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == STATION_EV_TYPE_PDU &&
+ 	       !LLC_PDU_IS_CMD(pdu) &&			/* command PDU */
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+ 	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_TEST &&
+ 	       !pdu->dsap ? 0 : 1;			/* NULL DSAP */
+ }
+ 
+ u16 stat_ev_disable_request(struct p8022_station *station,
+ 			    struct station_state_event *event)
+ {
+ 	return event->type == STATION_EV_TYPE_PRIM &&
+ 	       event->data.prim.prim == P8022_DISABLE_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ }
Index: kernel-acme/net/8022llc/llc_if.c
diff -c /dev/null kernel-acme/net/8022llc/llc_if.c:1.1.4.15
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_if.c	Thu Aug 30 19:42:35 2001
***************
*** 0 ****
--- 1,692 ----
+ /*
+  * llc_if.c - Defines LLC interface to upper layer
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/config.h>
+ #include <linux/module.h>
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <asm/errno.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_s_ev.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_c_ac.h>
+ #include <net/llc_c_st.h>
+ #include <net/llc_main.h>
+ #include <net/llc_mac.h>
+ 
+ static int sap_request(struct prim_if_block *prim);
+ static int unitdata_req_handler(struct prim_if_block *prim);
+ static int test_req_handler(struct prim_if_block *prim);
+ static int xid_req_handler(struct prim_if_block *prim);
+ static int data_req_handler(struct prim_if_block *prim);
+ static int connect_req_handler(struct prim_if_block *prim);
+ static int disconnect_req_handler(struct prim_if_block *prim);
+ static int reset_req_handler(struct prim_if_block *prim);
+ static int flowcontrol_req_handler(struct prim_if_block *prim);
+ static int sap_response(struct prim_if_block *prim);
+ static int connect_rsp_handler(struct prim_if_block *prim);
+ static int reset_rsp_handler(struct prim_if_block *prim);
+ static int no_rsp_handler(struct prim_if_block *prim);
+ 
+ static void process_rxframes_events(struct p8022_connection *conn);
+ 
+ extern void P8022_register_sap(unsigned char sap,
+ 			       int (*rcvfunc)(struct sk_buff *,
+ 					      struct net_device *,
+ 					      struct packet_type *));
+ extern void P8022_unregister_sap(unsigned char sap);
+ 
+ /* table of request handler functions */
+ primitive_call_t Request_primitives[P8022_NBR_PRIMITIVES] = {
+ 	unitdata_req_handler,           /* order of functions must not change */
+ 	connect_req_handler,
+ 	data_req_handler,
+ 	disconnect_req_handler,
+ 	reset_req_handler,
+ 	flowcontrol_req_handler,
+ 	NULL,
+ 	xid_req_handler,
+ 	test_req_handler
+ };
+ 
+ /* table of response handler functions */
+ primitive_call_t Response_primitives[P8022_NBR_PRIMITIVES] = {
+ 	no_rsp_handler,     /* order of functions must not change */
+ 	connect_rsp_handler,
+ 	no_rsp_handler,
+ 	no_rsp_handler,
+ 	reset_rsp_handler,
+ 	no_rsp_handler
+ };
+ 
+ /*
+  * Function : inc_conn_busy
+  *
+  * Description :
+  *  this function increments busy field of connection. this is a mechanism for
+  *  locking connection structure and protecting this from interrupt side
+  *  effects.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to connection that must be locked.
+  *
+  * Returns :
+  *  none.
+  */
+ inline void inc_conn_busy(struct p8022_connection *conn)
+ {
+ 	conn->busy++;
+ 	barrier();
+ }
+ 
+ /*
+  * Function : dec_conn_busy
+  *
+  * Description :
+  *  this function decrements busy field of connection. this is a mechanism for
+  *  unlocking connection structure.
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to connection that must be unlocked.
+  *
+  * Returns :
+  *  none.
+  */
+ inline void dec_conn_busy(struct p8022_connection *conn)
+ {
+ 	barrier();
+ 	conn->busy--;
+ }
+ 
+ /*
+  * Function : llc_sap_open
+  *
+  * Description :
+  *  this function is a interface function to upper layer. each one who wants to
+  *  get a SAP (for example NetBEUI) should call this function.
+  *
+  * Parameters :
+  *   primitive_call_t nw_indicate : pointer to indicate function of upper
+  *   layer.
+  *   primitive_call_t nw_confirm : pointer to confirm function of upper
+  *   layer.
+  *   u8 local_sap : SAP number.
+  *   u32 *sap : pointer to allocated SAP (output argument).
+  *
+  * Returns :
+  *   0 : success.
+  *   1 : failure.
+  */
+ struct p8022_sap *llc_sap_open(primitive_call_t nw_indicate,
+ 			       primitive_call_t nw_confirm, u8 local_sap)
+ {
+ 	/* verify this SAP is not already open; if so, return error */
+ 	struct p8022_sap *sap;
+ 
+ 	MOD_INC_USE_COUNT;
+ 	sap = llc_sap_find(local_sap);
+ 	if (sap) { /* SAP already exists */
+ 		sap = NULL;
+ 		goto err;
+ 	}
+ 	/* sap requested does not yet exist */
+ 	sap = llc_sap_alloc();
+ 	if (!sap)
+ 		goto err;
+ 	/* allocated a SAP; initialize it and clear out its memory pool */
+ 	sap->local_dl_addr.lsap = local_sap;
+ 	sap->request = sap_request;
+ 	sap->response = sap_response;
+ 	sap->indicate = nw_indicate;
+ 	sap->confirm = nw_confirm;
+ 	sap->parent_station = station_get();
+ 	/* initialized SAP; add it to list of SAPs this station manages */
+ 	llc_sap_save(sap);
+ 	P8022_register_sap(local_sap, mac_indicate);
+ out:	return sap;
+ err:	MOD_DEC_USE_COUNT;
+ 	goto out;
+ }
+ 
+ /*
+  * Function : llc_sap_close
+  *
+  * Description :
+  *  this function is a interface function to upper layer. each one who wants to
+  *  close an open SAP (for example NetBEUI) should call this function.
+  *
+  * Parameters :
+  *   struct p8022_sap *sap : pointer to free SAP.
+  *
+  * Returns :
+  *   None
+  */
+ void llc_sap_close(struct p8022_sap *sap)
+ {
+ 	P8022_unregister_sap(sap->local_dl_addr.lsap);
+ 	llc_free_sap(sap);
+ 	MOD_DEC_USE_COUNT;
+ }
+ 
+ /*
+  * Function : sap_request
+  *
+  * Description :
+  *  this function is a interface function to upper layer. each one who wants to
+  *  request a service from LLC, must call this function. details of requested
+  *  service is defined in input argument(prim).
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int sap_request(struct prim_if_block *prim)
+ {
+ 	int rc = 1;
+ 	/* receive REQUEST primitive from network layer; call the appropriate
+ 	 * primitive handler which then packages it up as an event and sends
+ 	 * it to the SAP or CONNECTION event handler */
+ 	if (prim->primitive < P8022_NBR_PRIMITIVES)
+ 	       /* valid primitive; call the function to handle it */
+ 		rc = Request_primitives[prim->primitive](prim);
+ 	return rc;
+ }
+ 
+ /*
+  * Function : unitdata_req_handler
+  *
+  * Description :
+  *  this function calls when upper layer wants to send data using
+  *  connection-less mode communication (UI pdu).
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int unitdata_req_handler(struct prim_if_block *prim)
+ {
+ 	int rc = 1;
+ 	struct sap_state_event *event;
+ 	/* accept data frame from network layer to be sent using connection-
+ 	 * less mode communication; timeout/retries handled by network layer;
+ 	 * package primitive as an event and send to SAP event handler */
+ 	struct p8022_sap *sap =
+ 			       llc_sap_find(prim->data->udata.source_addr.lsap);
+ 
+ 	if (!sap)
+ 		goto out;
+ 	event = sap_get_event(sap);
+ 	if (!event)
+ 		goto out;
+ 	event->type		= SAP_EV_TYPE_PRIM;
+ 	event->data.prim.prim	= P8022_DATAUNIT_PRIM;
+ 	event->data.prim.type	= P8022_PRIM_TYPE_REQUEST;
+ 	event->data.prim.data	= prim;
+ 	rc = sap_send_event(sap, event);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function : test_req_handler
+  *
+  * Description :
+  *  this function calls when upper layer wants to send a TEST pdu.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int test_req_handler(struct prim_if_block *prim)
+ {
+ 	int rc = 1;
+ 	struct sap_state_event *event;
+ 	/* package primitive as an event and send to SAP event handler */
+ 	struct p8022_sap *sap =
+ 			       llc_sap_find(prim->data->udata.source_addr.lsap);
+ 	if (!sap)
+ 		goto out;
+ 	event = sap_get_event(sap);
+ 	if (!event)
+ 		goto out;
+ 	event->type		= SAP_EV_TYPE_PRIM;
+ 	event->data.prim.prim	= P8022_TEST_PRIM;
+ 	event->data.prim.type	= P8022_PRIM_TYPE_REQUEST;
+ 	event->data.prim.data	= prim;
+ 	rc = sap_send_event(sap, event);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function : xid_req_handler
+  *
+  * Description :
+  *  this function calls when upper layer wants to send a XID pdu.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int xid_req_handler(struct prim_if_block *prim)
+ {
+ 	int rc = 1;
+ 	struct sap_state_event *event;
+ 	/* package primitive as an event and send to SAP event handler */
+ 	struct p8022_sap *sap =
+ 			       llc_sap_find(prim->data->udata.source_addr.lsap);
+ 
+ 	if (!sap) 
+ 		goto out;
+ 	event = sap_get_event(sap);
+ 	if (!event)
+ 		goto out;
+ 	event->type		= SAP_EV_TYPE_PRIM;
+ 	event->data.prim.prim	= P8022_XID_PRIM;
+ 	event->data.prim.type	= P8022_PRIM_TYPE_REQUEST;
+ 	event->data.prim.data	= prim;
+ 	rc = sap_send_event(sap, event);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function : data_req_handler
+  *
+  * Description :
+  *  this function calls when upper layer wants to send data using connection-
+  *  oriented communication mode. during sending data, connection will be locked
+  *  and received frames and expired timers will be queued in log_q filed of
+  *  connection. they will processed after sending data at end of this function
+  *  by calling process_rxframes_events function.
+  *  after sending data.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : internal failure.
+  *  -ECONNABORTED : connection already closed.
+  *  -EBUSY : sending data is not permitted in this state or LLC has send an I
+  *           pdu with p bit set to 1 and is waiting for it's response.
+  */
+ static int data_req_handler(struct prim_if_block *prim)
+ {
+ //	static spinlock_t process_rxframes_events_lock = SPIN_LOCK_UNLOCKED;
+ 	int rc = 0;
+ 	/* accept data frame from network layer to be sent using connection
+ 	 * mode communication; timeout/retries handled by this layer;
+ 	 * package primitive as an event and send to connection event handler */
+ 	struct p8022_connection *conn = prim->data->data.connection;
+ 
+ 	inc_conn_busy(conn);   /* locking connection */
+ 	conn->data_ret_val = 0;
+ 	if (conn->state == CONN_STATE_ADM) {
+ 		conn->data_ret_val = -ECONNABORTED;
+ 	} else if (data_accept_state(conn->state)) {
+ 		/* data_conn_refuse */
+ 		conn->failed_data_req = 1;
+ 		conn->data_ret_val = -EBUSY;
+ 	} else if (conn->p_flag) {
+ 		conn->failed_data_req = 1;
+ 		conn->data_ret_val = -EBUSY;
+ 	} else {
+ 		struct conn_state_event *event;
+ 
+ 		event = conn_alloc_event(conn);
+ 		if (event) {
+ 			event->type		= CONN_EV_TYPE_PRIM;
+ 			event->data.prim.prim	= P8022_DATA_PRIM;
+ 			event->data.prim.type	= P8022_PRIM_TYPE_REQUEST;
+ 			event->data.prim.data	= prim;
+ 			rc = conn_send_event(conn, event);
+ 		} else
+ 			rc = 1;
+ 		conn->data_ret_val = rc;
+ 	}
+ //	spin_lock_bh(&process_rxframes_events_lock);
+ 	process_rxframes_events(conn);
+ 	rc = conn->data_ret_val;
+ 	conn->data_ret_val = 0;
+ 	dec_conn_busy(conn);  /* opening connection lock */
+ //	spin_unlock_bh(&process_rxframes_events_lock);
+ 	return rc;
+ }
+ 
+ /*
+  * Function : confirm_impossible
+  *
+  * Description :
+  *  this function informs upper layer about failing in connection establishment.
+  *  this function calls by connect_req_handler.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains confirmation
+  *  data.
+  *
+  * Returns :
+  *  none
+  */
+ static void confirm_impossible(struct prim_if_block *prim)
+ {
+ 	prim->data->conn.status = P8022_STATUS_IMPOSSIBLE;
+ 	prim->sap->confirm(prim);
+ }
+ 
+ /*
+  * Function : connect_req_handler
+  *
+  * Description :
+  *  this function calls when upper layer wants to establish an LLC connection
+  *  with a remote machine. this function packages a proper event and sends it
+  *  connection component state machine.
+  *  success or failure of connection establishment will inform to upper layer
+  *  via calling it's confirm function and passing proper information.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0
+  */
+ static int connect_req_handler(struct prim_if_block *prim)
+ {
+ 	u16 rc;
+ 	struct p8022_sap *sap = prim->sap;
+ 	struct conn_state_event *event;
+ 	/* network layer supplies addressing required to establish connection;
+ 	 * package as an event and send it to the connection event handler */
+ 	struct p8022_connection *conn = find_conn(sap, 
+ 						  &prim->data->conn.dest_addr);
+ 
+ 	if (conn) {
+ 		confirm_impossible(prim);
+ 		goto out;
+ 	}
+ 	conn = llc_connection_alloc();
+ 	if (conn) {
+ 		confirm_impossible(prim);
+ 		goto out;
+ 	}
+ 	/* assign new connection to it's SAP */
+ 	sap_assign_conn(sap, conn);
+ 	memcpy(&conn->remote_dl_addr, &prim->data->conn.dest_addr,
+ 	       sizeof(address_t));
+ 	memcpy(&conn->local_dl_addr, &prim->data->conn.source_addr,
+ 	       sizeof(address_t));
+ 	conn->local_dev = prim->data->conn.device;
+ 	conn->link_no = prim->data->conn.link_no;
+ 	event = conn_alloc_event(conn);
+ 	if (event) {
+ 		event->type		= CONN_EV_TYPE_PRIM;
+ 		event->data.prim.prim	= P8022_CONNECT_PRIM;
+ 		event->data.prim.type	= P8022_PRIM_TYPE_REQUEST;
+ 		event->data.prim.data	= prim;
+ 		rc = conn_send_event(conn, event);
+ 		if (!rc)
+ 			prim->data->conn.connection = conn;
+ 	} else
+ 		rc = 1;
+ 	if (rc) {
+ 		sap_unassign_conn(sap, conn);
+ 		llc_connection_free(conn);
+ 		confirm_impossible(prim);
+ 	}
+ 	prim->data->conn.connection = conn;
+ out:	return 0;
+ }
+ 
+ /*
+  * Function : disconnect_req_handler
+  *
+  * Description :
+  *  this function calls when upper layer wants to close an established LLC
+  *  connection with a remote machine. this function packages a proper event and
+  *  sends it to connection component state machine.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int disconnect_req_handler(struct prim_if_block *prim)
+ {
+ 	u16 rc = 1;
+ 	struct conn_state_event *event;
+ 	struct p8022_connection *conn = prim->data->disc.connection;
+ 
+ 	if (conn->state == CONN_STATE_ADM || conn->state == CONN_OUT_OF_SVC)
+ 		goto out;
+ 	/*
+ 	 * postpone unassigning the connection from its SAP and returning the
+ 	 * connection until all ACTIONs have been completely executed
+ 	 */
+ 	event = conn_alloc_event(conn);
+ 	if (!event)
+ 		goto out;
+ 	event->type = CONN_EV_TYPE_PRIM;
+ 	event->data.prim.prim = P8022_DISCONNECT_PRIM;
+ 	event->data.prim.type = P8022_PRIM_TYPE_REQUEST;
+ 	event->data.prim.data = prim;
+ 	rc = conn_send_event(conn, event);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function : reset_req_handler
+  *
+  * Description :
+  *  this function calls when upper layer wants to reset an established LLC
+  *  connection with a remote machine. this function packages a proper event and
+  *  sends it to connection component state machine.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int reset_req_handler(struct prim_if_block *prim)
+ {
+ 	int rc = 1;
+ 	struct p8022_connection *conn = prim->data->res.connection;
+ 	struct conn_state_event *event = conn_alloc_event(conn);
+ 
+ 	if (event) {
+ 		event->type = CONN_EV_TYPE_PRIM;
+ 		event->data.prim.prim = P8022_RESET_PRIM;
+ 		event->data.prim.type = P8022_PRIM_TYPE_REQUEST;
+ 		event->data.prim.data = prim;
+ 		rc = conn_send_event(conn, event);
+ 	}
+ 	return rc;
+ }
+ 
+ /* We don't support flow control. */
+ static int flowcontrol_req_handler(struct prim_if_block *prim)
+ {
+ 	int rc = 1;
+ 	/* network layer supplies connection handle; map it to a connection;
+ 	 * package as event and send it to connection event handler */
+ 	struct p8022_connection *conn = prim->data->fc.connection;
+ 	struct conn_state_event *event = conn_alloc_event(conn);
+ 
+ 	if (!rc) {
+ 		event->type = CONN_EV_TYPE_PRIM;
+ 		event->data.prim.prim = P8022_FLOWCONTROL_PRIM;
+ 		event->data.prim.type = P8022_PRIM_TYPE_REQUEST;
+ 		event->data.prim.data = prim;
+ 		rc = conn_send_event(conn, event);
+ 	}
+ 	return rc;
+ }
+ 
+ /*
+  * Function : sap_response
+  *
+  * Description :
+  *  this function is a interface function to upper layer. each one who wants to
+  *  response to an indicate can call this function via calling sap_response with
+  *  proper service parameters.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains service
+  *  parameters.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int sap_response(struct prim_if_block *prim)
+ {
+ 	u16 rc = 1;
+ 	/*
+ 	 * network layer RESPONSE primitive received; package primitive
+ 	 * as an event and send it to the connection event handler
+ 	*/
+ 	if (prim->primitive < P8022_NBR_PRIMITIVES)
+ 	       /* valid primitive; call the function to handle it */
+ 		rc = Response_primitives[prim->primitive](prim);
+ 	return rc;
+ }
+ 
+ /*
+  * Function : connect_rsp_handler
+  *
+  * Description :
+  *  response to connect indication.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains response info.
+  *
+  * Returns :
+  *  0
+  */
+ static int connect_rsp_handler(struct prim_if_block *prim)
+ {
+ 	struct p8022_connection *conn = prim->data->conn.connection;
+ 
+ 	conn->link_no = prim->data->conn.link_no;
+ 	return 0;
+ }
+ 
+ /*
+  * Function : reset_rsp_handler
+  *
+  * Description :
+  *  response to RESET indication.
+  *
+  * Parameters :
+  *  struct prim_if_block *prim : pointer to structure that contains response
+  *  				 info.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static int reset_rsp_handler(struct prim_if_block *prim)
+ {
+ 	int rc = 1;
+ 	/* network layer supplies connection handle; map it to a connection;
+ 	 * package as event and send it to connection event handler */
+ 	struct p8022_connection *conn = prim->data->res.connection;
+ 	struct conn_state_event *event = conn_alloc_event(conn);
+ 
+ 	if (event) {
+ 		event->type = CONN_EV_TYPE_PRIM;
+ 		event->data.prim.prim = P8022_RESET_PRIM;
+ 		event->data.prim.type = P8022_PRIM_TYPE_RESPONSE;
+ 		event->data.prim.data = prim;
+ 		rc = conn_send_event(conn, event);
+ 	}
+ 	return rc;
+ }
+ 
+ static int no_rsp_handler(struct prim_if_block *prim)
+ {
+ 	return 0;
+ }
+ 
+ /*
+  * Function : process_rxframes_events
+  *
+  * Description :
+  *  this function processes frames that has received and timers that has expired
+  *  during sending an I pdu (refer to data_req_handler).
+  *  frames queue by mac_indicate function (llc_mac.c) and timers queue by timer
+  *  callback functions(llc_c_ac.c).
+  *
+  * Parameters :
+  *  struct p8022_connection *conn : pointer to connection.
+  *
+  * Returns :
+  *  None
+  */
+ static void process_rxframes_events(struct p8022_connection *conn)
+ {
+ 	struct p8022_rx_object *rx_object;
+ 	struct list_head *entry;
+ 
+ 	if (conn->busy > 1)  /* avoiding reentrancy */
+ 		goto out;
+ 	spin_lock_bh(&conn->log_q.lock);
+ 	if (list_empty(&conn->log_q.list))
+ 		goto unlock;
+ 	list_for_each(entry, &conn->log_q.list) {
+ 		rx_object = list_entry(entry, struct p8022_rx_object, node);
+ 		list_del(&rx_object->node);
+ 		if (rx_object->desc == P8022_FRAME)
+ 			if (conn->state > 1) /* not closed */
+ 				llc_pdu_router(conn->parent_sap,
+ 					       conn, rx_object->obj.skb,
+ 					       P8022_TYPE_2);
+ 			else 
+ 				kfree_skb(rx_object->obj.skb);
+ 		else if (rx_object->desc == P8022_EVENT) {
+ 			/* timer expiration event */
+ 			if (conn->state > 1)  /* not closed */
+ 				conn_send_event(conn, rx_object->obj.event);
+ 			else
+ 				conn_free_event(conn, rx_object->obj.event);
+ 		}
+ 		kfree(rx_object);
+ 	}
+ unlock:	spin_unlock_bh(&conn->log_q.lock);
+ out:;
+ }
+ 
+ EXPORT_SYMBOL(llc_sap_open);
+ EXPORT_SYMBOL(llc_sap_close);
Index: kernel-acme/net/8022llc/llc_mac.c
diff -c /dev/null kernel-acme/net/8022llc/llc_mac.c:1.1.4.11
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_mac.c	Thu Aug 30 19:42:35 2001
***************
*** 0 ****
--- 1,302 ----
+ /*
+  * llc_mac.c - Manages interface between LLC and MAC
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netdevice.h>
+ #include <linux/if_arp.h>
+ #include <net/sock.h>
+ #include <net/llc_if.h>
+ #include <net/llc_mac.h>
+ #include <net/llc_pdu.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_evnt.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_s_ev.h>
+ 
+ /* function prototypes */
+ static void fix_up_incoming_skb(struct sk_buff *skb);
+ 
+ /*
+  * Function: mac_send_pdu
+  *
+  * Description:
+  *  If module is not initialized then returns failure, else figures out where
+  *  to direct this PDU. Sends PDU to specific device, at this point a device
+  *  must has been assigned to the PDU; If not, can't transmit the PDU. PDU sent
+  *  to MAC layer, is free to re-send at a later time.
+  *
+  * Parameters:
+  *  struct sk_buff *skb : This argument points to pdu which must be sent.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ u16 mac_send_pdu(struct sk_buff *skb)
+ {
+ 	struct sk_buff *skb2;
+ 	int pri = GFP_ATOMIC;
+ 
+ 	if (!skb->dev)
+ 		return -1;
+ 	if (skb->sk)
+ 		pri = (int)skb->sk->priority;
+ 	skb2 = skb_clone(skb, pri);
+ 	if (!skb2)
+ 		return -1;
+ 	dev_queue_xmit(skb2);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: mac_indicate
+  *
+  * Description:
+  *  This function is LLC callback for net_bh (linux networking bottom half
+  *  handler). When a 802.2 frame receives to system, net_bh calls this function.
+  *  this function checks SAP and connection of received pdu and returns frame
+  *  to llc_pdu_router for sending to proper state machine. if frames is related
+  *  to a busy connection ( a connection is sending data now ), function queues
+  *  this frame in log_q of connection. this frame will be processed after
+  *  sending data at end of data_req_handler in llc_if.c by calling
+  *  process_rxframe_events.
+  *
+  * Parameters:
+  *  struct sk_buff *skb : received pdu.
+  *  struct net_device *dev : device that receive pdu.
+  *  struct packet_type *pt : packet type.
+  *
+  * Returns:
+  *  0 : success
+  *  1 : failure
+  */
+ int mac_indicate(struct sk_buff *skb, struct net_device *dev,
+ 		 struct packet_type *pt)
+ {
+ 	struct p8022_sap *sap;
+ 	pdu_sn_t *pdu;
+ 	u8 dest;
+ 
+ 	/* When the interface is in promisc. mode, drop all the crap that it
+ 	   receives, do not try to analyse it. */
+ 	if (skb->pkt_type == PACKET_OTHERHOST)
+ 		goto drop;
+         skb = skb_share_check(skb, GFP_ATOMIC);
+         if (!skb)
+ 		goto out;
+ 	fix_up_incoming_skb(skb);
+ 	pdu = (pdu_sn_t *)skb->nh.raw;
+ 	if (!pdu->dsap) { /* NULL DSAP, refer to station */
+ 		llc_pdu_router(NULL, NULL, skb, 0);
+ 		goto out;
+ 	}
+ 	sap = llc_sap_find(pdu->dsap);
+ 	if (!sap) /* unknown SAP */
+ 		goto drop;
+ 	decode_pdu_type(skb, &dest);
+ 	if (dest == P8022_DEST_SAP) /* type 1 services */
+ 		llc_pdu_router(sap, NULL, skb, P8022_TYPE_1);
+ 	else if (dest == P8022_DEST_CONN) {
+ 		address_t source_addr;
+ 		struct p8022_connection *conn;
+ 
+ 		pdu_decode_sa(skb, source_addr.mac);
+ 		pdu_decode_ssap(skb, &source_addr.lsap);
+ 		conn = sap_find_conn(sap, &source_addr);
+ 		if (!conn) { /* didn't find an active connection; allocate a
+ 			      connection to use; associate it with this SAP */
+ 			conn = llc_connection_alloc();
+ 			if (!conn)
+ 				goto drop;
+ 			memcpy(&conn->remote_dl_addr, &source_addr,
+ 			       sizeof(address_t));
+ 			sap_assign_conn(sap, conn);
+ 		}
+ 		if (conn->busy > 0) {
+ 			/* connection is sending I pdu, queue frame */
+ 			struct p8022_rx_object *rxobj = kmalloc(sizeof(*rxobj),
+ 								GFP_ATOMIC);
+ 			if (rxobj) {
+ 				rxobj->desc = P8022_FRAME;
+ 				rxobj->obj.skb = skb;
+ 				spin_lock(&conn->log_q.lock);
+ 				list_add_tail(&rxobj->node, &conn->log_q.list);
+ 				spin_unlock(&conn->log_q.lock);
+ 			} else
+ 				goto drop;
+ 		} else
+ 			llc_pdu_router(conn->parent_sap, conn, skb,
+ 				       P8022_TYPE_2);
+ 	} else /* unknown or not supported pdu */
+  		goto drop;
+ out:	return 0;
+ drop:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: fix_up_incoming_skb
+  *
+  * Description:
+  *  Initializes internal skb pointer to start of network layer by deriving
+  *  length of LLC header; finds length of LLC control field in LLC header by
+  *  looking at the two lowest-order bits of the first control field byte;
+  *  field is either 3 or 4 bytes long.
+  *
+  * Parameters:
+  *  struct sk_buff *skb : This argument points to incoming skb.
+  *
+  * Returns:
+  *  nothing
+  */
+ static void fix_up_incoming_skb(struct sk_buff *skb)
+ {
+ 	u8 llc_len = 2;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->data;
+ 
+ 	if ((pdu->ctrl_1 & LLC_PDU_TYPE_MASK) == LLC_PDU_TYPE_U)
+ 		llc_len = 1;
+ 	llc_len += 2;
+ 	skb_pull(skb, llc_len);
+ 	if (skb->protocol == htons(ETH_P_802_2)) {
+ 		u16 pdulen = ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->lpdu_len,
+ 		    data_size = ntohs(pdulen) - llc_len;
+ 
+ 		skb_trim(skb, data_size);
+ 	}	
+ }
+ 
+ /*
+  * Function: llc_pdu_router
+  *
+  * Description:
+  *  Queues received PDUs from LLC_MAC PDU receive queue until queue is empty;
+  *  examines LLC header to determine the destination of PDU, if DSAP is NULL
+  *  then data unit destined for station else frame destined for SAP or
+  *  connection; finds a matching open SAP, if one, forwards the packet to it;
+  *  If no matching SAP, drops the packet.
+  *
+  * Parameters:
+  *  sap_t *sap : This argument points to current sap component structure.
+  *  struct p8022_connection *conn : This argument points to current connection
+  *  				    structure.
+  *  frame_t *frame : This argument points to received frame.
+  *  u8 type : This argument is type of received frame, that is P8022_TYPE_1 or
+  *  	      P8022_TYPE_2
+  *
+  * Returns:
+  *  None
+  */
+ void llc_pdu_router(struct p8022_sap *sap, struct p8022_connection *conn,
+ 		    struct sk_buff *skb, u8 type)
+ {
+ 	struct sap_state_event *sap_event;
+ 	struct conn_state_event *conn_event;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	if (!pdu->dsap) {
+ 		struct p8022_station *station = station_get();
+ 		struct station_state_event *stat_event =
+ 						     station_get_event(station);
+ 		if (stat_event) {
+ 			stat_event->type = STATION_EV_TYPE_PDU;
+ 			stat_event->data.pdu.skb = skb;
+ 			stat_event->data.pdu.reason = 0;
+ 			station_send_event(station, stat_event);
+ 		}
+ 	} else if (type == P8022_TYPE_1) {
+ 		sap_event = sap_get_event(sap);
+ 		if (sap_event) {
+ 			sap_event->type = SAP_EV_TYPE_PDU;
+ 			sap_event->data.pdu.skb = skb;
+ 			sap_event->data.pdu.reason = 0;
+ 			sap_send_event(sap, sap_event);
+ 		}
+ 	} else if (type == P8022_TYPE_2) {
+ 		if (!conn->local_dev)
+ 			conn->local_dev = skb->dev;
+ 		conn_event = conn_alloc_event(conn);
+ 		if (conn_event) {
+ 			conn_event->type = CONN_EV_TYPE_PDU;
+ 			conn_event->data.pdu.skb = skb;
+ 			conn_event->data.pdu.reason = 0;
+ 			conn_send_event(conn, conn_event);
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Function: lan_hdrs_init
+  *
+  * Description:
+  *  Fills MAC header fields, depending on MAC type.
+  *
+  * Parameters:
+  *  skb : Address of the frame to initialize its MAC header
+  *  sa :i The MAC source address
+  *  da : The MAC destination address
+  *
+  * Returns:
+  *  0, If MAC type is a valid type and initialization completes correctly
+  *  1, Otherwise
+  */
+ u16 lan_hdrs_init(struct sk_buff *skb, u8 *sa, u8 *da)
+ {
+ 	u8 *src_addr;
+ 	u8 *dest_addr;
+ 	u16 rc = 0;
+ 	u16 lpdu_len;
+ 
+ 	switch (skb->dev->type) {
+ #ifdef CONFIG_TR
+ 		case ARPHRD_IEEE802: {
+ 			token_ring_mac_hdr_t *trh = (token_ring_mac_hdr_t *)
+ 						    skb_push(skb, sizeof(*trh));
+ 			struct net_device *dev = skb->dev;
+ 
+ 			trh->ac = AC;
+ 			trh->fc = LLC_FRAME;
+ 			if (sa)
+ 				memcpy(trh->sa, sa, dev->addr_len);
+ 			else
+ 				memset(trh->sa, 0, dev->addr_len);
+ 			if (da) {
+ 				memcpy(trh->da, da, dev->addr_len);
+ 				tr_source_route((struct trh_hdr *)trh, dev);
+ 			}
+ 			skb->mac.raw = skb->data;
+ 			break;
+ 		}
+ #endif
+ 		case ARPHRD_ETHER :
+ 		case ARPHRD_LOOPBACK :
+ 			lpdu_len = skb->len;
+ 			skb->mac.raw = skb_push(skb,
+ 						sizeof(ieee_802_3_mac_hdr_t));
+ 			memset(skb->mac.raw, 0, sizeof(ieee_802_3_mac_hdr_t));
+ 			((ieee_802_3_mac_hdr_t *)skb->mac.raw)->lpdu_len =
+ 				htons(lpdu_len);
+ 			dest_addr = ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->da;
+ 			src_addr =
+ 			  ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->sa;
+ 			memcpy(dest_addr, da, MAC_ADDR_LEN);
+ 			memcpy(src_addr, sa, MAC_ADDR_LEN);
+ 			break;
+ 		default:
+ 			printk(KERN_WARNING "Unknown DEVICE type : %d\n",
+ 			       skb->dev->type);
+ 			rc = 1;
+ 	}
+ 	return rc;
+ }
Index: kernel-acme/net/8022llc/llc_main.c
diff -c /dev/null kernel-acme/net/8022llc/llc_main.c:1.1.4.13
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_main.c	Tue Aug 28 01:32:08 2001
***************
*** 0 ****
--- 1,709 ----
+ /*
+  * llc_main.c - This module contains main functions to manage station, saps
+  * 	and connections of the LLC.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/sched.h>
+ #include <linux/init.h>
+ #include <linux/module.h>
+ #include <linux/proc_fs.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_evnt.h>
+ #include <net/llc_actn.h>
+ #include <net/llc_stat.h>
+ #include <net/llc_c_ac.h>
+ #include <net/llc_s_ac.h>
+ #include <net/llc_c_ev.h>
+ #include <net/llc_c_st.h>
+ #include <net/llc_s_ev.h>
+ #include <net/llc_s_st.h>
+ #include <net/llc_mac.h>
+ 
+ /* static function prototypes */
+ static u16 station_service_events(struct p8022_station *station);
+ static void station_free_event(struct p8022_station *station,
+ 			      struct station_state_event *event);
+ static u16 station_send_pdus(struct p8022_station *station);
+ static u16 station_next_state(struct p8022_station *station,
+ 			      struct station_state_event *event);
+ static u16 exec_station_transition_actions(struct p8022_station *station,
+ 					station_state_transition_t *transition,
+ 					     struct station_state_event *event);
+ static station_state_transition_t *
+ 		     find_station_transition(struct p8022_station *station,
+ 					     struct station_state_event *event);
+ static int rtn_all_conns(struct p8022_sap *sap);
+ 
+ static struct p8022_station Station;	/* only one of its kind */
+ u16 Max_nbr_saps = P8022_GLOBAL_DEFAULT_MAX_NBR_SAPS;
+ u16 Max_nbr_connections = P8022_GLOBAL_DEFAULT_MAX_NBR_CONNS;
+ struct prim_if_block Ind_prim, Cfm_prim;
+ prim_data_u Ind_data_prim, Cfm_data_prim;
+ 
+ /*
+  * Function : llc_sap_alloc
+  *
+  * Description:
+  *  Allocates a SAP from the available saps list and initializes it.
+  *
+  * Parameters :
+  *  None
+  *
+  * Returns :
+  *  the allocated sap
+  */
+ struct p8022_sap *llc_sap_alloc(void)
+ {
+ 	struct p8022_sap *sap = kmalloc(sizeof(*sap), GFP_ATOMIC);
+ 
+ 	if (sap) {
+ 		memset(sap, 0, sizeof(*sap));
+ 		sap->state = SAP_STATE_ACTIVE;
+ 		memcpy(sap->local_dl_addr.mac, Station.mac_sa, MAC_ADDR_LEN);
+ 		INIT_LIST_HEAD(&sap->connection_list.list);
+ 		spin_lock_init(&sap->connection_list.lock);
+ 		skb_queue_head_init(&sap->mac_pdu_q);
+ 	}
+ 	return sap;
+ }
+ 
+ /*
+  * Function : llc_free_sap
+  *
+  * Description:
+  *  Returns a sap to the available saps list and its connections (if any)
+  *  to the available connections list.
+  *
+  * Parameters :
+  *  sap : Address of the sap
+  *
+  * Returns :
+  *  None
+  */
+ void llc_free_sap(struct p8022_sap *sap)
+ {
+ 	struct p8022_station *station = sap->parent_station;
+ 
+ 	rtn_all_conns(sap);
+ 	spin_lock_bh(&station->sap_list.lock);
+ 	list_del(&sap->node);
+ 	spin_unlock_bh(&station->sap_list.lock);
+ 	kfree(sap);
+ }
+ 
+ /*
+  * Function : llc_sap_save
+  *
+  * Description:
+  *  Adds a sap to the LLC's station sap list.
+  *
+  * Parameters :
+  *  sap : Address of the sap
+  *
+  * Returns :
+  *  None
+  */
+ void llc_sap_save(struct p8022_sap *sap)
+ {
+ 	spin_lock_bh(&Station.sap_list.lock);
+ 	list_add_tail(&sap->node, &Station.sap_list.list);
+ 	spin_unlock_bh(&Station.sap_list.lock);
+ }
+ 
+ /*
+  * Function : llc_sap_find
+  *
+  * Description:
+  *  Searchs for a sap in the sap list of the LLC's station
+  *  upon the sap ID.
+  *
+  * Parameters :
+  *  sap : Address of a place for the found sap (if found).
+  *
+  * Returns :
+  *  0, on success
+  *  nonzero, otherwise
+  */
+ struct p8022_sap *llc_sap_find(u8 sap_value)
+ {
+ 	struct p8022_sap* sap = NULL;
+ 	struct list_head *entry;
+ 
+ 	spin_lock_bh(&Station.sap_list.lock);
+ 	list_for_each(entry, &Station.sap_list.list) {
+ 		sap = list_entry(entry, struct p8022_sap, node);
+ 		if (sap->local_dl_addr.lsap == sap_value)
+ 			break;
+ 	}
+         if (entry == &Station.sap_list.list) /* not found */
+ 		sap = NULL;
+ 	spin_unlock_bh(&Station.sap_list.lock);
+ 	return sap;
+ }
+ 
+ /*
+  * Function : llc_connection_alloc
+  *
+  * Description:
+  *  Allocates a connection and initializes it.
+  *
+  * Parameters :
+  *  None
+  *
+  * Returns :
+  *  The new connection or NULL if there's no memory available for one
+  */
+ struct p8022_connection *llc_connection_alloc(void)
+ {
+ 	struct p8022_connection *conn = kmalloc(sizeof(*conn), GFP_ATOMIC);
+ 
+ 	if (!conn)
+ 		goto out;
+ 	memset(conn, 0, sizeof(*conn));
+ 	conn->state	   = CONN_STATE_ADM;
+ 	conn->inc_step	   = 1;
+ 	conn->dec_step	   = 1;
+ 	conn->inc_cntr	   = 2;
+ 	conn->dec_cntr	   = 2;
+ 	conn->connect_step = 1;
+ 	skb_queue_head_init(&conn->mac_pdu_q);
+ 	skb_queue_head_init(&conn->pdu_unack_q);
+ 	INIT_LIST_HEAD(&conn->log_q.list);
+ 	spin_lock_init(&conn->log_q.lock);
+ 	conn->n2	   = 2;    /* max retransmit */
+ 	conn->k		   = 2;    /* tx window size, will adjust dynamically */
+ 	conn->rw	   = 128;  /* rx window size (optional and equal to
+ 				      tx_window of remote LLC )*/
+ out:	return conn;
+ }
+ 
+ /*
+  * Function : llc_connection_free
+  *
+  * Description:
+  *  Returns a connection to available connections list and
+  *  deinitializes it.
+  *
+  * Parameters :
+  *  The connection to be released
+  *
+  * Returns :
+  *  None
+  */
+ void llc_connection_free(struct p8022_connection *conn)
+ {
+ 	conn->state = CONN_OUT_OF_SVC;
+ 	/* stop all (possibly) running timers */
+ 	conn_ac_stop_all_timers(conn, NULL);
+ 	/* handle return of frames on lists */
+ 	skb_queue_purge(&conn->mac_pdu_q);
+ 	skb_queue_purge(&conn->pdu_unack_q);
+ 	kfree(conn);
+ }
+ 
+ /*
+  * Function : llc_connection_reset
+  *
+  * Description:
+  *  Resets a connection to the out of service state. stops its timers
+  *  and frees any frames in the queues of the connection.
+  *
+  * Parameters :
+  *  conn : Address of the connection
+  *
+  * Returns :
+  *  Always 0
+  */
+ u16 llc_connection_reset(struct p8022_connection *conn)
+ {
+ 	struct conn_state_event *event = NULL;
+ 
+ 	conn_ac_stop_all_timers(conn, event);
+ 	skb_queue_purge(&conn->mac_pdu_q);
+ 	skb_queue_purge(&conn->pdu_unack_q);
+ 	skb_queue_head_init(&conn->mac_pdu_q);
+ 	skb_queue_head_init(&conn->pdu_unack_q);
+ 	INIT_LIST_HEAD(&conn->log_q.list);
+ 	spin_lock_init(&conn->log_q.lock);
+ 	conn->remote_busy_flag	= 0;
+ 	conn->cause_flag	= 0;
+ 	conn->retry_count	= 0;
+ 	conn->p_flag		= 0;
+ 	conn->f_flag		= 0;
+ 	conn->s_flag		= 0;
+ 	conn->ack_pf		= 0;
+ 	conn->first_pdu_Ns	= 0;
+ 	conn->ack_must_be_send	= 0;
+ 	conn->inc_step		= 1;
+ 	conn->dec_step		= 1;
+ 	conn->inc_cntr		= 2;
+ 	conn->dec_cntr		= 2;
+ 	conn->X			= 0;
+ 	conn->busy		= 0;
+ 	conn->failed_data_req	= 0 ;
+ 	conn->last_nr		= 0;
+ 	return 0;
+ }
+ 
+ /*
+  * Function : rtn_all_conns
+  *
+  * Description:
+  *  Closes all connections of a sap and returns them to the available
+  *  connections list.
+  *
+  * Parameters :
+  *  sap : Address of the sap to close its connections
+  *
+  * Returns :
+  *  *  0, if all actions complete successfully
+  *  *  nonzero, otherwise
+  */
+ static int rtn_all_conns(struct p8022_sap *sap)
+ {
+ 	int rc = 0;
+ 	prim_data_u prim_data;
+ 	struct prim_if_block prim;
+ 	struct p8022_connection *conn;
+ 	struct list_head *entry;
+ 
+ 	spin_lock_bh(&sap->connection_list.lock);
+ 	list_for_each(entry, &sap->connection_list.list) {
+ 		conn = list_entry(entry, struct p8022_connection, node);
+ 		list_del(&conn->node);
+ 		prim.sap = sap;
+ 		prim_data.disc.connection = conn;
+ 		prim.primitive = P8022_DISCONNECT_PRIM;
+ 		prim.data = &prim_data;
+ 		conn->state = CONN_STATE_TEMP;
+ 		if (sap->request(&prim))
+ 			rc = 1;
+ 	}
+ 	spin_unlock_bh(&sap->connection_list.lock);
+ 	return rc;
+ }
+ 
+ /*
+  * Function : station_get
+  *
+  * Description:
+  *  Returns the address of the global Station.
+  *
+  * Parameters :
+  *  None
+  *
+  * Returns :
+  *  Address of a place to copy the global station to it.
+  */
+ struct p8022_station *station_get(void)
+ {
+ 	return &Station;
+ }
+ 
+ /*
+  * Function : station_get_event
+  *
+  * Description:
+  *  Allocates an event from the available event list of a station.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *  event : Address of a place for the allocated event
+  *
+  * Returns :
+  *  0, on success
+  *  nonzero, otherwise
+  */
+ struct station_state_event *station_get_event(struct p8022_station *station)
+ {
+ 	struct station_state_event *event = kmalloc(sizeof(*event), GFP_ATOMIC);
+ 
+ 	if (event)
+ 		memset(event, 0, sizeof(*event));
+ 	return event;
+ }
+ 
+ /*
+  * Function : station_send_event
+  *
+  * Description:
+  *  Queues an event (on the station event queue) for handling by the
+  *  station state machine and attempts to process any queued-up events.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *  event : Address of the event
+  *
+  * Returns :
+  *  Always 0
+  */
+ u16 station_send_event(struct p8022_station *station,
+ 		       struct station_state_event *event)
+ {
+ 	spin_lock_bh(&station->event_q.lock);
+ 	list_add_tail(&event->node, &station->event_q.list);
+ 	spin_unlock_bh(&station->event_q.lock);
+ 	station_service_events(station);
+ 	return 0;
+ }
+ 
+ /*
+  * Function : station_send_pdu
+  *
+  * Description:
+  *  Queues a PDU to send to the MAC layer.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *  skb     : Address of the PDU
+  *
+  * Returns :
+  *  Always 0
+  */
+ u16 station_send_pdu(struct p8022_station *station, struct sk_buff *skb)
+ {
+ 	skb_queue_tail(&station->mac_pdu_q, skb);
+ 	station_send_pdus(station);
+ 	return 0;
+ }
+ 
+ /*
+  * Function : llc_service_io
+  *
+  * Description:
+  *  This function is called by the PDU router (which is turn in called
+  *  by the LLC lower layer MAC-level interface via an OS-level signal);
+  *  send as many queued UNIT DATA PDUs to MAC layer as possible;
+  *  process as many queued events for all three component level.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *
+  * Returns :
+  *  Always 0
+  */
+ u16 llc_service_io(struct p8022_station *station)
+ {
+ 	station_service_events(station);
+ 	return 0;
+ }
+ 
+ /*
+  * Function : station_send_pdus
+  *
+  * Description:
+  *  Tries to send any PDUs queued in the station mac_pdu_q to the MAC
+  *  layer.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *
+  * Returns :
+  *  Always 0
+  */
+ static u16 station_send_pdus(struct p8022_station *station)
+ {
+ 	u16 rc;
+ 	struct sk_buff *skb;
+ 
+ 	while ((skb = skb_dequeue(&station->mac_pdu_q)) != NULL) {
+ 		rc = mac_send_pdu(skb);
+ 		kfree_skb(skb);
+ 		if (rc)
+ 			break;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Function : station_free_event
+  *
+  * Description:
+  *  Frees an event
+  *
+  * Parameters :
+  *  station : Address of the station
+  *  event : Address of the event
+  *
+  * Returns :
+  *  0, on success
+  *  nonzero, on failure
+  */
+ static void station_free_event(struct p8022_station *station,
+ 			      struct station_state_event *event)
+ {
+ 	struct sk_buff *skb = event->data.pdu.skb;
+ 
+ 	if (event->type == STATION_EV_TYPE_PDU)
+ 		kfree_skb(skb);
+ 	kfree(event);
+ }
+ 
+ /*
+  * Function : station_service_events
+  *
+  * Description:
+  *  Get an event from the station event queue (if any); attempt to
+  *  service the event; if event serviced, get the next event (if any)
+  *  on the event queue; if event not service, re-queue the event on
+  *  the event queue and attempt to service the next event; when serviced
+  *  all events in queue, finished; if don't transition to different
+  *  state, just service all events once; if transition to new state,
+  *  service all events again.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *
+  * Returns :
+  *  Always 0
+  */
+ static u16 station_service_events(struct p8022_station *station)
+ {
+ 	struct station_state_event *event;
+ 	struct list_head *entry;
+ 
+ 	spin_lock_bh(&station->event_q.lock);
+ 	list_for_each(entry, &station->event_q.list) {
+ 		event = list_entry(entry, struct station_state_event, node);
+ 		list_del(&event->node);
+ 		station_next_state(station, event);
+ 	}
+ 	spin_unlock_bh(&station->event_q.lock);
+ 	return 0;
+ }
+ 
+ /*
+  * Function : station_next_state
+  *
+  * Description:
+  *  Processes an event, executes any transitions related to that event
+  *  and updates the state of the station.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *  event : Address of the event
+  *
+  * Returns :
+  *  0, on success
+  *  nonzero, on failure
+  */
+ static u16 station_next_state(struct p8022_station *station,
+ 			      struct station_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	station_state_transition_t *transition;
+ 
+ 	if (station->state > NBR_STATION_STATES)
+ 		goto out;
+ 	transition = find_station_transition(station, event);
+ 	if (transition) {
+ 		/* got the state to which we next transition; perform the
+ 		 * actions associated with this transition before actually
+ 		 * transitioning to the next state */
+ 		rc = exec_station_transition_actions(station, transition,
+ 						     event);
+ 		if (!rc)
+ 			/* transition station to next state if all actions
+ 			 * execute successfully; done; wait for next event */
+ 			station->state = transition->next_state;
+ 	} else
+ 		/* event not recognized in current state; re-queue it for
+ 		 * processing again at a later time; return failure */
+ 		rc = 0;
+ out:	station_free_event(station, event);
+ 	return rc;
+ }
+ 
+ /*
+  * Function : find_station_transition
+  *
+  * Description:
+  *  Search thru events of the current state of the station until list
+  *  exhausted or it's obvious that the event is not valid for the
+  *  current state.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *  event : Address of the event
+  *
+  * Returns :
+  *  Address of the transition, if found any
+  *  NULL, if no transition found
+  */
+ static station_state_transition_t *find_station_transition(struct p8022_station *station,
+ 					      struct station_state_event *event)
+ {
+ 	u16 i;
+ 	station_state_transition_t **next_transition;
+ 	station_state_t *curr_state = &Station_state_table[station->state - 1];
+ 
+ 	for (i = 0, next_transition = curr_state->transitions;
+ 	     next_transition[i]->event; i++)
+ 		if (!next_transition[i]->event(station, event))
+ 			return next_transition[i];
+ 	return NULL;
+ }
+ 
+ /*
+  * Function : exec_station_transition_actions
+  *
+  * Description:
+  *  Executes actions of a transition of the station state machine.
+  *
+  * Parameters :
+  *  station : Address of the station
+  *  transition : Address of the transition
+  *  event : Address of the event that caused the transition
+  *
+  * Returns :
+  *  0, if all actions complete successfully
+  *  nonzero, otherwise
+  */
+ static u16 exec_station_transition_actions(struct p8022_station *station,
+ 					station_state_transition_t *transition,
+ 					   struct station_state_event *event)
+ {
+ 	u16 rc = 0;
+ 	station_action_t *next_action;
+ 
+ 	for (next_action = transition->event_actions;
+ 	     next_action && *next_action; next_action++)
+ 		if ((*next_action)(station, event))
+ 			rc = 1;
+ 	return rc;
+ }
+ 
+ /*
+  * Function: frame_pdu_allocate
+  *
+  * Description:
+  *  Similar to frame_allocate, except that it allocates an sk_buff for frame and
+  *  initializes sk_buff fields. 
+  *
+  * Parameters:
+  *  none
+  *
+  * Returns:
+  *  allocated skb
+  */
+ struct sk_buff *frame_pdu_allocate(void)
+ {
+ 	struct sk_buff *skb = alloc_skb(128, GFP_ATOMIC);
+ 
+ 	if (skb) {
+ 		skb_reserve(skb, 50);
+ 		skb->nh.raw   = skb->h.raw = skb->data;
+ 		skb->protocol = htons(ETH_P_802_2);
+ 		skb->dev      = dev_base->next;
+ 		skb->mac.raw  = skb->head;
+ 	}
+ 	return skb;
+ }
+ 
+ static int p8022_proc_get_info(char *bf, char **start, off_t offset, int length)
+ {
+ 	struct p8022_sap *sap;
+ 	struct p8022_connection *conn;
+ 	struct list_head *sap_entry, *conn_entry;
+ 	off_t begin = 0, pos = 0;
+ 	int len = 0;
+ 		
+ 	spin_lock_bh(&Station.sap_list.lock);
+ 	list_for_each(sap_entry, &Station.sap_list.list) {
+ 		sap = list_entry(sap_entry, struct p8022_sap, node);
+ 		len += snprintf(bf + len, length - offset - len,
+ 				"lsap=%d\n", sap->local_dl_addr.lsap);
+ 		spin_lock_bh(&sap->connection_list.lock);
+ 		if (list_empty(&sap->connection_list.list)) {
+ 			len += snprintf(bf + len, length - offset - len,
+ 					"no connections\n");
+ 			goto unlock;
+ 		}
+ 		len += snprintf(bf + len, length - offset - len,
+ 				"connection list:\nstate      retries busy\n",
+ 				sap->local_dl_addr.lsap);
+ 		list_for_each(conn_entry, &sap->connection_list.list) {
+ 			conn = list_entry(conn_entry, struct p8022_connection,
+ 					  node);
+ 			len += snprintf(bf + len, length - offset - len,
+ 					"  %-11s%-8d%-4d\n",
+ 				   Connection_state_table[conn->state - 1].desc,
+ 					conn->retry_count,
+ 					conn->busy);
+ 			}
+ unlock:		spin_unlock_bh(&sap->connection_list.lock);
+                 pos = begin + len;
+                 if (pos < offset) {
+                         len = 0; /* Keep dumping into the buffer start */
+ 			begin = pos;
+                 }
+                 if (pos > offset + length) /* We have dumped enough */
+                         break;
+ 	}
+ 	spin_unlock_bh(&Station.sap_list.lock);
+ 
+ 	/* The data in question runs from begin to begin + len */
+ 	*start = bf + (offset - begin); /* Start of wanted data */
+ 	len -= (offset - begin); /* Remove unwanted header data from length */
+ 	return len;
+ }
+ 
+ const char banner[] __initdata =
+ 		KERN_INFO "LLC 2.0 by Procom, 1997, Arnaldo C. Melo, 2001\n"
+ 		KERN_INFO "NET4.0 IEEE 802.2 extended support\n";
+ const char err_llc[] __initdata = KERN_ERR "LLC installation NOT successful.\n";
+ 
+ static int __init p8022_init(void)
+ {
+ 	u16 rc = 0;
+ 	struct station_state_event *event;
+ 
+ 	printk(banner);
+ 	INIT_LIST_HEAD(&Station.event_q.list);
+ 	spin_lock_init(&Station.event_q.lock);
+ 	INIT_LIST_HEAD(&Station.sap_list.list);
+ 	spin_lock_init(&Station.sap_list.lock);
+ 	skb_queue_head_init(&Station.mac_pdu_q);
+ 	event = kmalloc(sizeof(*event), GFP_ATOMIC);
+ 	if (!event)
+ 		goto err;
+ 	memset(event, 0, sizeof(*event));
+ 	memcpy(Station.mac_sa, dev_base->next->dev_addr, MAC_ADDR_LEN);
+ 	Station.ack_timer.expires = jiffies + 3 * HZ;
+ 	/* initialize the station component */
+ 	Station.maximum_retry = 1;
+ 	Station.state = STATION_STATE_DOWN;
+ 	event->type = STATION_EV_TYPE_SIMPLE;
+ 	event->data.a.event = STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK;
+ 	rc = station_next_state(&Station, event);
+ 	build_offset_table();
+ 	Ind_prim.data = &Ind_data_prim;
+ 	Cfm_prim.data = &Cfm_data_prim;
+ 	proc_net_create("802.2", 0, p8022_proc_get_info);
+ out:	return rc;
+ err:	printk(err_llc);
+ 	rc = 1;
+ 	goto out;
+ }
+ 
+ static void __exit p8022_exit(void)
+ {
+ 	proc_net_remove("802.2");
+ }
+ 
+ module_init(p8022_init);
+ module_exit(p8022_exit);
Index: kernel-acme/net/8022llc/llc_pdu.c
diff -c /dev/null kernel-acme/net/8022llc/llc_pdu.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_pdu.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,840 ----
+ /*
+  * llc_pdu.c - access to PDU internals
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netdevice.h>
+ #include <net/llc_pdu.h>
+ #include <net/llc_if.h>
+ #include <net/llc_mac.h>
+ #include <net/llc_main.h>
+ 
+ static u16 pdu_decode_pdu_type(struct sk_buff *skb, u8 *type);
+ static int get_llc_hdr_length(u8 pdu_type);
+ static u8 pdu_get_pf_bit(pdu_sn_t *pdu);
+ 
+ /*
+  * Function: pdu_header_init
+  *
+  * Description:
+  *  this function sets  DSAP, SSAP and command/Response bit in LLC header.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that header must be set into it.
+  *  u8 pdu_type: type of PDU ( U,I or S).
+  *  u8 ssap: source sap.
+  *  u8 dsap: destination sap.
+  *  u8 cr: command/response bit (0 or 1).
+  *
+  * Returns:
+  *  always 0.
+  */
+ u16 pdu_header_init(struct sk_buff *skb, u8 pdu_type, u8 ssap, u8 dsap, u8 cr)
+ {
+ 	skb->nh.raw = skb_push(skb, get_llc_hdr_length(pdu_type));
+ 	((pdu_un_t *)skb->nh.raw)->dsap = dsap;
+ 	((pdu_un_t *)skb->nh.raw)->ssap = ssap;
+ 	((pdu_un_t *)skb->nh.raw)->ssap |= cr;
+ 	return 0;
+ }
+ 
+ u16 pdu_set_cmd_rsp(struct sk_buff *skb, u8 pdu_type)
+ {
+ 	((pdu_un_t *)skb->nh.raw)->ssap |= pdu_type;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_set_pf_bit
+  *
+  * Description:
+  *  This function sets poll/final bit in LLC header (based on type of PDU).
+  *  in I or S pdus, p/f bit is right bit of fourth byte in header. in U pdus
+  *  p/f bit is fifth bit of third byte.
+  *
+  * Parameters:
+  *  Frame_t *pdu_frame: input frame that p/f bit must be set into it.
+  *  u8 bit_value: poll/final bit (0 or 1).
+  *
+  * Returns:
+  *  Always 0.
+  */
+ u16 pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value)
+ {
+ 	u8 pdu_type;
+ 	u16 rc = pdu_decode_pdu_type(skb, &pdu_type);
+ 
+ 	if (rc)
+ 		goto out;
+ 	switch (pdu_type) {
+ 		case LLC_PDU_TYPE_I:
+ 		case LLC_PDU_TYPE_S:
+ 			((pdu_sn_t *)skb->nh.raw)->ctrl_2 =
+ 				(((pdu_sn_t *)skb->nh.raw)->ctrl_2 & 0xFE) |
+ 				bit_value;
+ 			break;
+ 		case LLC_PDU_TYPE_U:
+ 			((pdu_un_t *)skb->nh.raw)->ctrl_1 |=
+ 				(((pdu_un_t *)skb->nh.raw)->ctrl_1 & 0xEF) |
+ 				(bit_value << 4);
+ 			break;
+ 	}
+ out:	return 0;
+ }
+ 
+ /*
+  * Function: pdu_decode_pf_bit
+  *
+  * Description:
+  *  This function extracts poll/final bit from LLC header (based on type of
+  *  PDU). In I or S pdus, p/f bit is right bit of fourth byte in header. In U
+  *  pdus p/f bit is fifth bit of third byte.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that p/f bit must be extracted from it.
+  *  u8 *pf_bit: poll/final bit (0 or 1).
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_decode_pf_bit(struct sk_buff *skb, u8 *pf_bit)
+ {
+ 	u8 pdu_type;
+ 	u16 rc = pdu_decode_pdu_type(skb, &pdu_type);
+ 
+ 	if (rc)
+ 		goto out;
+ 	switch (pdu_type) {
+ 		case LLC_PDU_TYPE_I:
+ 		case LLC_PDU_TYPE_S:
+ 			*pf_bit = ((pdu_sn_t *)skb->nh.raw)->ctrl_2 &
+ 				  LLC_S_PF_BIT_MASK;
+ 			break;
+ 		case LLC_PDU_TYPE_U:
+ 			*pf_bit = (((pdu_un_t *)skb->nh.raw)->ctrl_1 &
+ 				  LLC_U_PF_BIT_MASK) >> 4;
+ 				break;
+ 	}
+ out:	return 0;
+ }
+ 
+ /*
+  * Function: pdu_decode_cr_bit
+  *
+  * Description:
+  *  This function extracts command/response bit from LLC header. this bit is
+  *  right bit of source SAP.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that c/r bit must be extracted from it.
+  *  u8 *cr_bit: command/response bit (0 or 1).
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_decode_cr_bit(struct sk_buff *skb, u8 *cr_bit)
+ {
+ 	*cr_bit = ((pdu_un_t *)skb->nh.raw)->ssap & LLC_PDU_CMD_RSP_MASK;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_decode_sa
+  *
+  * Description:
+  *  This function extracts source address(MAC) of input frame.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that source address must be extracted
+  *  from it.
+  *  u8 *sa: pointer to source address ( 6 byte array ).
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_decode_sa(struct sk_buff *skb, u8 *sa)
+ {
+ 	if (skb->protocol == ntohs(ETH_P_802_2))
+ 		memcpy(sa, ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->sa,
+ 		       MAC_ADDR_LEN);
+ 	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+ 		memcpy(sa, ((token_ring_mac_hdr_t *)skb->mac.raw)->sa,
+ 		       MAC_ADDR_LEN);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_decode_da
+  *
+  * Description:
+  *  This function extracts destination address(MAC) of input frame.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that destination address must be extracted
+  *  from it.
+  *  u8 *sa: pointer to destination address ( 6 byte array ).
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_decode_da(struct sk_buff *skb, u8 *da)
+ {
+ 	if (skb->protocol == ntohs(ETH_P_802_2))
+ 		memcpy(da, ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->da,
+ 		       MAC_ADDR_LEN);
+ 	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+ 		memcpy(da, ((token_ring_mac_hdr_t *)skb->mac.raw)->da,
+ 		       MAC_ADDR_LEN);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_decode_dsap
+  *
+  * Description:
+  *  This function extracts destination SAP of input frame. right bit of DSAP
+  *  designates individual/group SAP.
+  *
+  * Parameters:
+  *  struct skb *skb: input skb that destination SAP must be extracted
+  *  from it.
+  *  u8 *dsap: destination SAP (output argument).
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_decode_dsap(struct sk_buff *skb, u8 *dsap)
+ {
+ 	*dsap = ((pdu_un_t *)skb->nh.raw)->dsap & 0xFE;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_decode_ssap
+  *
+  * Description:
+  *  This function extracts source SAP of input frame. right bit of SSAP
+  *  is command/response bit.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that source SAP must be extracted
+  *  from it.
+  *  u8 *ssap: source SAP (output argument).
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_decode_ssap(struct sk_buff *skb, u8 *ssap)
+ {
+ 	*ssap = ((pdu_un_t *)skb->nh.raw)->ssap & 0xFE;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_ui_cmd
+  *
+  * Description:
+  *  This function sets third byte of LLC header as a UI PDU.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that header must be set into it.
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_init_as_ui_cmd(struct sk_buff *skb)
+ {
+ 	pdu_un_t *pdu;
+ 
+ 	pdu = (pdu_un_t *)skb->nh.raw;
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_1_PDU_CMD_UI;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_xid_cmd
+  *
+  * Description:
+  *  This function sets third,fourth,fifth and sixth bytes of LLC header as a
+  *  XID PDU.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that header must be set into it.
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 pdu_init_as_xid_cmd(struct sk_buff *skb, u8 svcs_supported, u8 rx_window)
+ {
+ 	xid_info_t *xid_info;
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_1_PDU_CMD_XID;
+ 	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+ 	xid_info = (xid_info_t *)(((u8 *)&pdu->ctrl_1) + 1);
+ 	xid_info->fmt_id = XID_FMT_ID;    /* 0x81*/
+ 	xid_info->type = svcs_supported;
+ 	xid_info->rw = (rx_window << 1);  /* size of recieve window */
+ 	skb_put(skb, 3);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_test_cmd
+  *
+  * Description:
+  *  This function is not used anywhere; because this implementation of LLC
+  *  don't sends TEST commands by itself. That only responds to receiving
+  *  TEST commands.
+  *
+  * Parameters:
+  *  skb -	Address of the skb to build
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_test_cmd(struct sk_buff *skb)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
+ 	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_disc_cmd
+  *
+  * Description:
+  *  Builds a pdu frame as a DISC command.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  p_bit: The P bit to set in the PDU
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_disc_cmd(struct sk_buff *skb, u8 p_bit)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_2_PDU_CMD_DISC;
+ 	pdu->ctrl_1 |= (((p_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_i_cmd
+  *
+  * Description:
+  *  Builds a pdu frame as an I command.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  p_bit: The P bit to set in the PDU
+  *  ns: The sequence number of the data PDU
+  *  nr: The seq. number of the expected I PDU from the remote
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_i_cmd(struct sk_buff *skb, u8 p_bit, u8 ns, u8 nr)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_I;
+ 	pdu->ctrl_2 = 0;
+ 	pdu->ctrl_2 |= (p_bit & LLC_I_PF_BIT_MASK); /* p/f bit */
+ 	pdu->ctrl_1 |= ((ns << 1) & 0xFE);   /* set N(S) in bits 2..8 */
+ 	pdu->ctrl_2 |= ((nr << 1) & 0xFE);   /* set N(R) in bits 10..16 */
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_rej_cmd
+  *
+  * Description:
+  *  Builds a pdu frame as a REJ command.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  p_bit: The P bit to set in the PDU
+  *  nr: The seq. number of the expected I PDU from the remote
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_rej_cmd(struct sk_buff *skb, u8 p_bit, u8 nr)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+ 	pdu->ctrl_1 |= LLC_2_PDU_CMD_REJ;
+ 	pdu->ctrl_2 = 0;
+ 	pdu->ctrl_2 |= (p_bit & LLC_S_PF_BIT_MASK);
+ 	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+ 	pdu->ctrl_2 |= ((nr << 1)&0xFE); /* set N(R) in bits 10..16 */
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_rnr_cmd
+  *
+  * Description:
+  *  Builds a pdu frame as an RNR command.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  p_bit: The P bit to set in the PDU
+  *  nr: The seq. number of the expected I PDU from the remote
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_rnr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+ 	pdu->ctrl_1 |= LLC_2_PDU_CMD_RNR;
+ 	pdu->ctrl_2 = 0;
+ 	pdu->ctrl_2 |= (p_bit & LLC_S_PF_BIT_MASK);
+ 	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+ 	pdu->ctrl_2 |= ((nr << 1) & 0xFE); /* set N(R) in bits 10..16 */
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_rr_cmd
+  *
+  * Description:
+  *  Builds a pdu frame as an RR command.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  p_bit: The P bit to set in the PDU
+  *  nr: The seq. number of the expected I PDU from the remote
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_rr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+ 	pdu->ctrl_1 |= LLC_2_PDU_CMD_RR;
+ 	pdu->ctrl_2 = (p_bit & LLC_S_PF_BIT_MASK);
+ 	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+ 	pdu->ctrl_2 |= ((nr << 1) & 0xFE); /* set N(R) in bits 10..16 */
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_sabme_cmd
+  *
+  * Description:
+  *  Builds a pdu frame as an SABME command.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  p_bit: The P bit to set in the PDU
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_sabme_cmd(struct sk_buff *skb, u8 p_bit)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_2_PDU_CMD_SABME;
+ 	pdu->ctrl_1 |= (((p_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_dm_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as a DM response.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  f_bit: The F bit to set in the PDU
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_dm_rsp(struct sk_buff *skb, u8 f_bit)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_2_PDU_RSP_DM;
+ 	pdu->ctrl_1 |= (((f_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_xid_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as an XID response.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  svcs_supported: The class of the LLC (I or II)
+  *  rx_window: The size of the receive window of the LLC
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_xid_rsp(struct sk_buff *skb, u8 svcs_supported, u8 rx_window)
+ {
+ 	xid_info_t *xid_info;
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_1_PDU_CMD_XID;
+ 	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+ 
+ 	xid_info = (xid_info_t *)(((u8 *)&pdu->ctrl_1) + 1);
+ 	xid_info->fmt_id = XID_FMT_ID;
+ 	xid_info->type = svcs_supported;
+ 	xid_info->rw = rx_window << 1;
+ 	skb_put(skb, 3);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_test_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as a TEST response.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  ev_skb: The received TEST command PDU frame
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_test_rsp(struct sk_buff *skb, struct sk_buff *ev_skb)
+ {
+ 	u16 data_size = 0;
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
+ 	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+ 	if (ev_skb->protocol == ntohs(ETH_P_802_2)) {
+ 		data_size = ntohs(((ieee_802_3_mac_hdr_t *)
+ 					ev_skb->mac.raw)->lpdu_len) - 3;
+ 		memcpy(((u8 *)skb->nh.raw) + 3,
+ 		       ((u8 *)ev_skb->nh.raw) + 3, data_size);
+ 		skb_put(skb, data_size);
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_frmr_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as a FRMR response.
+  *
+  * Parameters:
+  *  pdu_frame: Address of the frame to build
+  *  prev_pdu: The rejected PDU frame
+  *  f_bit: The F bit to set in the PDU
+  *  vs: The current send state variable value for the
+  *	 data link connection at the rejecting LLC
+  *  vr: The current receive state variable value for the
+  *	 data link connection at the rejecting LLC
+  *  vzyxw: This field is completely described in the
+  *	    IEEE Std 802.2 document (Page 55)
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_frmr_rsp(struct sk_buff *skb, pdu_sn_t *prev_pdu, u8 f_bit,
+ 			 u8 vs, u8 vr, u8 vzyxw)
+ {
+ 	frmr_info_t *frmr_info;
+ 	u8 prev_pf = 0;
+ 	u8 *ctrl;
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_2_PDU_RSP_FRMR;
+ 	pdu->ctrl_1 |= ((f_bit & 1) << 4) & LLC_U_PF_BIT_MASK;
+ 
+ 	frmr_info = (frmr_info_t *)&pdu->ctrl_2;
+ 	ctrl = (u8 *)&prev_pdu->ctrl_1;
+ 	FRMR_INFO_SET_REJ_CNTRL(frmr_info,ctrl);
+ 	FRMR_INFO_SET_Vs(frmr_info, vs);
+ 	FRMR_INFO_SET_Vr(frmr_info, vr);
+ 	prev_pf = pdu_get_pf_bit(prev_pdu);
+ 	FRMR_INFO_SET_C_R_BIT(frmr_info, prev_pf);
+ 	FRMR_INFO_SET_INVALID_PDU_CTRL_IND(frmr_info, vzyxw);
+ 	FRMR_INFO_SET_INVALID_PDU_INFO_IND(frmr_info, vzyxw);
+ 	FRMR_INFO_SET_PDU_INFO_2LONG_IND(frmr_info, vzyxw);
+ 	FRMR_INFO_SET_PDU_INVALID_Nr_IND(frmr_info, vzyxw);
+ 	FRMR_INFO_SET_PDU_INVALID_Ns_IND(frmr_info, vzyxw);
+ 	skb_put(skb, 5);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_rr_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as an RR response.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  f_bit: The F bit to set in the PDU
+  *  nr: The seq. number of the expected data PDU from the remote
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_rr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+ 	pdu->ctrl_1 |= LLC_2_PDU_RSP_RR;
+ 	pdu->ctrl_2 = 0;
+ 	pdu->ctrl_2 |= (f_bit & LLC_S_PF_BIT_MASK);
+ 	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+ 	pdu->ctrl_2 |= ((nr << 1) & 0xFE);  /* set N(R) in bits 10..16 */
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_rej_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as a REJ response.
+  *
+  * Parameters:
+  *  skb: Address of the skb to build
+  *  f_bit: The F bit to set in the PDU
+  *  nr: The seq. number of the expected data PDU from the remote
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_rej_rsp(struct sk_buff *skb, u8 f_bit, u8 nr)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+ 	pdu->ctrl_1 |= LLC_2_PDU_RSP_REJ;
+ 	pdu->ctrl_2 = 0;
+ 	pdu->ctrl_2 |= (f_bit & LLC_S_PF_BIT_MASK);
+ 	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+ 	pdu->ctrl_2 |= ((nr << 1) & 0xFE);  /* set N(R) in bits 10..16 */
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_rnr_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as an RNR response.
+  *
+  * Parameters:
+  *  pdu_frame: Address of the frame to build
+  *  f_bit: The F bit to set in the PDU
+  *  nr: The seq. number of the expected data PDU from the remote
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_rnr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr)
+ {
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+ 	pdu->ctrl_1 |= LLC_2_PDU_RSP_RNR;
+ 	pdu->ctrl_2 = 0;
+ 	pdu->ctrl_2 |= (f_bit & LLC_S_PF_BIT_MASK);
+ 	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+ 	pdu->ctrl_2 |= ((nr << 1) & 0xFE);  /* set N(R) in bits 10..16 */
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_init_as_ua_rsp
+  *
+  * Description:
+  *  Builds a pdu frame as a UA response.
+  *
+  * Parameters:
+  *  skb: Address of the frame to build
+  *  f_bit: The F bit to set in the PDU
+  *
+  * Returns:
+  *  Always 0
+  */
+ u16 pdu_init_as_ua_rsp(struct sk_buff *skb, u8 f_bit)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+ 	pdu->ctrl_1 |= LLC_2_PDU_RSP_UA;
+ 	pdu->ctrl_1 |= (((f_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: pdu_decode_pdu_type
+  *
+  * Description:
+  *  This function designates type of PDU (I,S or U).
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb that type of it must be designated.
+  *  u8 *type: type of PDU ( output argument ).
+  *
+  * Returns:
+  *   Always 0.
+  */
+ static u16 pdu_decode_pdu_type(struct sk_buff *skb, u8 *type)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+ 
+ 	if (pdu->ctrl_1 & 1) {
+ 		if ((pdu->ctrl_1 & LLC_PDU_TYPE_U) == LLC_PDU_TYPE_U)
+ 			*type = LLC_PDU_TYPE_U;
+ 		else
+ 			*type = LLC_PDU_TYPE_S;
+ 	} else
+ 		*type = LLC_PDU_TYPE_I;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: decode_pdu_type
+  *
+  * Description:
+  *  This function designates which component of LLC must handle this PDU.
+  *
+  * Parameters:
+  *  struct sk_buff *skb: input skb.
+  *  u8 *destination: destination component.
+  *
+  * Returns:
+  *   Always 0.
+  */
+ u16 decode_pdu_type(struct sk_buff *skb, u8 *destination)
+ {
+ 	u8 type = P8022_DEST_CONN; /* I-PDU or S-PDU type */
+ 	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+ 
+ 	if ((pdu->ctrl_1 & LLC_PDU_TYPE_MASK) != LLC_PDU_TYPE_U)
+ 		goto out;
+ 	switch (LLC_U_PDU_CMD(pdu)) {
+ 		case LLC_1_PDU_CMD_XID:
+ 		case LLC_1_PDU_CMD_UI:
+ 		case LLC_1_PDU_CMD_TEST:
+ 			type = P8022_DEST_SAP;
+ 			break;
+ 		case LLC_2_PDU_CMD_SABME:
+ 		case LLC_2_PDU_CMD_DISC:
+ 		case LLC_2_PDU_RSP_UA:
+ 		case LLC_2_PDU_RSP_DM:
+ 		case LLC_2_PDU_RSP_FRMR:
+ 			break;
+ 		default:
+ 			type = P8022_DEST_INVALID;
+ 			break;
+ 	}
+ out:	*destination = type;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: get_llc_hdr_len
+  *
+  * Description:
+  *  This function designates LLC header length of PDU. header length for I and S
+  *  PDU is 4 and for U is 3 bytes.
+  *
+  * Parameters:
+  *  u8 pdu_type: type of PDU.
+  *
+  * Returns:
+  *  Length of header.
+  */
+ static int get_llc_hdr_length(u8 pdu_type)
+ {
+ 	int rtn_val = 0;
+ 
+ 	switch (pdu_type) {
+ 		case LLC_PDU_TYPE_I:
+ 		case LLC_PDU_TYPE_S:
+ 			rtn_val = 4;
+ 			break;
+ 		case LLC_PDU_TYPE_U:
+ 			rtn_val = 3;
+ 			break;
+ 	}
+ 	return rtn_val;
+ }
+ 
+ /*
+  * Function: pdu_get_pf_bit
+  *
+  * Description:
+  *  This function extracts p/f bit of input PDU. at first examines type of PDU
+  *  and then extracts p/f bit.
+  *
+  * Parameters:
+  *  pdu_sn_t *pdu: pointer to LLC header.
+  *
+  * Returns:
+  *  p/f bit.
+  */
+ static u8 pdu_get_pf_bit(pdu_sn_t *pdu)
+ {
+ 	u8 pdu_type;
+ 	u8 pf_bit;
+ 
+ 	if (pdu->ctrl_1 & 1) {
+ 		if ((pdu->ctrl_1 & LLC_PDU_TYPE_U) == LLC_PDU_TYPE_U)
+ 			pdu_type = LLC_PDU_TYPE_U;
+ 		else
+ 			pdu_type = LLC_PDU_TYPE_S;
+ 	} else
+ 		pdu_type = LLC_PDU_TYPE_I;
+ 	switch (pdu_type) {
+ 		case LLC_PDU_TYPE_I:
+ 		case LLC_PDU_TYPE_S:
+ 			pf_bit = pdu->ctrl_2 & LLC_S_PF_BIT_MASK;
+ 			break;
+ 		case LLC_PDU_TYPE_U:
+ 			pf_bit = (pdu->ctrl_1 & LLC_U_PF_BIT_MASK) >> 4;
+ 			break;
+ 		default:
+ 			pf_bit = 0;
+ 			break;
+ 	}
+ 	return pf_bit;
+ }
Index: kernel-acme/net/8022llc/llc_s_ac.c
diff -c /dev/null kernel-acme/net/8022llc/llc_s_ac.c:1.1.4.4
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_s_ac.c	Mon Aug 20 22:19:58 2001
***************
*** 0 ****
--- 1,229 ----
+ /*
+  * llc_s_ac.c - actions performed during sap state transition.
+  *
+  * Description :
+  *   Functions in this module are implementation of sap component actions.
+  *   Details of actions can be found in IEEE-802.2 standard document.
+  *   All functions have one sap and one event as input argument. All of
+  *   them return 0 On success and 1 otherwise.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netdevice.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_s_ev.h>
+ #include <net/llc_s_ac.h>
+ #include <net/llc_pdu.h>
+ #include <net/llc_mac.h>
+ 
+ /*
+  * Function: sap_action_unit_data_indication
+  *
+  * Description:
+  *  Received a UI PDU from MAC layer; forward to network layer as a
+  *  UNITDATA INDICATION; verify our event is the kind we expect
+  */
+ u16 sap_action_unitdata_indication(struct p8022_sap *sap,
+ 				   struct sap_state_event *event)
+ {
+ 	return sap_rtn_pdu(sap, event->data.pdu.skb, event);
+ }
+ 
+ /*
+  * Function: sap_action_send_ui
+  *
+  * Description:
+  *  Sends a UI PDU to the MAC layer in response to a UNITDATA REQUEST
+  *  primitive from the network layer. Verifies event is a primitive
+  *  type of event. Verify the primitive is a UNITDATA REQUEST.
+  */
+ u16 sap_action_send_ui(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	struct prim_if_block *prim = event->data.prim.data;
+ 	prim_unit_data_t *prim_data = &prim->data->udata;
+ 	struct sk_buff *skb = prim->data->udata.skb;
+ 	u16 rc = pdu_header_init(skb, LLC_PDU_TYPE_U,
+ 				 prim_data->source_addr.lsap,
+ 				 prim_data->dest_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto out;
+ 	rc = pdu_init_as_ui_cmd(skb);
+ 	if (rc)
+ 		goto out;
+ 	rc = lan_hdrs_init(skb, prim_data->source_addr.mac,
+ 			   prim_data->dest_addr.mac);
+ 	if (!rc)
+ 		rc = sap_send_pdu(sap, skb);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: sap_action_send_xid_c
+  *
+  * Description:
+  *  send a XID command PDU to MAC layer in response to a XID REQUEST
+  *  primitive from the network layer. Verify event is a primitive
+  *  type event. Verify the primitive is a XID REQUEST.
+  */
+ u16 sap_action_send_xid_c(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	struct prim_if_block *prim = event->data.prim.data;
+ 	prim_xid_t *prim_data = &prim->data->xid;
+ 	u16 rc = 1;
+         struct sk_buff *skb = frame_pdu_allocate();
+ 
+ 	if (rc)
+ 		goto out;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U,
+ 			     prim_data->source_addr.lsap,
+ 			     prim_data->dest_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto out;
+ 	rc = pdu_init_as_xid_cmd(skb, XID_NULL_CLASS_2, 0);
+ 	if (rc)
+ 		goto out;
+ 	rc = lan_hdrs_init(skb, prim_data->source_addr.mac,
+ 			   prim_data->dest_addr.mac);
+ 	if (!rc)
+ 		rc = sap_send_pdu(sap, skb);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: sap_action_send_xid_r
+  *
+  * Description:
+  *  send XID response PDU to MAC in response to an earlier received
+  *  XID command PDU. Verify event is a PDU type event
+  */
+ u16 sap_action_send_xid_r(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	u8 mac_da[MAC_ADDR_LEN], mac_sa[MAC_ADDR_LEN], dsap;
+ 	u16 rc = 1;
+ 	struct sk_buff *ev_skb = event->data.pdu.skb;
+ 	struct sk_buff *skb;
+ 
+ 	pdu_decode_sa(ev_skb, mac_da);
+ 	pdu_decode_da(ev_skb, mac_sa);
+ 	pdu_decode_ssap(ev_skb, &dsap);
+ 	skb = frame_pdu_allocate();
+ 	if (!skb)
+ 		goto out;
+ 	skb->dev = ev_skb->dev;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U,
+ 			     sap->local_dl_addr.lsap, dsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto out;
+ 	rc = pdu_init_as_xid_rsp(skb, XID_NULL_CLASS_2, 0);
+ 	if (rc)
+ 		goto out;
+ 	rc = lan_hdrs_init(skb, mac_sa, mac_da);
+ 	if (!rc)
+ 		rc = sap_send_pdu(sap, skb);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: sap_action_send_test_c
+  *
+  * Description:
+  *  Send a TEST command PDU to the MAC layer in response to a TEST
+  *  REQUEST primitive from the network layer. Verify event is a
+  *  primitive type event; verify the primitive is a TEST REQUEST.
+  */
+ u16 sap_action_send_test_c(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	struct prim_if_block *prim = event->data.prim.data;
+ 	prim_test_t *prim_data = &prim->data->test;
+ 	struct sk_buff *skb = prim_data->skb;
+ 	u16 rc = pdu_header_init(skb, LLC_PDU_TYPE_U,
+ 				 prim_data->source_addr.lsap,
+ 				 prim_data->dest_addr.lsap, LLC_PDU_CMD);
+ 	if (rc)
+ 		goto out;
+ 	rc = pdu_init_as_test_cmd(skb);
+ 	if (rc)
+ 		goto out;
+ 	rc = lan_hdrs_init(skb, prim_data->source_addr.mac,
+ 			   prim_data->dest_addr.mac);
+ 	if (!rc)
+ 		rc = sap_send_pdu(sap, skb);
+ out:	return rc;
+ }
+ 
+ u16 sap_action_send_test_r(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	u8 mac_da[MAC_ADDR_LEN], mac_sa[MAC_ADDR_LEN], dsap;
+ 	u16 rc = 1;
+ 	struct sk_buff *ev_skb = event->data.pdu.skb;
+ 	struct sk_buff *skb;
+ 
+ 	pdu_decode_sa(ev_skb, mac_da);
+ 	pdu_decode_da(ev_skb, mac_sa);
+ 	pdu_decode_ssap(ev_skb, &dsap);
+ 	skb = skb_clone(ev_skb, GFP_ATOMIC);
+ 	if (!skb)
+ 		goto out;
+ 	skb->dev = ev_skb->dev;
+ 	rc = pdu_header_init(skb, LLC_PDU_TYPE_U,
+ 			     sap->local_dl_addr.lsap, dsap, LLC_PDU_RSP);
+ 	if (rc)
+ 		goto out;
+ 	rc = pdu_init_as_test_rsp(skb, ev_skb);
+ 	if (rc)
+ 		goto out;
+ 	rc = lan_hdrs_init(skb, mac_sa, mac_da);
+ 	if (!rc)
+ 		rc = sap_send_pdu(sap, skb);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: sap_action_report_status
+  *
+  * Description:
+  *  Report data link status to layer management. Verify our event
+  *  is the kind we expect.
+  */
+ u16 sap_action_report_status(struct p8022_sap *sap,
+ 			     struct sap_state_event *event)
+ {
+ 	return 0;
+ }
+ 
+ /*
+  * Function: sap_action_xid_indication
+  *
+  * Description:
+  *  Send a XID response PDU to the network layer via a XID INDICATION
+  *  primitive.
+  */
+ u16 sap_action_xid_indication(struct p8022_sap *sap,
+ 			      struct sap_state_event *event)
+ {
+ 	return sap_rtn_pdu(sap, event->data.pdu.skb, event);
+ }
+ 
+ /*
+  * Function: sap_action_test_indication
+  *
+  * Description:
+  *  Send a TEST response PDU to the network layer via a TEST INDICATION
+  *  primitive. Verify our event is a PDU type event.
+  */
+ u16 sap_action_test_indication(struct p8022_sap *sap,
+ 			       struct sap_state_event *event)
+ {
+ 	return sap_rtn_pdu(sap, event->data.pdu.skb, event);
+ }
Index: kernel-acme/net/8022llc/llc_s_ev.c
diff -c /dev/null kernel-acme/net/8022llc/llc_s_ev.c:1.1.4.4
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_s_ev.c	Fri Aug 24 03:05:03 2001
***************
*** 0 ****
--- 1,106 ----
+ /*
+  * llc_s_ev.c - Defines SAP component events
+  *
+  * The followed event functions are SAP component events which are described
+  * in 802.2 LLC protocol standard document.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/skbuff.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_s_ev.h>
+ #include <net/llc_s_ac.h>
+ #include <net/llc_pdu.h>
+ 
+ u16 sap_ev_activation_request(struct p8022_sap *sap,
+ 			      struct sap_state_event *event)
+ {
+ 	return event->type == SAP_EV_TYPE_SIMPLE &&
+ 	       event->data.a.event == SAP_EV_ACTIVATION_REQUEST ? 0 : 1;
+ }
+ 
+ u16 sap_ev_rx_ui(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == SAP_EV_TYPE_PDU && !LLC_PDU_IS_CMD(pdu) &&
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_UI ? 0 : 1;
+ }
+ 
+ u16 sap_ev_unitdata_request(struct p8022_sap *sap,
+ 			    struct sap_state_event *event)
+ {
+ 	return event->type == SAP_EV_TYPE_PRIM &&
+ 	       event->data.prim.prim == P8022_DATAUNIT_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ 
+ }
+ 
+ u16 sap_ev_xid_request(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	return event->type == SAP_EV_TYPE_PRIM &&
+ 	       event->data.prim.prim == P8022_XID_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ }
+ 
+ u16 sap_ev_rx_xid_c(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == SAP_EV_TYPE_PDU && !LLC_PDU_IS_CMD(pdu) &&
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_XID ? 0 : 1;
+ }
+ 
+ u16 sap_ev_rx_xid_r(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == SAP_EV_TYPE_PDU && !LLC_PDU_IS_RSP(pdu) &&
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID ? 0 : 1;
+ }
+ 
+ u16 sap_ev_test_request(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	return event->type == SAP_EV_TYPE_PRIM &&
+ 	       event->data.prim.prim == P8022_TEST_PRIM &&
+ 	       event->data.prim.type == P8022_PRIM_TYPE_REQUEST ? 0 : 1;
+ }
+ 
+ u16 sap_ev_rx_test_c(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == SAP_EV_TYPE_PDU && !LLC_PDU_IS_CMD(pdu) &&
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_TEST ? 0 : 1;
+ }
+ 
+ u16 sap_ev_rx_test_r(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 	return event->type == SAP_EV_TYPE_PDU && !LLC_PDU_IS_RSP(pdu) &&
+ 	       !LLC_PDU_TYPE_IS_U(pdu) &&
+ 	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_TEST ? 0 : 1;
+ }
+ 
+ u16 sap_ev_deactivation_request(struct p8022_sap *sap,
+ 				struct sap_state_event *event)
+ {
+ 	return event->type == SAP_EV_TYPE_SIMPLE &&
+ 	       event->data.a.event == SAP_EV_DEACTIVATION_REQUEST ? 0 : 1;
+ }
Index: kernel-acme/net/8022llc/llc_s_st.c
diff -c /dev/null kernel-acme/net/8022llc/llc_s_st.c:1.1.4.4
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_s_st.c	Mon Aug 20 22:19:58 2001
***************
*** 0 ****
--- 1,167 ----
+ /*
+  * llc_s_st.c - Defines SAP component state machine transitions.
+  *
+  * The followed transitions are SAP component state machine transitions
+  * which are described in 802.2 LLC protocol standard document.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/types.h>
+ #include <linux/skbuff.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_s_ev.h>
+ #include <net/llc_s_ac.h>
+ #include <net/llc_s_st.h>
+ 
+ /* dummy last-transition indicator; common to all state transition groups */
+ static sap_state_transition_t sap_state_transition_n = {
+ 	NULL, 0, NULL	/* last entry for this state */
+ };
+ 
+ /* state SAP_STATE_INACTIVE transition for SAP_EV_ACTIVATION_REQUEST event */
+ static sap_action_t sap_inactive_state_actions_1[] = {
+ 	sap_action_report_status,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_inactive_state_transition_1 = {
+ 	sap_ev_activation_request,	SAP_STATE_ACTIVE,
+ 					sap_inactive_state_actions_1
+ };
+ 
+ /* array of pointers; one to each transition */
+ static sap_state_transition_t *sap_inactive_state_transitions[] = {
+ 	&sap_inactive_state_transition_1,
+ 	&sap_state_transition_n
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_RX_UI event */
+ static sap_action_t sap_active_state_actions_1[] = {
+ 	sap_action_unitdata_indication,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_1 = {
+ 	sap_ev_rx_ui,			SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_1
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_UNITDATA_REQUEST event */
+ static sap_action_t sap_active_state_actions_2[] = {
+ 	sap_action_send_ui,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_2 = {
+ 	sap_ev_unitdata_request,	SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_2
+ };
+ 
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_XID_REQUEST event */
+ static sap_action_t sap_active_state_actions_3[] = {
+ 	sap_action_send_xid_c,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_3 = {
+ 	sap_ev_xid_request,		SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_3
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_RX_XID_C event */
+ static sap_action_t sap_active_state_actions_4[] = {
+ 	sap_action_send_xid_r,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_4 = {
+ 	sap_ev_rx_xid_c,		SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_4
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_RX_XID_R event */
+ static sap_action_t sap_active_state_actions_5[] = {
+ 	sap_action_xid_indication,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_5 = {
+ 	sap_ev_rx_xid_r,		SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_5
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_TEST_REQUEST event */
+ static sap_action_t sap_active_state_actions_6[] = {
+ 	sap_action_send_test_c,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_6 = {
+ 	sap_ev_test_request,		SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_6
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_RX_TEST_C event */
+ static sap_action_t sap_active_state_actions_7[] = {
+ 	sap_action_send_test_r,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_7 = {
+ 	sap_ev_rx_test_c,		SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_7
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_RX_TEST_R event */
+ static sap_action_t sap_active_state_actions_8[] = {
+ 	sap_action_test_indication,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_8 = {
+ 	sap_ev_rx_test_r,		SAP_STATE_ACTIVE,
+ 					sap_active_state_actions_8
+ };
+ 
+ /* state SAP_STATE_ACTIVE transition for SAP_EV_DEACTIVATION_REQUEST event */
+ static sap_action_t sap_active_state_actions_9[] = {
+ 	sap_action_report_status,
+ 	NULL
+ };
+ 
+ static sap_state_transition_t sap_active_state_transition_9 = {
+ 	sap_ev_deactivation_request,	SAP_STATE_INACTIVE,
+ 					sap_active_state_actions_9
+ };
+ 
+ /* array of pointers; one to each transition */
+ static sap_state_transition_t *sap_active_state_transitions[] = {
+ 	&sap_active_state_transition_2,
+ 	&sap_active_state_transition_1,
+ 	&sap_active_state_transition_3,
+ 	&sap_active_state_transition_4,
+ 	&sap_active_state_transition_5,
+ 	&sap_active_state_transition_6,
+ 	&sap_active_state_transition_7,
+ 	&sap_active_state_transition_8,
+ 	&sap_active_state_transition_9,
+ 	&sap_state_transition_n
+ };
+ 
+ /* SAP state transition table */
+ sap_state_t Sap_state_table[] = {
+ 	{ SAP_STATE_INACTIVE,		sap_inactive_state_transitions  },
+ 	{ SAP_STATE_ACTIVE,		sap_active_state_transitions    }
+ };
Index: kernel-acme/net/8022llc/llc_sap.c
diff -c /dev/null kernel-acme/net/8022llc/llc_sap.c:1.1.4.10
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_sap.c	Thu Aug 30 03:58:33 2001
***************
*** 0 ****
--- 1,371 ----
+ /*
+  * llc_sap.c - driver routines for SAP component.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <asm/byteorder.h>
+ #include <linux/netdevice.h>
+ #include <linux/slab.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_s_ev.h>
+ #include <net/llc_s_ac.h>
+ #include <net/llc_s_st.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_mac.h>
+ #include <net/llc_pdu.h>
+ 
+ static void sap_rtn_event(struct p8022_sap *sap, struct sap_state_event *event);
+ static u16 sap_next_state(struct p8022_sap *sap, struct sap_state_event *event);
+ static u16 execute_sap_transition_actions(struct p8022_sap *sap,
+ 					  sap_state_transition_t *transition,
+ 					  struct sap_state_event *event);
+ static sap_state_transition_t *find_sap_transition(struct p8022_sap *sap,
+ 						 struct sap_state_event *event);
+ 
+ /*
+  * Function : sap_assign_conn
+  *
+  * Description :
+  *  this function adds a connection to connection_list of a SAP.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  struct p8022_connection *connection : pointer to connection.
+  *
+  * Returns :
+  *  None
+  */
+ void sap_assign_conn(struct p8022_sap *sap, struct p8022_connection *conn)
+ {
+ 	spin_lock_bh(&sap->connection_list.lock);
+ 	conn->parent_sap = sap;
+ 	list_add_tail(&conn->node, &sap->connection_list.list);
+ 	spin_unlock_bh(&sap->connection_list.lock);
+ }
+ 
+ /*
+  * Function : sap_unassign_conn
+  *
+  * Description :
+  *  this function removes a connection from connection_list of a SAP.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  struct p8022_connection *connection : pointer to connection.
+  *
+  * Returns :
+  *  None
+  */
+ void sap_unassign_conn(struct p8022_sap *sap, struct p8022_connection *conn)
+ {
+ 	spin_lock_bh(&sap->connection_list.lock);
+ 	list_del(&conn->node);
+ 	spin_unlock_bh(&sap->connection_list.lock);
+ }
+ 
+ /*
+  * Function : sap_get_event
+  *
+  * Description :
+  *  this function removes an event from event pool of SAP and returns it.
+  *  each SAP has 5 events and use them during execution.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  void **event : allocated event (output argument).
+  *
+  * Returns :
+  *  0 : succes.
+  *  1 : failure.
+  */
+ struct sap_state_event *sap_get_event(struct p8022_sap *sap)
+ {
+ 	struct sap_state_event *event = kmalloc(sizeof(*event), GFP_ATOMIC);
+ 
+         if (event)
+ 		memset(event, 0, sizeof(*event));
+ 	return event;
+ }
+ 
+ /*
+  * Function : sap_send_event
+  *
+  * Description :
+  *  this function sends an event to SAP state machine. after executing actions
+  *  of the event, upper layer will be indicated if needed(on receiving an
+  *  UI frame).
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  void *event : pointer to occurred event.
+  *
+  * Returns :
+  *  Always 0.
+  */
+ u16 sap_send_event(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	struct prim_if_block *prim;
+ 	u8 flag;
+ 
+ 	sap_next_state(sap, event);
+ 	flag = event->ind_cfm_flag;
+ 	prim = event->prim;
+ 	if (flag == P8022_INDICATE) {
+ 		skb_get(event->data.pdu.skb);
+ 		sap->indicate(prim);
+ 	}
+ 	sap_rtn_event(sap, event);
+ 	return 0;
+ }
+ 
+ /*
+  * Function : sap_rtn_pdu
+  *
+  * Description :
+  *  This function informs upper layer on receiving an UI, XID or TEST pdu.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  struct sk_buff *skb : received pdu.
+  *  void *event : pointer to occurred event.
+  *
+  * Returns :
+  *  Always 0.
+  */
+ u16 sap_rtn_pdu(struct p8022_sap *sap, struct sk_buff *skb,
+ 		struct sap_state_event *event)
+ {
+ 	pdu_un_t *pdu;
+ 	struct prim_if_block *prim = &Ind_prim;
+ 	prim_data_u *prim_data = Ind_prim.data;
+ 	u8 lfb;
+ 
+ 	pdu_decode_sa(skb, prim_data->udata.source_addr.mac);
+ 	pdu_decode_da(skb, prim_data->udata.dest_addr.mac);
+ 	pdu_decode_dsap(skb, &prim_data->udata.dest_addr.lsap);
+ 	pdu_decode_ssap(skb, &prim_data->udata.source_addr.lsap);
+ 	prim_data->udata.priority = 0;
+ 	prim_data->udata.skb = skb;
+ 	pdu = (pdu_un_t *)skb->nh.raw;
+ 	switch (LLC_U_PDU_RSP(pdu)) {
+ 		case LLC_1_PDU_CMD_TEST:
+ 			prim->primitive = P8022_TEST_PRIM;
+ 			break;
+ 		case LLC_1_PDU_CMD_XID:
+ 			prim->primitive = P8022_XID_PRIM;
+ 			break;
+ 		case LLC_1_PDU_CMD_UI:
+ 			if (skb->protocol == ntohs(ETH_P_TR_802_2)) {
+ 				if (((token_ring_mac_hdr_t *)skb->mac.raw)->rcf) {
+ 					lfb = ntohs(((token_ring_mac_hdr_t *)
+ 						    skb->mac.raw)->rcf) &
+ 						    0x0070;
+ 					prim_data->udata.lfb = lfb >> 4;
+ 				} else {
+ 					lfb = 0xFF;
+ 					prim_data->udata.lfb = 0xFF;
+ 				}
+ 			}
+ 			prim->primitive = P8022_DATAUNIT_PRIM;
+ 			break;
+ 	}
+ 	prim->data = prim_data;
+ 	prim->sap = sap;
+ 	event->ind_cfm_flag = P8022_INDICATE;
+ 	event->prim = prim;
+ 	return 0;
+ }
+ 
+ /*
+  * Function : sap_send_pdu
+  *
+  * Description :
+  *  This function sends a frame to MAC layer for transmition.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  struct sk_buff *skb : pdu that must be sent.
+  *
+  * Returns :
+  *  Always 0.
+  */
+ u16 sap_send_pdu(struct p8022_sap *sap, struct sk_buff *skb)
+ {
+ 	mac_send_pdu(skb);
+ 	kfree_skb(skb);
+ 	return 0;
+ }
+ 
+ /*
+  * Function : sap_find_conn
+  *
+  * Description :
+  *  This function searches connection list of a SAP and finds a connection
+  *  by given address.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  address_t *remote_addr : MAC address of remote machine (base of search).
+  *  void **conn_ptr : pointer to found connection (output argument).
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ struct p8022_connection *sap_find_conn(struct p8022_sap *sap,
+ 				       address_t *remote_addr)
+ {
+ 	/* search for the corresponding active connection */
+ 	struct p8022_connection *conn;
+ 	struct list_head *entry;
+ 
+ 	spin_lock_bh(&sap->connection_list.lock);
+ 	list_for_each(entry, &sap->connection_list.list) {
+ 		conn = list_entry(entry, struct p8022_connection, node);
+ 		if (!memcmp(conn->remote_dl_addr.mac, remote_addr->mac,
+ 		    MAC_ADDR_LEN))
+ 			break;
+ 	}
+ 	if (entry == &sap->connection_list.list) /* didn't found it */
+ 		conn = NULL;
+ 	spin_unlock_bh(&sap->connection_list.lock);
+ 	return conn;
+ }
+ 
+ /*
+  * Function : sap_rtn_event
+  *
+  * Description :
+  *  This function frees an sap event
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  struct sap_state_event *event : released event.
+  *
+  * Returns :
+  *  None
+  */
+ static void sap_rtn_event(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	if (event->type == SAP_EV_TYPE_PDU) {
+ 		pdu_un_t *pdu = (pdu_un_t *)event->data.pdu.skb->nh.raw;
+ 
+ 		if (LLC_U_PDU_CMD(pdu) != LLC_1_PDU_CMD_UI)
+ 			kfree_skb(event->data.pdu.skb);
+ 	}
+ 	kfree(event);
+ }
+ 
+ /*
+  * Function : sap_next_state
+  *
+  * Description :
+  *  This function finds transition that matches with happened event, then
+  *  executes related actions and finally changes state of SAP.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  struct sap_state_event *event : happened event.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure.
+  */
+ static u16 sap_next_state(struct p8022_sap *sap, struct sap_state_event *event)
+ {
+ 	u16 rc = 1;
+ 	sap_state_transition_t *transition;
+ 
+ 	if (sap->state <= NBR_SAP_STATES) {
+ 		transition = find_sap_transition(sap, event);
+ 		if (transition) {
+ 			/*
+ 			 * got the state to which we next transition; perform
+ 			 * the actions associated with this transition before
+ 			 * actually transitioning to the next state
+ 			 */
+ 			rc = execute_sap_transition_actions(sap, transition,
+ 							    event);
+ 			if (!rc)
+                			/* transition SAP to next state if all actions
+                			   execute successfully */
+ 				sap->state = transition->next_state;
+ 		}
+ 	}
+ 	return rc;
+ }
+ 
+ /*
+  * Function : find_sap_transition
+  *
+  * Description :
+  *  This function finds transition that matches with happened event.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  struct sap_state_event *event : happened event.
+  *
+  * Returns :
+  *  pointer to found transition : success.
+  *  NULL : failure.
+  *
+  */
+ static sap_state_transition_t *find_sap_transition(struct p8022_sap *sap,
+ 						  struct sap_state_event* event)
+ {
+ 	u16 i;
+ 	sap_state_transition_t **next_transition;
+ 	sap_state_t *curr_state = &Sap_state_table[sap->state - 1];
+ 	/*
+ 	 * search thru events for this state until list exhausted
+ 	 * or until its obvious the event is not valid for the current state
+ 	 */
+ 	for (i = 0, next_transition = curr_state->transitions;
+ 	     next_transition [i]->event; i++)
+ 		if (!next_transition[i]->event(sap, event))
+ 			/* got event match; return it */
+ 			return next_transition[i];
+ 	return NULL;
+ }
+ 
+ /*
+  * Function : execute_sap_transition_actions
+  *
+  * Description :
+  *  This function executes actions that is related to happened event.
+  *
+  * Parameters :
+  *  struct p8022_sap *sap : pointer to SAP.
+  *  sap_state_transition_t *transition : pointer to transition that it's
+  *  actions must be performed.
+  *  struct sap_state_event *event : happened event.
+  *
+  * Returns :
+  *  0 : success.
+  *  1 : failure of at least one action.
+  *
+  */
+ static u16 execute_sap_transition_actions(struct p8022_sap *sap,
+ 					  sap_state_transition_t *transition,
+ 					  struct sap_state_event *event)
+ {
+ 	u16 rc = 0;
+ 	sap_action_t *next_action;
+ 
+ 	for (next_action = transition->event_actions;
+ 	     next_action && *next_action; next_action++)
+ 		if ((*next_action)(sap, event))
+ 			rc = 1;
+ 
+ 	return rc;
+ }
Index: kernel-acme/net/8022llc/llc_stat.c
diff -c /dev/null kernel-acme/net/8022llc/llc_stat.c:1.1.4.4
*** /dev/null	Wed Sep  5 00:22:28 2001
--- kernel-acme/net/8022llc/llc_stat.c	Mon Aug 20 22:19:58 2001
***************
*** 0 ****
--- 1,209 ----
+ /*
+  * llc_stat.c - Implementation of LLC station component state machine
+  * 		transitions
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/skbuff.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <net/llc_conn.h>
+ #include <net/llc_main.h>
+ #include <net/llc_evnt.h>
+ #include <net/llc_actn.h>
+ #include <net/llc_stat.h>
+ 
+ /* ------------------- COMMON STATION STATE transitions ------------------ */
+ 
+ /* dummy last-transition indicator; common to all state transition groups */
+ static station_state_transition_t stat_state_transition_n = {
+ 	NULL, 0, NULL			/* last entry for this state */
+ };
+ 
+ /* ------------------------ DOWN STATE transitions ----------------------- */
+ 
+ /* state transition for STATION_EV_ENABLE_WITH_DUP_ADDR_CHECK event */
+ static station_action_t	stat_down_state_actions_1[] = {
+ 	station_ac_start_ack_timer,
+ 	station_ac_set_retry_count_0,
+ 	station_ac_set_xid_r_count_0,
+ 	station_ac_send_null_dsap_xid_c,
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_down_state_transition_1 = {
+ 	stat_ev_enable_with_dup_addr_check,
+ 					STATION_STATE_DUP_ADDR_CHK,
+ 					stat_down_state_actions_1
+ };
+ 
+ /* state transition for STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK event */
+ static station_action_t	stat_down_state_actions_2[] = {
+ 	station_ac_report_status,	/* STATION UP */
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_down_state_transition_2 = {
+ 	stat_ev_enable_without_dup_addr_check,
+ 					STATION_STATE_UP,
+ 					stat_down_state_actions_2
+ };
+ 
+ /* array of pointers; one to each transition */
+ static station_state_transition_t *stat_dwn_state_transitions[] = {
+ 	&stat_down_state_transition_1,
+ 	&stat_down_state_transition_2,
+ 	&stat_state_transition_n
+ };
+ 
+ /* ------------------------- UP STATE transitions ------------------------ */
+ /* state transition for STATION_EV_DISABLE_REQUEST event */
+ static station_action_t	stat_up_state_actions_1[] = {
+ 	station_ac_report_status,	/* STATION DOWN */
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_up_state_transition_1 = {
+ 	stat_ev_disable_request,	STATION_STATE_DOWN,
+ 					stat_up_state_actions_1
+ };
+ 
+ /* state transition for STATION_EV_RX_NULL_DSAP_XID_C event */
+ static station_action_t	stat_up_state_actions_2[] = {
+ 	station_ac_send_xid_r,
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_up_state_transition_2 = {
+ 	stat_ev_rx_null_dsap_xid_c,	STATION_STATE_UP,
+ 					stat_up_state_actions_2
+ };
+ 
+ /* state transition for STATION_EV_RX_NULL_DSAP_TEST_C event */
+ static station_action_t	stat_up_state_actions_3[] = {
+ 	station_ac_send_test_r,
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_up_state_transition_3 = {
+ 	stat_ev_rx_null_dsap_test_c,	STATION_STATE_UP,
+ 					stat_up_state_actions_3
+ };
+ 
+ /* array of pointers; one to each transition */
+ static station_state_transition_t *stat_up_state_transitions [] = {
+ 	&stat_up_state_transition_1,
+ 	&stat_up_state_transition_2,
+ 	&stat_up_state_transition_3,
+ 	&stat_state_transition_n
+ };
+ 
+ /* ---------------------- DUP ADDR CHK STATE transitions ----------------- */
+ /*
+  * state transition for STATION_EV_RX_NULL_DSAP_0_XID_R_XID_R_COUNT_EQ
+  * event
+  */
+ static station_action_t	stat_dupaddr_state_actions_1[] = {
+ 	station_ac_increment_xid_r_count_by_1,
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_dupaddr_state_transition_1 = {
+ 	stat_ev_rx_null_dsap_0_xid_r_xid_r_count_eq,
+ 					STATION_STATE_DUP_ADDR_CHK,
+ 					stat_dupaddr_state_actions_1
+ };
+ 
+ /*
+  * state transition for STATION_EV_RX_NULL_DSAP_1_XID_R_XID_R_COUNT_EQ
+  * event
+  */
+ static station_action_t	stat_dupaddr_state_actions_2[] = {
+ 	station_ac_report_status,	/* DUPLICATE ADDRESS FOUND */
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_dupaddr_state_transition_2 = {
+ 	stat_ev_rx_null_dsap_1_xid_r_xid_r_count_eq,
+ 					STATION_STATE_DOWN,
+ 					stat_dupaddr_state_actions_2
+ };
+ 
+ /* state transition for STATION_EV_RX_NULL_DSAP_XID_C event */
+ static station_action_t	stat_dupaddr_state_actions_3[] = {
+ 	station_ac_send_xid_r,
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_dupaddr_state_transition_3 = {
+ 	stat_ev_rx_null_dsap_xid_c,	STATION_STATE_DUP_ADDR_CHK,
+ 					stat_dupaddr_state_actions_3
+ };
+ 
+ /*
+  * state transition for STATION_EV_ACK_TIMER_EXPIRED_LT_RETRY_COUNT_MAX_RETRY
+  * event
+  */
+ static station_action_t	stat_dupaddr_state_actions_4[] = {
+ 	station_ac_start_ack_timer,
+ 	station_ac_increment_retry_count_by_1,
+ 	station_ac_set_xid_r_count_0,
+ 	station_ac_send_null_dsap_xid_c,
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_dupaddr_state_transition_4 = {
+ 	stat_ev_ack_timer_expired_lt_retry_count_max_retry,
+ 					STATION_STATE_DUP_ADDR_CHK,
+ 					stat_dupaddr_state_actions_4
+ };
+ 
+ /*
+  * state transition for STATION_EV_ACK_TIMER_EXPIRED_EQ_RETRY_COUNT_MAX_RETRY
+  * event
+  */
+ static station_action_t	stat_dupaddr_state_actions_5[] = {
+ 	station_ac_report_status,	/* STATION UP */
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_dupaddr_state_transition_5 = {
+ 	stat_ev_ack_timer_expired_eq_retry_count_max_retry,
+ 					STATION_STATE_UP,
+ 					stat_dupaddr_state_actions_5
+ };
+ 
+ /* state transition for STATION_EV_DISABLE_REQUEST event */
+ static station_action_t	stat_dupaddr_state_actions_6[] = {
+ 	station_ac_report_status,	/* STATION DOWN */
+ 	NULL
+ };
+ 
+ static station_state_transition_t stat_dupaddr_state_transition_6 = {
+ 	stat_ev_disable_request,	STATION_STATE_DOWN,
+ 					stat_dupaddr_state_actions_6
+ };
+ 
+ /* array of pointers; one to each transition */
+ static station_state_transition_t *stat_dupaddr_state_transitions[] = {
+ 	&stat_dupaddr_state_transition_6,	// Request
+ 	&stat_dupaddr_state_transition_4,	// Timer
+ 	&stat_dupaddr_state_transition_5,
+ 	&stat_dupaddr_state_transition_1,	// Receive frame
+ 	&stat_dupaddr_state_transition_2,
+ 	&stat_dupaddr_state_transition_3,
+ 	&stat_state_transition_n
+ };
+ 
+ station_state_t	Station_state_table[NBR_STATION_STATES] = {
+ 	{ STATION_STATE_DOWN,		stat_dwn_state_transitions        },
+ 	{ STATION_STATE_DUP_ADDR_CHK,	stat_dupaddr_state_transitions    },
+ 	{ STATION_STATE_UP,		stat_up_state_transitions         }
+ };
Index: kernel-acme/net/core/Makefile
diff -c kernel-acme/net/core/Makefile:1.1.1.1 kernel-acme/net/core/Makefile:1.1.1.1.4.1
*** kernel-acme/net/core/Makefile:1.1.1.1	Tue Jun 26 14:28:56 2001
--- kernel-acme/net/core/Makefile	Thu Aug 16 22:26:36 2001
***************
*** 9,15 ****
  
  O_TARGET := core.o
  
! export-objs := netfilter.o profile.o
  
  obj-y := sock.o skbuff.o iovec.o datagram.o scm.o
  
--- 9,15 ----
  
  O_TARGET := core.o
  
! export-objs := ext8022.o netfilter.o profile.o
  
  obj-y := sock.o skbuff.o iovec.o datagram.o scm.o
  
***************
*** 21,33 ****
  
  obj-$(CONFIG_FILTER) += filter.o
  
! obj-$(CONFIG_NET) += dev.o dev_mcast.o dst.o neighbour.o rtnetlink.o utils.o
  
  obj-$(CONFIG_NETFILTER) += netfilter.o
  obj-$(CONFIG_NET_DIVERT) += dv.o
  obj-$(CONFIG_NET_PROFILE) += profile.o
  
  include $(TOPDIR)/Rules.make
- 
- tar:
- 		tar -cvf /dev/f1 .
--- 21,30 ----
  
  obj-$(CONFIG_FILTER) += filter.o
  
! obj-$(CONFIG_NET) += ext8022.o dev.o dev_mcast.o dst.o neighbour.o rtnetlink.o utils.o
  
  obj-$(CONFIG_NETFILTER) += netfilter.o
  obj-$(CONFIG_NET_DIVERT) += dv.o
  obj-$(CONFIG_NET_PROFILE) += profile.o
  
  include $(TOPDIR)/Rules.make
Index: kernel-acme/net/core/ext8022.c
diff -c /dev/null kernel-acme/net/core/ext8022.c:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:37 2001
--- kernel-acme/net/core/ext8022.c	Wed Aug 22 16:21:39 2001
***************
*** 0 ****
--- 1,76 ----
+ /*
+  * (ext8022.c)
+  * 
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the 
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/config.h>
+ #include <linux/module.h>
+ #include <linux/netdevice.h>
+ #include <linux/brlock.h>
+ 
+ typedef int (*func_type)(struct sk_buff *, struct net_device *,
+ 			 struct packet_type *);
+ static int P8022_rcv(struct sk_buff *, struct net_device *,
+ 		     struct packet_type *);
+ 
+ static func_type sap_table[128];
+ static int p8022_users;
+ 
+ static struct packet_type p8022_packet_type = {
+ 	type:	__constant_htons(ETH_P_802_2),
+ 	func:	P8022_rcv,
+ };
+ static struct packet_type p8022tr_packet_type = {
+ 	type:	__constant_htons(ETH_P_TR_802_2),
+ 	func:	P8022_rcv,
+ };
+ 
+ static int P8022_rcv(struct sk_buff *skb, struct net_device *dev,
+ 			struct packet_type *pt)
+ {
+  	unsigned char n = (*(skb->h.raw)) >> 1;
+ 
+ 	br_read_lock(BR_8022_LOCK);
+ 	if (sap_table[n])
+             sap_table[n](skb, dev, pt);
+         else
+             kfree_skb(skb);
+ 	br_read_unlock(BR_8022_LOCK);
+         return 0;
+ }
+ 
+ void P8022_register_sap(unsigned char sap, func_type rcvfunc)
+ {
+ 	sap >>= 1;
+ 	br_write_lock_bh(BR_8022_LOCK);
+ 	sap_table[sap] = rcvfunc;            
+ 	if (!p8022_users) {
+ 		dev_add_pack(&p8022_packet_type);
+ 		dev_add_pack(&p8022tr_packet_type);
+         }
+ 	p8022_users++;
+ 	br_write_unlock_bh(BR_8022_LOCK);
+ }
+ 
+ void P8022_unregister_sap(unsigned char sap)
+ {
+ 	sap >>= 1;
+ 	br_write_lock_bh(BR_8022_LOCK);
+         sap_table[sap] = NULL;
+ 	if (!--p8022_users) {
+ 		dev_remove_pack(&p8022_packet_type);
+ 		dev_remove_pack(&p8022tr_packet_type);
+         } 
+ 	br_write_unlock_bh(BR_8022_LOCK);
+ }
+ 
+ EXPORT_SYMBOL(P8022_register_sap);
+ EXPORT_SYMBOL(P8022_unregister_sap);
Index: kernel-acme/net/core/iovec.c
diff -c kernel-acme/net/core/iovec.c:1.1.1.2 kernel-acme/net/core/iovec.c:1.1.1.2.2.1
*** kernel-acme/net/core/iovec.c:1.1.1.2	Thu Aug 16 19:19:59 2001
--- kernel-acme/net/core/iovec.c	Thu Aug 16 22:26:36 2001
***************
*** 157,163 ****
  
  
  /*
!  *	For use with ip_build_xmit
   */
  
  int memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov, int offset,
--- 157,163 ----
  
  
  /*
!  *	For use with ip_build_xmit, and by the netbeui stack
   */
  
  int memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov, int offset,
Index: kernel-acme/net/netbeui/Makefile
diff -c /dev/null kernel-acme/net/netbeui/Makefile:1.1.4.2
*** /dev/null	Wed Sep  5 00:22:38 2001
--- kernel-acme/net/netbeui/Makefile	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,22 ----
+ #
+ # Makefile for the Linux NETBEUI layer.
+ #
+ # Note! Dependencies are done automagically by 'make dep', which also
+ # removes any old dependencies. DON'T put your own dependencies here
+ # unless it's something special (ie not a .c file).
+ #
+ # Note 2! The CFLAGS definition is now in the main makefile...
+ 
+ # We only get in/to here if CONFIG_NETBEUI = 'y' or 'm'
+ 
+ O_TARGET := netbeui.o
+ 
+ obj-y	:= af_netb.o config.o dextab.o dgram_serve.o llc_supp.o \
+ 	   name_serve.o nb_common.o proc.o query_serve.o session_serve.o \
+ 	   sock_dgram.o sock_name.o sock_session.o status_serve.o
+ 
+ ifeq ($(CONFIG_NETBEUI),m)
+   obj-m += $(O_TARGET)
+ endif
+ 
+ include $(TOPDIR)/Rules.make
Index: kernel-acme/net/netbeui/af_netb.c
diff -c /dev/null kernel-acme/net/netbeui/af_netb.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:38 2001
--- kernel-acme/net/netbeui/af_netb.c	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,132 ----
+ /*
+  * af_netb.c - Contains functions that supply socket system calls for NetBEUI
+  *             protocol stack which their names has a 'netbeui_' prefix, and
+  *             also some utility functions that their names has a 'nbso_'
+  *             prefix.
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/module.h>
+ #include <linux/net.h>
+ #include <linux/sched.h>
+ #include <linux/wait.h>
+ #include <linux/fs.h>
+ #include <linux/slab.h>
+ #include <linux/string.h>
+ #include <linux/kernel.h>
+ #include <linux/types.h>
+ #include <linux/uio.h>
+ #include <linux/skbuff.h>
+ #include <linux/netbeui.h>
+ #include <net/sock.h>
+ 
+ extern struct proto_ops nbso_name_proto_ops;
+ extern struct proto_ops nbso_dgram_proto_ops;
+ extern struct proto_ops nbso_session_proto_ops;
+ 
+ /* Socket System Calls */
+ /*
+  * Function: netbeui_create
+  *	Creates a NetBEUI socket.
+  *
+  * Parameters:
+  *	sock     : pointer to 'struct socket' that created by system before
+  *	           call this function.
+  *	protocol : an integer that have protocol specific meaning and we
+  *	           do not use it.
+  *
+  * Returns: int
+  *	0        : if socket has been created successfully.
+  *	negative : if a fault occurs.
+  *                  -ESOCKTNOSUPPORT : Specified socket type NOT supported.
+  *                  -ENOMEM          : Out of memory condition.
+  */
+ static int netbeui_create(struct socket *sock, int protocol)
+ {
+ 	struct proto_ops *prot;
+ 	struct sock *sk;
+ 	int rc = 0;
+ 
+ 	MOD_INC_USE_COUNT;
+ 	switch (sock->type) {
+ 		case SOCK_STREAM:
+ 			prot = &nbso_session_proto_ops;
+ 			break;
+ 		case SOCK_DGRAM:
+ 			prot = &nbso_dgram_proto_ops;
+ 			break;
+ 		case SOCK_RAW:
+ 			prot = &nbso_name_proto_ops;
+ 			break;
+ 		case SOCK_SEQPACKET:
+ 		default:
+ 			rc = -ESOCKTNOSUPPORT;
+ 			goto err_notsupport;
+ 	}
+ 	sk = sk_alloc(PF_NETBEUI, GFP_KERNEL, 1);
+ 	if (!sk)
+ 		goto err_sk;
+ 	sk->protinfo.af_netbeui = kmalloc(sizeof(*sk->protinfo.af_netbeui),
+ 					  GFP_KERNEL);
+ 	if (!sk->protinfo.af_netbeui)
+ 		goto err_nbsk;
+ 	memset(sk->protinfo.af_netbeui, 0, sizeof(*sk->protinfo.af_netbeui));
+ 	sock_init_data(sock, sk);
+ 	sk->protinfo.destruct_hook = sk->protinfo.af_netbeui;
+ 	sock->ops = prot;
+ 	sk->state = NBSO_INIT;
+ out:	return rc;
+ err_nbsk:
+ 	sk_free(sk);
+ err_sk: rc = -ENOMEM;
+ err_notsupport:
+ 	MOD_DEC_USE_COUNT;
+ 	goto out;
+ }
+ 
+ /* Socket family declarations */
+ static struct net_proto_family netbeui_family_ops = {
+         family:         PF_NETBEUI,
+         create:         netbeui_create,
+ };
+ 
+ /*
+  * Function: nbso_init
+  *	Initializes socket interface for servicing. This function is called
+  *	in start of NetBEUI module installation in kernel memory.
+  *
+  * Parameters: none
+  *
+  * Returns: int
+  *	0        : if operation is performed successfully.
+  *	negative : if a fault occurs.
+  */
+ int nbso_init(void)
+ {
+ 	return sock_register(&netbeui_family_ops);
+ }
+ 
+ /*
+  * Function: nbso_exit
+  *	Prepares socket interface for termination of NetBEUI module operation.
+  *
+  * Parameters: none
+  *
+  * Returns: int
+  *	0        : if operation is performed successfully.
+  *	negative : if a fault occurs.
+  */
+ int nbso_exit(void)
+ {
+ 	return sock_unregister(netbeui_family_ops.family);
+ }
Index: kernel-acme/net/netbeui/config.c
diff -c /dev/null kernel-acme/net/netbeui/config.c:1.1.4.6
*** /dev/null	Wed Sep  5 00:22:38 2001
--- kernel-acme/net/netbeui/config.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,405 ----
+ /*
+  * config.c - Contains functions that configure or query NetBEUI parameters
+  *	      from API tools such as ioctl/setsockopt/getsockopt.
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/string.h>
+ #include <linux/sched.h>
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/errno.h>
+ #include <net/sock.h>
+ #include <asm/uaccess.h>
+ #include <linux/netbeui.h>
+ 
+ /* Holds NetBIOS configurable parameters */
+ config_t netbios_config = {
+ 	DEFAULT_LINK_INACTIVITY_TIMEOUT,
+ 	DEFAULT_TRANSMIT_TIMEOUT,
+ 	DEFAULT_TRANSMIT_COUNT,
+ 	DEFAULT_RESOURCE_TIMEOUT,
+ 	DEFAULT_DATA_ACK_TIMEOUT
+ };
+ 
+ /*
+  * Function: nbcs_update_netbios_config
+  *	Updates NetBIOS parameters with new values while considers special
+  *	cases.
+  *
+  * Parameters:
+  *	newcfg	: pointer to config_t which contains new values for NetBIOS
+  *	  	  parameters.
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- Since most NetBIOS parameters are tuned automatically both in LLC
+  *	  and NetBEUI, this implementation contains only a subset.
+  *	- Setting value of parameter to zero means using NetBIOS defaults
+  *	- Two parameters "resource_timeout" and "data_ack_timeout" are added
+  *	  by this implementation.
+  */
+ static void nbcs_update_netbios_config(config_t *newcfg)
+ {
+ 	/* Setting INACTIVITY TIMEOUT */
+ 	if (!newcfg->inactivity_timeout)
+ 		netbios_config.inactivity_timeout =
+ 						DEFAULT_LINK_INACTIVITY_TIMEOUT;
+ 	else if (newcfg->inactivity_timeout > MAX_LINK_INACTIVITY_TIMEOUT)
+ 		netbios_config.inactivity_timeout = MAX_LINK_INACTIVITY_TIMEOUT;
+ 	else
+ 		netbios_config.inactivity_timeout = newcfg->inactivity_timeout;
+ 
+ 	/* Setting TRANSMIT TIMEOUT */
+ 	if (!newcfg->transmit_timeout)
+ 		netbios_config.transmit_timeout = DEFAULT_TRANSMIT_TIMEOUT;
+ 	else if (newcfg->transmit_timeout > MAX_TRANSMIT_TIMEOUT)
+ 		netbios_config.transmit_timeout = MAX_TRANSMIT_TIMEOUT;
+ 	else
+ 		netbios_config.transmit_timeout = newcfg->transmit_timeout;
+ 
+ 	/* Setting TRANSMIT COUNT */
+ 	if (!newcfg->transmit_count)
+ 		netbios_config.transmit_count = DEFAULT_TRANSMIT_COUNT;
+ 	else if (newcfg->transmit_count > MAX_TRANSMIT_COUNT)
+ 		netbios_config.transmit_count = MAX_TRANSMIT_COUNT;
+ 	else
+ 		netbios_config.transmit_count = newcfg->transmit_count;
+ 
+ 	/* Setting RESOURCE TIMEOUT */
+ 	if (!newcfg->resource_timeout)
+ 		netbios_config.resource_timeout = DEFAULT_RESOURCE_TIMEOUT;
+ 	else if (newcfg->resource_timeout > MAX_RESOURCE_TIMEOUT)
+ 		netbios_config.resource_timeout = MAX_RESOURCE_TIMEOUT;
+ 	else
+ 		netbios_config.resource_timeout = newcfg->resource_timeout;
+ 
+ 	/* Setting DATA ACK TIMEOUT */
+ 	if (!newcfg->data_ack_timeout)
+ 		netbios_config.data_ack_timeout = DEFAULT_DATA_ACK_TIMEOUT;
+ 	else if (newcfg->data_ack_timeout > MAX_DATA_ACK_TIMEOUT)
+ 		netbios_config.data_ack_timeout = MAX_DATA_ACK_TIMEOUT;
+ 	else
+ 		netbios_config.data_ack_timeout = newcfg->data_ack_timeout;
+ }
+ 
+ /*
+  * Function: nbcs_setsockopt
+  *	Sets SOL_NETBEUI layer options provided by setsockopt system call.
+  *
+  * Parameters:
+  *	sock	: pointer to socket structure
+  *	optname : option code
+  *	optval	: pointer to new value of parameter (option)
+  *	optlen  : length of option value in bytes.
+  *
+  * Returns:
+  *	0	      : if new value for option set successfully
+  *	-EOPNOTSUPP   : if option is not supported on socket type
+  *	-ENOTPROTOOPT : if NetBEUI layer does not support the option.
+  *
+  * Notes:
+  *	- Refer to Implementation documents for a complete description of
+  *	  NetBEUI layer options accessible from setsockopt.
+  *	- user buffer is checked in upper layer.
+  */
+ int nbcs_setsockopt(struct socket *sock, int optname, void *optval, int optlen)
+ {
+ 	struct sock *sk = sock->sk;
+ 
+ 	switch (optname) {
+ 		case SO_URGENTACK:
+ 			if (NB_SK(sk)->u.st.session) {
+ 				__u8 urg_ack;
+ 
+ 				if (get_user(urg_ack, (__u8 *)optval))
+ 					return -EFAULT;
+ 				NB_SK(sk)->u.st.session->urgent_ack = urg_ack;
+ 				return 0;
+ 			}
+ 			return -ENOTCONN;
+ 
+ 		case SO_NBPARAM: {
+ 			config_t tmp_config;
+ 
+ 			if (optlen != sizeof(netbios_config))
+ 				return -EINVAL;
+ 			if (copy_from_user((void *)&tmp_config, optval, optlen))
+ 				return -EFAULT;
+ 			nbcs_update_netbios_config(&tmp_config);
+ 			return 0;
+ 		}
+ 	}
+ 	return -ENOPROTOOPT;
+ }
+ 
+ /*
+  * Function: nbcs_getsockopt
+  *	Gets SOL_NETBEUI layer options requested by getsockopt system call.
+  *
+  * Parameters:
+  *	sock	: pointer to socket structure
+  *	optname : option code
+  *	optval	: (VRP) pointer to buffer to save value of parameter (option)
+  *	optlen  : (VRP) pointer length of option value in bytes.
+  *
+  * Returns:
+  *	0	      : if value of option is moved to optval successfully
+  *	-EOPNOTSUPP   : if option is not supported on socket type
+  *	-ENOTPROTOOPT : if NetBEUI layer does not support the option.
+  *
+  * Notes:
+  *	- Refer to Implementation documents for a complete description of
+  *	  NetBEUI layer options accessible from setsockopt.
+  *	- user buffer is checked in upper layer.
+  */
+ int nbcs_getsockopt(struct socket *sock, int optname, void *optval, int *optlen)
+ {
+ 	int len;
+ 	struct sock *sk = sock->sk;
+ 
+ 	if (get_user(len, (int *)optlen))
+ 		return -EFAULT;
+ 
+ 	switch (optname) {
+ 		case SO_URGENTACK:
+ 			if (NB_SK(sk)->u.st.session) {
+ 				len = MIN(len,
+ 				   sizeof(NB_SK(sk)->u.st.session->urgent_ack));
+ 				if (copy_to_user(optval,
+ 				   (void *)&NB_SK(sk)->u.st.session->urgent_ack,
+ 			   			 len) ||
+ 				    put_user(len, (int *)optlen))
+ 					return -EFAULT;
+ 				return 0;
+ 			}
+ 			return -EOPNOTSUPP;
+ 		case SO_NBPARAM:
+ 			len = MIN(len, sizeof(netbios_config));
+ 			if (copy_to_user(optval, (void *)&netbios_config,
+ 					 len) ||
+ 			    put_user(len, (int *)optlen))
+ 				return -EFAULT;
+ 			return 0;
+ 		}
+ 	return -ENOPROTOOPT;
+ }
+ 
+ /*
+  * Function: nbcs_purge_links
+  *	Disconnects links on a specific network device (if exist).
+  *
+  * Parameters:
+  *	dev  : pointer to device that links on it must be disconnect.
+  *	flag : type of unbinding that specified by user. The
+  *	       NETBEUI_UNBIND_FLAG_SAFE flag means that protocol stack unbinds
+  *	       from the device only no links exist on it.
+  *
+  * Returns: int
+  *	zero     : if command be performed successfully.
+  *	negative : if command fails. error codes that bubble to user are
+  *	           dependent to cmd.
+  *	           -EISCONN : the device has some links as yet , but the
+  *	                      NETBEUI_UNBIND_FLAG_SAFE flag is specified.
+  */
+ static int nbcs_purge_links(struct net_device *dev, unsigned char flag)
+ {
+ 	int i, count, rc = 0;
+ 	dextab_t *ltbl;
+ 
+ 	ltbl = nbll_get_link_table();
+ 	spin_lock_bh(&ltbl->lock);
+ 	count = ltbl->count;
+ 	for (i = ltbl->reserved; count; i++, count--) {
+ 		link_t *nb_link = ltbl->addr[i];
+ 
+ 		if (nb_link->remote_dev == dev) {
+ 			if (flag == NETBEUI_UNBIND_FLAG_DROP)
+ 				nbll_drop_link(nb_link->link_no);
+ 			else { /* NETBEUI_UNBIND_FLAG_SAFE */
+ 				rc = -EISCONN;
+ 				goto out;
+ 			}
+ 		}
+ 	}
+ out:	spin_lock_bh(&ltbl->lock);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbcs_config
+  *	Performs configuration actions on the NetBEUI via NBIOCCONFIG ioctl
+  *	command.
+  *
+  * Parameters:
+  *	usp : pointer to 'struct netbeui_cfg' that contains command and its
+  *	      arguments.
+  *
+  * Returns: int
+  *	zero     : if command is performed successfully.
+  *	negative : if command fails. error codes that bubble to user are
+  *	           dependent to usp->command.
+  *	           -EOPNOTSUPP : the command is not valid.
+  */
+ static int nbcs_config(struct netbeui_cfg *usp)
+ {
+ 	int i;
+ 	char name[NETBEUI_MAX_NIF_NAME_LEN];
+ 	extern struct net_device *adapters[];
+ 	extern unsigned short binded_adapters_count;
+ 	unsigned short command;
+ 	unsigned char reserved;
+ 
+ 	if (get_user(command, &usp->command))
+ 		return -EFAULT;
+ 
+ 	switch (command) {
+ 		case NETBEUI_CFGCMD_NIF_UNBIND:
+ 			if (get_user(reserved, &usp->reserved))
+ 				return -EFAULT;
+ 			if (reserved)
+ 				return -EINVAL;
+ 			if (copy_from_user(name, usp->nif_name,
+ 				   		NETBEUI_MAX_NIF_NAME_LEN))
+ 				return -EFAULT;
+ 			for (i = 0; i < binded_adapters_count; i++)
+ 				if (!strcmp(adapters[i]->name, name)) {
+ 					int rc;
+ 					unsigned char flag;
+ 
+ 					if (get_user(flag, &usp->flag))
+ 						return -EFAULT;
+ 					rc = nbcs_purge_links(adapters[i],
+ 							      flag);
+ 					if (rc)
+ 						return rc;
+ 					dev_mc_delete(adapters[i],
+ 					          NETBEUI_FUNCADDR(adapters[i]),
+ 					              adapters[i]->addr_len, 0);
+ 					binded_adapters_count--;
+ 					if (i < binded_adapters_count)
+ 						adapters[i] =
+ 						adapters[binded_adapters_count];
+ 					adapters[binded_adapters_count] = NULL;
+ 					return 0;
+ 				}
+ 			return -ENODEV;
+ 		case NETBEUI_CFGCMD_NIF_BIND: {
+ 			struct net_device *dev;
+ 
+ 			if (get_user(reserved, &usp->reserved))
+ 				return -EFAULT;
+ 			if (reserved)
+ 				return -EINVAL;
+ 			if (copy_from_user(name, usp->nif_name,
+ 					   NETBEUI_MAX_NIF_NAME_LEN))
+ 				return -EFAULT;
+ 			if (binded_adapters_count == NETBEUI_MAX_ADAPTERS)
+ 				return -ENOSPC;
+ 
+ 			for (i = 0; i < binded_adapters_count; i++)
+ 				if (!strcmp(adapters[i]->name, name))
+ 					return 0; /* It binds already */
+ 
+ 			for (dev = dev_base; dev; dev = dev->next)
+ 				if (!strcmp(dev->name, name)) {
+ 					if (nbcm_apt_dev(dev)) {
+ 						adapters[binded_adapters_count]
+ 						                          = dev;
+ 						binded_adapters_count++;
+ 						dev_mc_add(dev,
+ 							  NETBEUI_FUNCADDR(dev),
+ 						           dev->addr_len, 0);
+ 
+ 						return 0;
+ 					} else
+ 						return -EOPNOTSUPP;
+ 				}
+ 			return -ENODEV;
+ 		}
+ 		case NETBEUI_CFGCMD_DROP_SESS: {
+ 			int rc, lnn, snn;
+ 
+ 			if (get_user(lnn, &usp->ln_num))
+ 				return -EFAULT;
+ 			if (lnn < 0 || lnn >= NETBEUI_MAX_LINKS)
+ 				return -EINVAL;
+ 			if (get_user(snn, &usp->sn_num))
+ 				return -EFAULT;
+ 			if (snn < 1 || snn >= NETBEUI_MAX_SESSIONS)
+ 				return -EINVAL;
+ 			rc = nbss_drop_session(lnn, snn);
+ 			return rc;
+ 		}
+ 		case NETBEUI_CFGCMD_DROP_LINK: {
+ 			int rc, lnn;
+ 
+ 			if (get_user(lnn, &usp->ln_num))
+ 				return -EFAULT;
+ 			if (lnn < 0 || lnn >= NETBEUI_MAX_LINKS)
+ 				return -EINVAL;
+ 			rc = nbll_drop_link(lnn);
+ 			return rc;
+ 		}
+ 	}
+ 	return -EOPNOTSUPP;
+ }
+ 
+ /*
+  * Function: nbcs_ioctl
+  *	Provides NetBEUI level requests of ioctl() system call.
+  *
+  * Parameters:
+  *	cmd : code of command that must perform.
+  *	arg : pointer to appropriate data structure, related to command.
+  *
+  * Returns: int
+  *	zero     : if command be performed successfully.
+  *	negative : if command fails. error codes that bubble to user are
+  *	           dependent to cmd.
+  *	           -EOPNOTSUPP : the command is not valid.
+  */
+ int nbcs_ioctl(unsigned int cmd, void *arg)
+ {
+ 	switch (cmd) {
+                 case NBIOCGSTATUS: {
+ 			int len;
+ 			struct netbeui_status *usp = arg;
+ 
+ 			if (get_user(len, &usp->buff_len))
+ 				return -EFAULT;
+ 			if (len < NETBEUI_MIN_STATUS_BUFF_LEN)
+ 				return -EINVAL;
+ 			return nbst_obtain_status(usp->called_name,
+ 			                          usp->status_buff,
+ 			                          &usp->buff_len);
+ 		}
+ 		case NBIOCCONFIG: {
+ 			struct netbeui_cfg *usp = arg;
+ 
+ 			if (!capable(CAP_NET_ADMIN))
+ 				return -EACCES;
+ 			return nbcs_config(usp);
+ 		}
+ #if 0
+ /* NOT IMPLEMENTED */
+ 		default:
+                         /* Pass ioctl command to next layer */
+ 			return ll___ioctl(cmd, arg);
+ /*			return dev_ioctl(cmd, arg); */
+ 
+ #endif
+ 	}
+ 	return -EOPNOTSUPP;
+ }
Index: kernel-acme/net/netbeui/dextab.c
diff -c /dev/null kernel-acme/net/netbeui/dextab.c:1.1.4.6
*** /dev/null	Wed Sep  5 00:22:38 2001
--- kernel-acme/net/netbeui/dextab.c	Sat Aug 25 03:43:41 2001
***************
*** 0 ****
--- 1,266 ----
+ /*
+  * dextab.c - Contains functions that implement a dynamically expandable table.
+  * 	      The abstraction includes a data structure with a table of
+  * 	      addresses which expands in order of two. The table never shrinks.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/sched.h>
+ #include <linux/kernel.h>
+ #include <linux/slab.h>
+ #include <linux/netdevice.h>
+ #include <linux/netbeui.h>
+ 
+ /*
+  * Function: dextab_init
+  *	Initializes dextab_t structure
+  *
+  * Parameters:
+  *	tbl	: pointer to dextab_t to be initialized
+  *	reserved: number of entries to reserve from head of dextab. This value
+  *		  instructs other functions not to use those entries.
+  *	max_size: maximum number of entries the <tbl> can hold.
+  *
+  * Returns: none
+  *
+  * Note:
+  *	- There are two ways to initialize a dextab:
+  *		1- Staticly initializating when defining dextab_t
+  *		2- calling dextab_init
+  */
+ void dextab_init(dextab_t *tbl, int reserved, int max_size)
+ {
+ 	tbl->addr	= NULL;
+ 	tbl->size	= 0;
+ 	tbl->reserved	= reserved;
+ 	tbl->max_size	= max_size;
+ 	tbl->count	= 0;
+ 	spin_lock_init(&tbl->lock);
+ }
+ 
+ /*
+  * Function: dextab_expand
+  *	Expands table array of pointers in order of two. The old entries
+  *	contents are safely kept in their place.
+  *
+  * Parameters:
+  *	tbl	: pointer to dextab_t to be expanded
+  *
+  * Returns:
+  *	0	: If table expanded successfully.
+  *	non-zero: if table entry count has reached maximum size determined
+  *		  in initialization steps and if memory allocation failed.
+  *		
+  *	Don't grab tbl->lock, dextab_add_insert_entry already does this
+  */
+ static int dextab_expand(dextab_t *tbl)
+ {
+ 	int new_size;
+ 	void **new_addr;
+ 	int rc = -1;
+ 
+ 	new_size = !tbl->size ? 16 : (tbl->size * 2);
+ 	/* Table size should not exceed maximum table size */
+ 	if (new_size > tbl->max_size) {
+ 		if (tbl->size < tbl->max_size)
+ 			new_size = tbl->max_size;
+ 		else
+ 			goto out;
+ 	}
+ 	new_addr = kmalloc(new_size * sizeof(void *), GFP_ATOMIC);
+ 	if (!new_addr)
+ 		goto out;
+ 	/* Copy previous data from old area to new one */
+ 	memset(new_addr, 0, new_size * sizeof(void *));
+ 	if (tbl->addr) {
+ 		memcpy(new_addr, tbl->addr, tbl->size * sizeof(void *));
+ 		kfree(tbl->addr);
+ 	}
+ 	tbl->addr = new_addr;
+ 	tbl->size = new_size;
+ 	rc = 0;
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: dextab_add_insert_entry
+  *	This is a back-end function which depending on its arguments creates
+  *	an entry or puts a pre-allocated entry into dextab. The front ends
+  *	are macros defined in header files.
+  *
+  * Parameters:
+  *	tbl	  : pointer to dextab_t to insert element into
+  *	entry_size: size of entry to add. if non-zero value passed, the memory
+  *		    is allocated with entry_size bytes.
+  *	entry	  : address of entry to insert into table
+  *
+  * Returns:
+  *	>=0	  : uopn successfull insertion into table, this is the index
+  *		    of entry in table.
+  * 	<0	  : unsuccessful insertion
+  *
+  * Note:
+  *	- The entry_size and entry are exclusive arguments and entry_size
+  *	  precedes entry in decisions.
+  *
+  *	- Add means allocate and insert entry, which is usually indicated by
+  *	  setting entry_size to non-zero value.
+  *
+  *	- Insert means insert a pre-allocated entry, which is usually indicated
+  *	  by setting entry_size to zero and passing an address in entry.
+  */
+ int __dextab_add_insert_entry(dextab_t *tbl, int entry_size, void *entry)
+ {
+ 	int index, rc = -1;
+ 
+ 	/* If you can find a free slot in table add entry there */
+ 	for (index = tbl->reserved; index < tbl->size; index++) {
+ 		if (tbl->addr[index])
+ 			continue;
+ 		tbl->addr[index] = entry_size > 0 ?
+ 		                   kmalloc(entry_size, GFP_ATOMIC) : entry;
+ 		if (tbl->addr[index]) {
+ 			tbl->count++;
+ 			rc = index;
+ 		}
+ 		goto out;
+ 	}
+ 	/* Try to expand table then retry again */
+ 	if (!dextab_expand(tbl)) {
+ 		rc = __dextab_add_insert_entry(tbl, entry_size, entry);
+ 		goto out;
+ 	}
+ 	/* Could not expand table return error */
+ 	rc = -1;
+ out:	return rc;
+ }
+ 
+ int dextab_add_insert_entry(dextab_t *tbl, int entry_size, void *entry)
+ {
+ 	int rc = -1;
+ 
+ 	spin_lock(&tbl->lock);
+ 	rc = __dextab_add_insert_entry(tbl, entry_size, entry);
+ 	spin_unlock(&tbl->lock);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: dextab_remove_delete_index
+  *	This is a back-end function which depending on its arguments removes
+  *	destructs an entry from dextab. The front ends are macros defined in
+  *	header files.
+  *
+  * Parameters:
+  *	tbl	   : pointer to dextab_t to remove element from
+  *	entry_index: index of entry in table
+  *	flag	   : removal or deletion flag. Values are:
+  *			- DEXTAB_FREE_ENTRY
+  *			- DEXTAB_NOFREE_ENTRY (otherwise)
+  *
+  * Returns: none
+  *
+  * Note:
+  *	- The flag value is checked against DEXTAB_FREE_ENTRY
+  *
+  *	- Remove means delete entry from table and free its memory, This is
+  *	  indicated by setting qflag DEXTAB_FREE_ENTRY
+  *
+  *	- Delete means delete entry from memory, this is indicated by setting
+  *	  qflag to everything other than DEXTAB_FREE_ENTRY usually
+  *	  DEXTAB_NOFREE_ENTRY
+  */
+ void __dextab_remove_delete_index(dextab_t *tbl, int entry_index, int flag)
+ {
+ 	if (entry_index < tbl->size && entry_index >= tbl->reserved)
+ 		if (tbl->addr[entry_index]) {
+ 			if (flag == DEXTAB_FREE_ENTRY)
+ 				kfree(tbl->addr[entry_index]);
+ 			tbl->addr[entry_index] = NULL;
+ 			tbl->count--;
+ 		}
+ }
+ 
+ void dextab_remove_delete_index(dextab_t *tbl, int entry_index, int flag)
+ {
+ 	spin_lock(&tbl->lock);
+ 	__dextab_remove_delete_index(tbl, entry_index, flag);
+ 	spin_unlock(&tbl->lock);
+ }
+ 
+ /*
+  * Function: dextab_entry_index
+  *	Returns index of an entry in table using its address.
+  *
+  * Parameters:
+  *	tbl	   : pointer to dextab_t to find entry in
+  *	entry	   : address of entry to find in table
+  *
+  * Returns:
+  *	>= 0	   : index of entry found in table
+  *	< 0	   : if entry not found in table
+  */
+ int dextab_entry_index(dextab_t *tbl, void *entry)
+ {
+ 	int index;
+ 
+ 	spin_lock(&tbl->lock);
+ 	for (index = tbl->reserved; index < tbl->size; index++)
+ 		if (tbl->addr[index] == entry)
+ 			break;
+ 	if (index >= tbl->size)
+ 		index = -1;
+ 	spin_unlock(&tbl->lock);
+ 	return index;
+ }
+ 
+ /*
+  * Function: dextab_count_entries
+  *	returns count of entries in dextab
+  *
+  * Parameters:
+  *	tbl	   : pointer to dextab_t to count its entries
+  *
+  * Returns:
+  *	>0	   : count of entries in table
+  */
+ inline int __dextab_count_entries(dextab_t *tbl)
+ {
+ 	return tbl->count;
+ }
+ 
+ inline int dextab_count_entries(dextab_t *tbl)
+ {
+ 	int rc;
+ 
+ 	spin_lock(&tbl->lock);
+ 	rc = __dextab_count_entries(tbl);
+ 	spin_unlock(&tbl->lock);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: dextab_destruct
+  *	housekeep a dextab, deallocates memories, ....
+  *
+  * Parameters:
+  *	tbl	   : pointer to dextab_t to destruct
+  *
+  * Returns: none
+  */
+ void dextab_destruct(dextab_t *tbl)
+ {
+ 	spin_lock(&tbl->lock);
+ 	if (tbl->addr)
+ 		kfree(tbl->addr);
+ 	spin_unlock(&tbl->lock);
+ 	dextab_init(tbl, tbl->reserved, tbl->max_size);
+ }
Index: kernel-acme/net/netbeui/dgram_serve.c
diff -c /dev/null kernel-acme/net/netbeui/dgram_serve.c:1.1.4.4
*** /dev/null	Wed Sep  5 00:22:38 2001
--- kernel-acme/net/netbeui/dgram_serve.c	Wed Aug 29 15:35:28 2001
***************
*** 0 ****
--- 1,597 ----
+ /*
+  * dgram_serve.c - Contains functions that supply DATAGRAM service for NetBEUI
+  *                 protocol stack, and also some utility functions.
+  *
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/string.h>
+ #include <asm/system.h>
+ #include <asm/uaccess.h>		/* put/get_user, copy_.*_user */
+ #include <net/sock.h>
+ #include <linux/slab.h>
+ #include <linux/skbuff.h>
+ #include <linux/netdevice.h>
+ #include <linux/netbeui.h>
+ 
+ extern struct net_device *adapters[];	 /* List of adapters bound to */
+ 
+ unsigned int dgbc_mtu;  /* DataGram BroadCast Maximum Transfer Unit */
+ 
+ static struct {
+ 	volatile unsigned char	lock;	/* 0:UnLock , 1:Lock */
+ 	name_dgrms_t		*obc;	/* One Behind Cache */
+ 	name_dgrms_t		*normal_list;
+ 	name_dgrms_t		*star_list;
+ } nbdg_names = { 0, NULL, NULL, NULL};
+ 
+ /* Internal NBDG functions */
+ /*
+  * Function: nbdg_find_name
+  *	Finds sightly name_dgrms structure address depend on its name in the
+  *	normal_list.
+  *
+  * Parameters:
+  *	name : pointer to name that must find its structure address.
+  *
+  * Returns: name_dgrms_t *
+  *	non NULL : address of related name_dgrms structure.
+  *	NULL     : means requested name not exist in normal_list.
+  */
+ static inline name_dgrms_t *nbdg_find_name (char *name)
+ {
+ 	name_dgrms_t *curr;
+ 
+ 	for (curr = nbdg_names.normal_list; curr; curr = curr->next)
+ 		if (!memcmp(curr->name, name, NETBEUI_NAME_LEN))
+ 			break;
+ 	return curr;
+ }
+ 
+ /*
+  * Function: nbdg_find_such_frame
+  *	Finds another frame in 'frameq' that has same "frame type" and
+  *	"source name" with 'skb'.
+  *
+  * Parameters:
+  *	skb : pointer to sk_buff that contains sightly frame.
+  *
+  * Returns: struct sk_buff *
+  *	non NULL : address of appropriate sk_buff.
+  *	NULL     : if no such frame exist in frameq.
+  */
+ static struct sk_buff *nbdg_find_such_frame(struct sk_buff *skb)
+ {
+ 	char source_name[NETBEUI_NAME_LEN];
+ 	dgram_t *hdrp = (dgram_t *)skb->data;
+ 	int frame_type = hdrp->command;
+ 	struct sk_buff_head *frameq = skb->list;
+ 
+ 	memcpy(source_name, hdrp->source_name, NETBEUI_NAME_LEN);
+ 	skb = skb->next;
+ 	while (skb != (struct sk_buff *)frameq) {
+ 		hdrp = (dgram_t *)skb->data;
+ 
+ 		if (hdrp->command == frame_type)
+ 			if (!memcmp(hdrp->source_name, source_name,
+ 			    NETBEUI_NAME_LEN))
+ 				return skb;
+ 		skb = skb->next;
+ 	}
+ 	return NULL;
+ }
+ 
+ /*
+  * Function: nbdg_enqueue_name
+  *	Enqueues a name_dgrms structure at begin of 'list' queue. it guards
+  *	code from race conditions by Lock/UnLock 'nbdg_names' structure.
+  *
+  * Parameters:
+  *	namep : pointer to name_dgrms structure that must be inserted into
+  *	        the list.
+  *	list  : pointer to a pointer that points to first member of list.
+  *
+  * Returns: none
+  */
+ static void nbdg_enqueue_name(name_dgrms_t *namep, name_dgrms_t **list)
+ {
+ 	namep->prev = NULL;
+ 	namep->next = *list;
+ 	nbdg_names.lock = 1;
+ 	barrier();
+ 	*list = namep;
+ 	if (namep->next)
+ 		namep->next->prev = namep;
+ 	barrier();
+ 	nbdg_names.lock = 0;
+ 	namep->list = list;
+ }
+ 
+ /*
+  * Function: nbdg_dequeue_name
+  *	Dequeues a name_dgrms structure from 'list' queue. it guards code
+  *	from race conditions by Lock/UnLock 'nbdg_names' structure.
+  *
+  * Parameters:
+  *	namep : pointer to name_dgrms structure that must be removed from
+  *	        its list.
+  *
+  * Returns: none
+  */
+ static void nbdg_dequeue_name(name_dgrms_t *namep)
+ {
+ 	nbdg_names.lock = 1;
+ 	barrier();
+ 	if (namep->next)
+ 		namep->next->prev = namep->prev;
+ 	if (namep->prev)
+ 		namep->prev->next = namep->next;
+ 	else
+ 		*namep->list = namep->next;
+ 	barrier();
+ 	nbdg_names.lock = 0;
+ }
+ 
+ /*
+  * Exported  NBDG  functions
+  */
+ /*
+  * Function: nbdg_set_dgbc_mtu
+  *	Tunes the 'dgbc_mtu' global variable up to correct value. this function
+  *	is called at begin of protocol stack installation in kernel space, and
+  *	also must be called each time 'adapters[]' array altered.
+  *
+  * Parameters: none
+  *
+  * Returns: none
+  */
+ void nbdg_set_dgbc_mtu(void)
+ {
+ 	int i, tmp;
+ 
+ 	if (!adapters[0])
+ 		return;
+ 	tmp = adapters[0]->mtu;
+ 	for (i = 1; i < NETBEUI_MAX_ADAPTERS && adapters[i]; i++)
+ 		tmp = MIN(tmp, adapters[i]->mtu);
+ 	dgbc_mtu = tmp - LLCMAC_UIB_HEADLEN() - NETBEUI_UILEN;
+ }
+ 
+ /*
+  * Function: nbdg_remove_unwanted_dgf
+  *	Removes frames in frame queue that contain up to 'len' bytes of data.
+  *	user program can uses this function by call ioctl() with SIOCRUWDGF
+  *	command. because we have not any mechanism in NetBEUI to recognize
+  *	message boundaries, this is user (program) that recognizes them and
+  *	announce us that Maximum 'len' bytes of remainder data is not
+  *	beneficial and can be removed. 'len' == 0 means that we must remove all
+  *	of such frames from queue.
+  *
+  * Parameters:
+  *	namep : pointer to name_dgrms structure that operation perform on its
+  *	        frameq.
+  *	len   : maximum length which upper layer knows that is not usable.
+  *
+  * Returns: int
+  *	0 : this function always succeed.
+  */
+ int nbdg_remove_unwanted_dgf(name_dgrms_t *namep, int len)
+ {
+ 	struct sk_buff *skb = namep->curr_skb,
+ 	               *such_skb;
+ 	if (!skb)
+ 		return 0;  /* We are at begin of a message boundary now */
+ 	namep->curr_skb = NULL;
+ 	if (len) {
+ 		len -= skb->len;
+ 		while (len > 0) {
+ 			such_skb = nbdg_find_such_frame(skb);
+ 			skb_unlink(skb);
+ 			kfree_skb(skb);
+ 			if (!such_skb)
+ 				return 0;
+ 			skb = such_skb;
+ 			len -= skb->len;
+ 		}
+ 	} else /* Remove all of such frames */
+ 		while ((such_skb = nbdg_find_such_frame(skb))) {
+ 			skb_unlink(skb);
+ 			kfree_skb(skb);
+ 			skb = such_skb;
+ 		}
+ 	skb_unlink(skb);
+ 	kfree_skb(skb);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbdg_register_peername
+  *	Registers a remote name for a local name. it causes that received
+  *	frames only from specified remote name be acceptable. broadcasted frames
+  *	will be accepted only if 'remote_name[0]' is equal to '*'.
+  *
+  * Parameters:
+  *	namep       : pointer to name_dgrms structure that remote name registers
+  *	              for it.
+  *	remote_name : pointer to remote name that must be registered.
+  *
+  * Returns: none
+  */
+ void nbdg_register_peername(name_dgrms_t *namep, char *remote_name)
+ {
+ 	if (remote_name[0] == '*') {
+ 		if (namep->list != &nbdg_names.star_list) {
+ 			nbdg_dequeue_name(namep);
+ 			nbdg_enqueue_name(namep, &nbdg_names.star_list);
+ 		}
+ 	} else
+ 		if (namep->list != &nbdg_names.normal_list) {
+ 			nbdg_dequeue_name(namep);
+ 			nbdg_enqueue_name(namep, &nbdg_names.normal_list);
+ 		}
+ 	namep->conn_name = remote_name;
+ 	namep->connected = 1;
+ }
+ 
+ /*
+  * Function: nbdg_deregister_peername
+  *	Deregisters a registered name for a local name. it causes that received
+  *	frames which are broadcasted or have our name in dest_name field of
+  *	their NetBIOS header, be acceptable.
+  *
+  * Parameters:
+  *	namep : pointer to name_dgrms structure that must deregister its
+  *	        attached name.
+  *
+  * Returns: none
+  */
+ void nbdg_deregister_peername(name_dgrms_t *namep)
+ {
+ 	if (namep->conn_name[0] == '*') {
+ 		nbdg_dequeue_name(namep);
+ 		nbdg_enqueue_name(namep, &nbdg_names.normal_list);
+ 	}
+ 	namep->connected = 0;
+ }
+ 
+ /*
+  * Function: nbdg_add_name
+  *	Creates a name_dgrms structure and adds it to normal_list.
+  *
+  * Parameters:
+  *	local_name : pointer to name that must add its structure to normal_list.
+  *	wq         : pointer to a pointer that points to dependent wait_queue.
+  *	namep      : (VRP) pointer to a pointer buffer that in successful return
+  *	             contains address of related name_dgrms structure in list.
+  *
+  * Returns: int
+  *	0        : if operation is performed successfully.
+  *	negative : if a fault occurs.
+  *                  -ENOMEM : Out of memory condition.
+  */
+ int nbdg_add_name(char *local_name, wait_queue_head_t *wq, name_dgrms_t **namep)
+ {
+ 	name_dgrms_t *new = kmalloc(sizeof(name_dgrms_t), GFP_KERNEL);
+ 
+ 	if (!new)
+ 		return -ENOMEM;
+ 	memset(new, 0, sizeof(*new));
+ 	skb_queue_head_init(&new->frameq);
+ 	memcpy(new->name, local_name, NETBEUI_NAME_LEN);
+ 	new->waitq = wq;
+ 	init_waitqueue_head(new->waitq);
+ 	nbdg_enqueue_name(new, &nbdg_names.normal_list);
+ 	*namep = new;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbdg_del_name
+  *	Removes a name_dgrms structure from its list.
+  *
+  * Parameters:
+  *	namep : pointer to name_dgrms structure that must deleted.
+  *
+  * Returns: none
+  */
+ void nbdg_del_name(name_dgrms_t *namep)
+ {
+ 	nbdg_names.lock = 1;
+ 	barrier();
+ 	if (nbdg_names.obc == namep)
+ 		nbdg_names.obc = NULL;
+ 	barrier();
+ 	nbdg_names.lock = 0;
+ 	nbdg_dequeue_name(namep);
+ 	skb_queue_purge(&namep->frameq);
+ 	kfree(namep);
+ }
+ 
+ /*
+  * Function: nbdg_receive_ready
+  *	Answers to the question "Do in transport layer exist any queued
+  *	received data for this name ?"
+  *
+  * Parameters:
+  *	namep : pointer to name_dgrms structure that question is about it.
+  *
+  * Returns: int
+  *	0  : means "OK, exist some data".
+  *	-1 : means "NO, not exist any queued received data as yet".
+  */
+ int nbdg_receive_ready(name_dgrms_t *namep)
+ {
+ 	return skb_queue_empty(&namep->frameq) ? -1 : 0 /* OK! */;
+ }
+ 
+ /*
+  * Function: nbdg_send
+  *	Sends datagrams to the sightly destination(s).
+  *
+  * Parameters:
+  *	local_name : pointer to name that must copied to source_name field of
+  *	             NetBIOS header of all sent frames.
+  *	dest_name  : pointer to name that must copied to dest_name field of
+  *	             NetBIOS header of all sent frames (target name).
+  *	dest_type  : type of destination of frames.
+  *	buff       : pointer to buffer that contains data that must be sent.
+  *	bufflen    : length of data buffer.
+  *
+  * Returns: int
+  *	positive : number of bytes that was sent.
+  *	negative : if a fault occurs.
+  *	           -ENOMEM       : Out of memory condition.
+  */
+ int nbdg_send(struct sock *sk, char *local_name, char *dest_name,
+ 	      name_type_t dest_type, struct iovec *iov, int len, int noblock)
+ {
+ 	int rc,
+ 	    fskbl,
+ 	    offset = 0,
+ 	    bytes_put = 0;
+ 	dgram_t hdr;
+ 	struct sk_buff *skb;
+ 	unsigned char *datap;
+ 
+ 	if (dest_name[0] == '*')
+ 		hdr.command = NETBEUI_DATAGRAM_BROADCAST;
+ 	else {
+ 		hdr.command = NETBEUI_DATAGRAM;
+ 		memcpy(hdr.dest_name, dest_name, NETBEUI_NAME_LEN);
+ 	}
+ 	hdr.length = NETBEUI_UILEN;
+ 	hdr.delimiter = NETBEUI_DELIMITER;
+ 	memcpy(hdr.source_name, local_name, NETBEUI_NAME_LEN);
+ 	fskbl = CALC_DG_SKBLEN(NETBEUI_MAC_B_HEADLEN, dgbc_mtu + NETBEUI_UILEN);
+ 	skb = sock_alloc_send_skb(sk, fskbl, noblock, &rc);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 	skb_reserve(skb, LLCMAC_UIB_HEADLEN());
+ 	memcpy(skb_put(skb, sizeof(hdr)), &hdr, sizeof(hdr));
+ 
+ 	if (len > dgbc_mtu) {
+ 		datap = skb_put(skb, dgbc_mtu);
+ 		do {
+ 			rc = memcpy_fromiovecend(datap, iov, offset, dgbc_mtu);
+ 			if (rc)
+ 				goto out;
+ 			offset += dgbc_mtu;
+ 			bytes_put += dgbc_mtu;
+ 			len -= dgbc_mtu;
+ 			rc = nbll_uisend(NULL, skb);
+ 			if (rc)
+ 				goto out;
+ 		} while (len > dgbc_mtu); /* FIXME: > or >= ? */
+ 	}
+ 	if (len) {
+ 		skb_trim(skb, sizeof(hdr));
+ 		rc = memcpy_fromiovecend(skb_put(skb, len), iov, offset, len);
+ 		if (rc)
+ 			goto out;
+ 		bytes_put += len;
+ 
+ 		rc = nbll_uisend(NULL, skb);
+ 		if (rc)
+ 			goto out;
+ 	}
+ 	rc = bytes_put;
+ out:	kfree_skb(skb);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbdg_receive
+  *	Copies data that received and queued into user data buffer.
+  *
+  * Parameters:
+  *	namep       : pointer to name_dgrms that we want receive data that
+  *	              queued for it.
+  *	source_name : (VRP) pointer to a name buffer. if this parameter is not
+  *	              NULL at return the name buffer will be filled with message
+  *	              sender name.
+  *	dest_name   : (VRP) pointer to a name buffer. if this parameter is not
+  *	              NULL at return the name buffer will be filled with message
+  *	              destination name.
+  *	buff        : (VRP) pointer to data buffer. at return this buffer
+  *	              contains data that received.
+  *	bufflen     : indicates Maximum no of bytes that user wants to receive.
+  *	nonblock    : an integer that if be set to non-zero value means that
+  *	              no waiting (sleeping, blocking & ...) acceptable during
+  *	              operation.
+  *
+  * Returns: int
+  *	positive : no of bytes that was received.
+  *	negative : if a fault occurs.
+  *	           -EWOULDBLOCK : user requests non-blocking operation, but
+  *	                            operation would block.
+  *	           -ERESTARTSYS : interrupted system call.
+  */
+ int nbdg_receive(name_dgrms_t *namep, char *source_name, char *dest_name,
+ 		 char *buff, int bufflen, int nonblock)
+ {
+ 	int bytes_gotten = 0;
+ 	char *datap;
+ 	dgram_t *hdrp;
+ 	struct sk_buff *skb;
+ 
+ 	while (skb_queue_empty(&namep->frameq))
+ 		if (nonblock)
+ 			return -EWOULDBLOCK;
+ 		else {
+ 			interruptible_sleep_on(namep->waitq);
+ 			if (signal_pending(current))
+ 				return -ERESTARTSYS;
+ 		}
+ 	skb = namep->curr_skb;
+ 	if (!skb) {
+ 		skb = namep->curr_skb = skb_peek(&namep->frameq);
+ 		skb->len -= sizeof(dgram_t);
+ 	}
+ 	hdrp = (dgram_t *)skb->data;
+ 	datap = (char *)(skb->tail - skb->len);
+ 	if (source_name)
+ 		memcpy(source_name, hdrp->source_name, NETBEUI_NAME_LEN);
+ 	if (dest_name) {
+ 		if (hdrp->command == NETBEUI_DATAGRAM) {
+ 			if (copy_to_user(dest_name, hdrp->dest_name,
+ 						NETBEUI_NAME_LEN))
+ 				return -EFAULT;
+ 		} else
+ 			if (put_user('*', dest_name))
+ 				return -EFAULT;
+ 	}
+ 	while (bufflen) {
+ 		int len = MIN(bufflen, skb->len);
+ 
+ 		if (copy_to_user(buff, datap, len))
+ 			return -EFAULT;
+ 		buff += len;
+ 		bufflen -= len;
+ 		datap += len;
+ 		skb->len -= len;
+ 		bytes_gotten += len;
+ 
+ 		if (!skb->len) {  /* sk_buff copied completely */
+ 			struct sk_buff *such_skb = nbdg_find_such_frame(skb);
+ 
+ 			skb_unlink(skb);
+ 			kfree_skb(skb);
+ 			namep->curr_skb = such_skb;
+ 			if (!such_skb)  /* No any such frame */
+ 				return bytes_gotten;
+ 			skb = such_skb;
+ 			hdrp = (dgram_t *)skb->data;
+ 			skb->len -= sizeof(dgram_t);
+ 			datap = (char *)(hdrp + sizeof(dgram_t));
+ 		}
+ 	}
+ 	return bytes_gotten;
+ }
+ 
+ /*
+  * Function: nbdg_get_datagram
+  *	Takes a NETBEUI_DATAGRAM frame from 'llc supplementary' and place it on
+  *	appropriate frame queues.
+  *
+  * Parameters:
+  *	skb        : pointer to sk_buff that contains NETBEUI_DATAGRAM frame.
+  *
+  * Returns: none
+  */
+ void nbdg_get_datagram(struct sk_buff *skb)
+ {
+ 	dgram_t *hdrp;
+ 	name_dgrms_t *namep;
+ 
+ 	barrier();
+ 	if (nbdg_names.lock) /* Is the structure lock ?! */
+ 		goto drop;
+ 	/* Place a copy of the skb in frame queue of all star_list's members */
+ 	for (namep = nbdg_names.star_list; namep; namep = namep->next) {
+ 		struct sk_buff *new_skb = skb_clone(skb, GFP_ATOMIC);
+ 
+ 		if (!new_skb)
+ 			continue;
+ 		skb_queue_tail(&namep->frameq, new_skb);
+ 		wake_up_interruptible(namep->waitq);
+ 	}
+ 	hdrp = (dgram_t *)skb->data;
+ 
+ 	if (nbdg_names.obc && /* If One Behind Cache is not empty and ... */
+ 	    !memcmp(nbdg_names.obc->name, hdrp->dest_name, NETBEUI_NAME_LEN))
+ 		namep = nbdg_names.obc;
+ 	else {
+ 		namep = nbdg_find_name(hdrp->dest_name);
+ 		if (!namep)  /* No registered name for this sk_buff */
+ 			goto drop;
+ 		nbdg_names.obc = namep;
+ 	}
+ 	if (namep->connected)
+ 		/* To force short circuiting by compiler */
+ 		if (!memcmp(namep->conn_name, hdrp->source_name,
+ 			    NETBEUI_NAME_LEN))
+ 			/* Not connected to this source_name */
+ 			goto drop;
+ 	/* Now we find the apposite name */
+ 	skb_queue_tail(&namep->frameq, skb);
+ 	wake_up_interruptible(namep->waitq);
+ out:	return;
+ drop:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbdg_get_datagram_broadcast
+  *	Takes a NETBEUI_DATAGRAM_BROADCAST frame from 'llc supplementary' and
+  *	place it on appropriate frame queues.
+  *
+  * Parameters:
+  *	skb        : pointer to sk_buff that contains
+  *		     NETBEUI_DATAGRAM_BROADCAST frame.
+  *
+  * Returns: none
+  */
+ void nbdg_get_datagram_broadcast(struct sk_buff *skb)
+ {
+ 	name_dgrms_t *namep;
+ 	struct sk_buff *new_skb;
+ 
+ 	barrier();
+ 	if (nbdg_names.lock) {  /* Is the structure lock ?! */
+ 		kfree_skb(skb);
+ 		return;
+ 	}
+ 	/* Place a copy of skb in frame queue of all star_list's members */
+ 	for (namep = nbdg_names.star_list; namep; namep = namep->next) {
+ 		new_skb = skb_clone(skb, GFP_ATOMIC);
+ 		if (!new_skb)
+ 			continue;
+ 		skb_queue_tail(&namep->frameq, new_skb);
+ 		wake_up_interruptible(namep->waitq);
+ 	}
+ 	for (namep = nbdg_names.normal_list; namep; namep = namep->next) {
+ 		if (namep->connected)
+ 			/* To force short circuiting by compiler */
+ 			if (memcmp(namep->conn_name,
+ 			           ((dgram_t *)skb->data)->source_name,
+ 			           NETBEUI_NAME_LEN))
+ 				/* Not connected to this source_name */
+ 				continue;
+ 		new_skb = skb_clone(skb, GFP_ATOMIC);
+ 		if (!new_skb)
+ 			continue;
+ 		skb_queue_tail(&namep->frameq, new_skb);
+ 		wake_up_interruptible(namep->waitq);
+ 	}
+ 	kfree_skb(skb);
+ }
Index: kernel-acme/net/netbeui/llc_supp.c
diff -c /dev/null kernel-acme/net/netbeui/llc_supp.c:1.1.4.10
*** /dev/null	Wed Sep  5 00:22:38 2001
--- kernel-acme/net/netbeui/llc_supp.c	Wed Aug 29 15:35:28 2001
***************
*** 0 ****
--- 1,1552 ----
+ /*
+  * llc_supp.c - Contains three category of functions
+  * 			1- functions that implement Link Service State Machine
+  * 			2- functions that simplify LLC interface layer services
+  *			3- dispatching functions
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/module.h>
+ #include <linux/sched.h>
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/errno.h>
+ #define __KERNEL_SYSCALLS__
+ #include <linux/unistd.h>
+ #include <net/llc_if.h>
+ #include <net/llc_sap.h>
+ #include <linux/init.h>
+ #include <linux/netbeui.h>
+ 
+ static void nbll_timer_function(unsigned long input);
+ /* These functions are Link State Transition handlers */
+ static int nbll_conn_indicate_in_initial(link_t *nb_link);
+ static int nbll_conn_request_in_connwait(link_t *nb_link);
+ static int nbll_dummy_conn_in_initial(link_t *nb_link);
+ static int nbll_conn_confirm_in_connwait(link_t *nb_link);
+ static int nbll_conn_indicate_in_connwait(link_t *nb_link);
+ static int nbll_conn_reject_in_connwait(link_t *nb_link);
+ static int nbll_disc_request_in_connwait(link_t *nb_link);
+ static int nbll_reset_indicate_in_up(link_t *nb_link);
+ static int nbll_session_alive_in_up(link_t *nb_link);
+ static int nbll_disc_request_in_up(link_t *nb_link);
+ static int nbll_disc_indicate_in_up(link_t *nb_link);
+ 
+ static int auto_bind;
+ MODULE_PARM(auto_bind, "i");
+ MODULE_PARM_DESC(auto_bind, "Autobinds all multicast interfaces");
+ #define NetBEUI_SAP_NO 	0xF0
+ 
+ /* Contains hardcoded NetBIOS Frame Header length */
+ u8 nb_command_header_len[] = {
+ 	0x2C, 0x2C, 0x2C, 0x2C, 0x00, 0x00, 0x00, 0x2C,
+ 	0x2C, 0x2C, 0x2C, 0x00, 0x00, 0x2C, 0x2C, 0x2C,
+ 	0x00, 0x00, 0x00, 0x2C, 0x0E, 0x0E, 0x0E, 0x0E,
+ 	0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E
+ };
+ 
+ /*
+  * LLC is not re-entrant service to upper layer (NetBEUI)
+  * This flag, set upon entering LLC code, prevents NetBEUI to re-enter the
+  * code when its timers fire.
+  */
+ volatile int llc_in_progress = 0;
+ 
+ /* This is the communication medium between LLC and NetBEUI */
+ static struct p8022_sap *netbeui_sap;
+ 
+ /* This is a list of adapters NetBEUI is bound to. */
+ struct net_device *adapters[NETBEUI_MAX_ADAPTERS];
+ 
+ /* Counts members of 'adapters[]' array */
+ unsigned short binded_adapters_count;
+ 
+ /* LLC links to other network nodes */
+ static dextab_t link_table = {
+ 	max_size:	NETBEUI_MAX_LINKS,
+ 	lock:		SPIN_LOCK_UNLOCKED
+ };
+ 
+ #define link_table_entry(i)  ((link_t *)link_table.addr[i])
+ 
+ /* Link service state machine definition */
+ typedef int (*link_event_handler_t)(link_t *);
+ 
+ struct event_struct {
+ 	link_state_t  next_state;
+ 	link_event_handler_t event_handler;
+ };
+ 
+ static struct event_struct link_state_table[3][9] = {
+ 			/* NETBEUI_LINK_INITIAL  */
+ {
+ { NETBEUI_LINK_UP,
+ 	nbll_conn_indicate_in_initial }, /* NETBEUI_LINK_CONN_INDICATE  */
+ { -1, NULL },				 /* NETBEUI_LINK_CONN_REQUEST   */
+ { NETBEUI_LINK_CONNWAIT,
+ 	nbll_dummy_conn_in_initial },	 /* NETBEUI_LINK_DUMMY_CONN     */
+ { -1, NULL },				 /* NETBEUI_LINK_CONN_CONFIRM   */
+ { -1, NULL },				 /* NETBEUI_LINK_CONN_REJECT    */
+ { -1, NULL },				 /* NETBEUI_LINK_RESET_INDICATE */
+ { -1, NULL }, 				 /* NETBEUI_LINK_SESSION_ALIVE  */
+ { -1, NULL },				 /* NETBEUI_LINK_DISC_REQUEST   */
+ { -1, NULL }				 /* NETBEUI_LINK_DISC_INDICATE  */
+ },
+ 			/* NETBEUI_LINK_CONNWAIT */
+ {
+ { NETBEUI_LINK_UP,
+ 	nbll_conn_indicate_in_connwait }, /* NETBEUI_LINK_CONN_INDICATE  */
+ { NETBEUI_LINK_CONNWAIT,
+ 	nbll_conn_request_in_connwait },  /* NETBEUI_LINK_CONN_REQUEST   */
+ { -1, NULL },				  /* NETBEUI_LINK_DUMMY_CONN     */
+ { NETBEUI_LINK_UP,
+ 	nbll_conn_confirm_in_connwait },  /* NETBEUI_LINK_CONN_CONFIRM   */
+ { NETBEUI_LINK_INITIAL,
+ 	nbll_conn_reject_in_connwait },	  /* NETBEUI_LINK_CONN_REJECT    */
+ { -1, NULL },				  /* NETBEUI_LINK_RESET_INDICATE */
+ { -1, NULL }, 				  /* NETBEUI_LINK_SESSION_ALIVE  */
+ { NETBEUI_LINK_INITIAL,
+ 	nbll_disc_request_in_connwait },  /* NETBEUI_LINK_DISC_REQUEST   */
+ { -1, NULL }				  /* NETBEUI_LINK_DISC_INDICATE  */
+ },
+ 			  /* NETBEUI_LINK_UP */
+ {
+ { -1, NULL },				  /* NETBEUI_LINK_CONN_INDICATE  */
+ { -1, NULL },				  /* NETBEUI_LINK_CONN_REQUEST   */
+ { -1, NULL },				  /* NETBEUI_LINK_DUMMY_CONN     */
+ { -1, NULL },				  /* NETBEUI_LINK_CONN_CONFIRM   */
+ { -1, NULL },				  /* NETBEUI_LINK_CONN_REJECT    */
+ { NETBEUI_LINK_UP,
+ 	nbll_reset_indicate_in_up },	  /* NETBEUI_LINK_RESET_INDICATE */
+ { NETBEUI_LINK_UP,
+ 	nbll_session_alive_in_up },	  /* NETBEUI_LINK_SESSION_ALIVE  */
+ { NETBEUI_LINK_INITIAL,
+ 	nbll_disc_request_in_up },	  /* NETBEUI_LINK_DISC_REQUEST   */
+ { NETBEUI_LINK_INITIAL,
+ 	nbll_disc_indicate_in_up }	  /* NETBEUI_LINK_DISC_INDICATE  */
+ }
+ };
+ /*
+  * LLC interface functions
+  * Data-out functions
+  */
+ /*
+  * Function: nbll_isend_link
+  *	This is the lowest level LLC interface function in sending and I-Frame
+  *	It prepares a LLC frame structure, considers LLC re-entrancy problems
+  *	and decides on LLC return value to handle many special cases.
+  *
+  * Parameters:
+  *	rdev	  : pointer to struct net_device or adapter the frame is sent to
+  *		    This parameter is designed to minimize critical regions
+  *	llc_handle: LLC handle of remote machine (is a pointer to LLC data)
+  *	skb	  : the pointer to sk_buff containing data to send
+  *	qflag	  : queuing flag. NetBEUI links control flow of data to LLC
+  *		    layer using a skb queue. Depending on the situation we
+  *		    are in, an unsuccessful try in delivering frame to LLC
+  *		    should queue the frame for later trials. This flag controls
+  *		    how this function should queue the skb.
+  *			0    : queue unsuccessful skb in tail and return 0
+  *			other: queue unsuccessful skb in head and return
+  *			       non-zero
+  *
+  * Returns:
+  *	0	  : if LLC accepts the frame or frame is queue in Link for
+  *		    later trial
+  *	qflag<> 0 : if queues frame for later trial
+  *	non-zero  : any other error value returned by LLC
+  *
+  * Notes:
+  *	- Any modification to this function highly affects the whole system
+  *
+  *	- A special race condition is an interrupt occurred when LLC returns
+  *	  from sap_request to NetBEUI. To cover it a critical region is created
+  *	  before LLC return statement in LLC code and is destroyed after
+  *	  sap_request statement in NetBEUI code. This is why you may see
+  *	  wonderful save and restore flag calls in the code.
+  *
+  *	  acme: with all the locking changes I think that this race is gone
+  *	  so, for now I'll get rid of all this 'wonderful' save and restore
+  */
+ static int nbll_isend_link(struct net_device *rdev,
+ 			   struct p8022_connection *llc_handle,
+ 			   struct sk_buff *skb, unsigned char link_no,
+ 			   int qflag)
+ {
+ 	prim_data_u prim_data;
+ 	struct prim_if_block prim;
+ 	int rc;
+ 
+ 	prim.data = &prim_data;
+ 	skb->protocol = htons(ETH_P_802_2);
+ 	if (!memcmp(rdev->name, "tr", 2))
+ 		skb->protocol = htons(ETH_P_TR_802_2);
+ 	skb->dev	= rdev;
+ 	skb->mac.raw	= skb->head;
+ 	prim_data.data.priority	  = 0;
+ 	prim_data.data.connection = llc_handle;
+ 	prim_data.data.skb	  = skb;
+ 	prim.sap		  = netbeui_sap;
+ 	prim.primitive		  = P8022_DATA_PRIM;
+ restart:
+ 	llc_in_progress = 1;
+ 	barrier();
+ 	rc = netbeui_sap->request(&prim);
+ 	llc_in_progress = 0;
+ 	barrier();
+ 	switch (rc) {
+ 		case 0:
+ 			goto out;
+ 		case -ERESTART:
+ 			goto restart;
+ 		case -EBUSY: {
+ 			link_t *nb_link;
+ 			nb_link = link_table_entry(link_no);
+ 			if (!nb_link) {
+ 				kfree_skb(skb);
+ 				rc = -ECONNABORTED;
+ 				goto out;
+ 			}
+ 			nb_link->llc_busy = 1;
+ 			if (!qflag)
+ 				__skb_queue_tail(&nb_link->skbq, skb);
+ 			else
+ 				__skb_queue_head(&nb_link->skbq, skb);
+ 			rc = qflag;
+ 			goto out;
+ 		}
+ 	}
+ 	kfree_skb(skb);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: nbll_free_link
+  *	Does a complete housekeeping for a link including queue/table/...
+  *
+  * Parameters:
+  *	nb_link	: pointer to link_t to destruct
+  *
+  * Returns: none
+  */
+ static inline void nbll_free_link(link_t *nb_link)
+ {
+ 	skb_queue_purge(&nb_link->skbq);
+ 	dextab_destruct(&nb_link->session_table);
+ 	kfree(nb_link);
+ }
+ 
+ /* used by session_serve.c as well, so cannot be static */
+ inline void nbll_link_put(link_t *nb_link)
+ {
+ 	if (atomic_dec_and_test(&nb_link->refcnt))
+ 		nbll_free_link(nb_link);
+ }
+ 
+ static inline void nbll_link_hold(link_t *nb_link)
+ {
+ 	atomic_inc(&nb_link->refcnt);
+ }
+ 
+ /*
+  * Function: nbll_isend
+  *	This is the interface routine that actually tries to send I-Frames
+  *	on an LLC connection.
+  *
+  * Parameters:
+  *	link_no	: An integer containing link number in link table
+  *		  The function relies on correctness of value.
+  *	skb	: pointer to sk_buff containing data to send
+  *
+  * Returns:
+  *	0	: if LLC accepts frame or it is queued for later trial
+  *	-ECONNABORTED: If connection is aborted by remote peer
+  *	-ENOMEM	: If cannot allocate a skb
+  *	non-zero: any other error value returned by LLC
+  *
+  * Notes:
+  *	- Since I intended to call this function freely in
+  *	  upper layer codes, it contains a critical region checking LINK
+  *	  consistency
+  */
+ int nbll_isend(int link_no, struct sk_buff *skb)
+ {
+ 	link_t *nb_link = NULL;
+ 	struct net_device *link_remote_dev;
+ 	struct p8022_connection *link_llc_handle;
+ 	int rc = -EINVAL;
+ 
+ 	spin_lock(&link_table.lock);
+ 	if (link_no > link_table.count)
+ 		goto freeskb;
+ 	nb_link = link_table_entry(link_no);
+ 	rc = -ECONNABORTED;
+ 	if (!nb_link)
+ 		goto freeskb;
+ 	nbll_link_hold(nb_link);
+ 	rc = 0;
+ 	if (nb_link->llc_busy == 1) {
+ 		__skb_queue_tail(&nb_link->skbq, skb);
+ 		goto out;
+ 	}
+ 	nb_link->iactivity++;
+ 	link_remote_dev = nb_link->remote_dev;
+ 	link_llc_handle = nb_link->llc_handle;
+ 	rc = nbll_isend_link(link_remote_dev, link_llc_handle, skb, link_no, 0);
+ out:	nbll_link_put(nb_link);
+ sunlock:spin_unlock(&link_table.lock);
+ 	return rc;
+ freeskb:
+ 	kfree_skb(skb);
+ 	goto sunlock;
+ }
+ 
+ /*
+  * Function: nbll_uisend_mac
+  *	This is the lowest level LLC interface function in sending and UI-Frame
+  *
+  * Parameters:
+  *	remote_mac: pointer to MAC address of destination node or NetBIOS
+  *		    functional address of device the frame is sent to.
+  *	skb	  : pointer to sk_buff containing data to send
+  *
+  * Returns:
+  *	0	: if LLC accepts frame
+  *	-ENOMEM	: If cannot allocate a skb
+  *	non-zero: any other error value returned by LLC
+  */
+ static int nbll_uisend_mac(unsigned char *remote_mac, struct sk_buff *skb)
+ {
+ 	prim_data_u prim_data;
+ 	struct prim_if_block prim;
+ 
+ 	prim.data = &prim_data;
+ 	skb->protocol = htons(ETH_P_802_2);
+ 	if (!memcmp(skb->dev->name, "tr", 2))
+ 		skb->protocol = htons(ETH_P_TR_802_2);
+ 
+ 	prim_data.udata.source_addr.lsap = NetBEUI_SAP_NO;
+ 	memcpy(prim_data.udata.source_addr.mac, skb->dev->dev_addr,
+ 	       skb->dev->addr_len);
+ 	prim_data.udata.dest_addr.lsap	= NetBEUI_SAP_NO;
+ 	memcpy(prim_data.udata.dest_addr.mac, remote_mac, skb->dev->addr_len);
+ 	prim_data.udata.skb		= skb;
+ 	prim.sap	= netbeui_sap;
+ 	prim.primitive	= P8022_DATAUNIT_PRIM;
+ 	return netbeui_sap->request(&prim);
+ }
+ 
+ /*
+  * Function: nbll_uisend
+  *	This is the interface routine that actually tries to send UI-Frames
+  *	on an LLC connection.
+  *
+  * Parameters:
+  *	remote_mac: pointer to MAC address of destination system or NULL
+  *		    to indicate broadcast to all NICs NetBEUI is bound to
+  *	skb	  : pointer to sk_buff containing data to send
+  *
+  * Returns:
+  *	0	: if LLC accepts frame
+  *	-ENOMEM	: If cannot allocate a skb
+  *		  or cannot create a copy from skb.
+  *	non-zero: any other error value returned by LLC
+  */
+ int nbll_uisend(unsigned char *remote_mac, struct sk_buff *skb)
+ {
+ 	int i, rc = -ENOMEM;
+ 
+ 	/* If datagram has a destination */
+ 	if (remote_mac) {
+ 		rc = nbll_uisend_mac(remote_mac, skb);
+ 		goto out;
+ 	}
+ 	/* Datagram is to be broadcasted to all interfaces */
+ 	for (i = 0; i < NETBEUI_MAX_ADAPTERS && adapters[i]; i++) {
+ 		struct sk_buff *skb2 = skb_copy(skb, GFP_ATOMIC);
+ 
+ 		if (!skb2)
+ 			goto out;
+ 		skb2->dev = adapters[i];
+ 		nbll_uisend_mac(NETBEUI_FUNCADDR(adapters[i]), skb2);
+ 	}
+ 	rc = 0;
+ out:	return rc;
+ }
+ 
+ /*
+  * Link service state machine functions
+  * Implementing general functions
+  */
+ /*
+  * Function: nbll_alloc_link
+  *	Allocates and Initializes a link_t structure
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	NULL	: if can not allocate link_t structure
+  *	non-NULL: if link_t is allocated and initialized
+  *
+  * Note:
+  *	- Link timer is initialized but not started
+  *	- The call to memset does implicitly initialize all fields. Those
+  *	  fields that need explicit non-zero initialization are manipulated
+  *	  afterwards.
+  */
+ static link_t *nbll_alloc_link(void)
+ {
+ 	link_t *nb_link = kmalloc(sizeof(*nb_link), GFP_ATOMIC);
+ 
+ 	if (!nb_link)
+ 		goto out;
+ 	/* Implicitly initialize all fields */
+ 	memset(nb_link, 0, sizeof(*nb_link));
+ 	nb_link->state		= NETBEUI_LINK_INITIAL;
+ 	nb_link->link_no	= -1;
+ 	dextab_init(&nb_link->session_table, 1, NETBEUI_MAX_SESSIONS);
+ 	skb_queue_head_init(&nb_link->skbq);
+ 	init_waitqueue_head(&nb_link->waitq);
+ 	init_timer(&nb_link->timer);
+ 	nb_link->timer.data	= (unsigned long)nb_link;
+ 	nb_link->timer.function	= nbll_timer_function;
+ 	atomic_set(&nb_link->refcnt, 1);
+ out:	return nb_link;
+ }
+ 
+ /*
+  * Function: nbll_insert_link_into_table
+  *	Inserts a previously allocated/initialized link into system link table
+  *
+  * Parameters:
+  *	nb_link	: pointer to link_t to insert
+  *
+  * Returns: none
+  *	0	: if nb_link is inserted into system link_table
+  *	-ENOSPC : if link_table is full
+  */
+ static int nbll_insert_link_into_table(link_t *nb_link)
+ {
+ 	int link_no;
+ 	int rc = -ENOSPC;
+ 
+ 	nbll_link_hold(nb_link);
+ 	link_no = dextab_insert_entry(&link_table, nb_link);
+ 	if (link_no < 0)
+ 		goto out;
+ 	if (nb_link->link_no == -1) {
+ 		nb_link->link_no = link_no;
+ 		rc = -ENOMEM;
+ 		if (netbeui_proc_add_link(nb_link)) {
+ 			dextab_delete_index(&link_table, link_no);
+ 			goto out;
+ 		}
+ 	}
+ 	rc = 0;
+ out:	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbll_delete_link_from_table
+  *	Deletes a link from system link table
+  *
+  * Parameters:
+  *	nb_link	: pointer to link_t to delete
+  *
+  * Returns: none
+  */
+ static void nbll_delete_link_from_table(link_t *nb_link)
+ {
+ 	nbll_link_hold(nb_link);
+ 	netbeui_proc_del_link(nb_link);
+ 	dextab_delete_index(&link_table, nb_link->link_no);
+ 	nb_link->link_no = -1;
+ 	nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Function: nbll_find_link
+  *	Finds a link in system link table to a remote node from its mac and
+  *	the device we are connected via
+  *
+  * Parameters:
+  *	dev	  : pointer to struct net_device we are connected to remote
+  *		    node via
+  *	remote_mac: pointer to MAC address of remote node we are connected to
+  *
+  * Returns:
+  *	NULL	  : if a corresponding link is not found
+  *	non-NULL  : the link_t address of corresponding link
+  */
+ static link_t *nbll_find_link(struct net_device *dev, unsigned char *remote_mac)
+ {
+ 	int index;
+ 	link_t *nb_link = NULL;
+ 
+ 	spin_lock(&link_table.lock);
+ 	for (index = link_table.reserved; index < link_table.size; index++) {
+ 		nb_link = link_table_entry(index);
+ 		if (nb_link && nb_link->remote_dev == dev &&
+ 		    !memcmp(nb_link->remote_mac, remote_mac, dev->addr_len))
+ 			break;
+ 	}
+ 	if (nb_link)
+ 		nbll_link_hold(nb_link);
+ 	spin_unlock(&link_table.lock);
+ 	return nb_link;
+ }
+ 
+ /*
+  * Function: nbll_request_llc_connect
+  *	Prepares and sends a connection request to LLC layer.
+  *
+  * Parameters:
+  *	nb_link	: pointer to link_t structure prepared for this new connection
+  *		  A NetBEUI link_t is the counterpart of LLC connection struct.
+  *
+  * Returns:
+  *	0	: LLC accepted connection request
+  *	non-zero: LLC rejected connection request
+  */
+ static int nbll_request_llc_connect(link_t *nb_link)
+ {
+ 	struct net_device *dev;
+ 	struct prim_if_block prim;
+ 	prim_data_u prim_data;
+ 	int rc;
+ 
+ 	nbll_link_hold(nb_link);
+ 	dev = nb_link->remote_dev;
+ 	prim.data			= &prim_data;
+ 	prim_data.conn.source_addr.lsap	= NetBEUI_SAP_NO;
+ 	memcpy(prim_data.conn.source_addr.mac, dev->dev_addr, dev->addr_len);
+ 	prim_data.conn.dest_addr.lsap	= NetBEUI_SAP_NO;
+ 	memcpy(prim_data.conn.dest_addr.mac, nb_link->remote_mac,
+ 	       dev->addr_len);
+ 	prim_data.conn.device		= dev;
+ 	prim_data.conn.link_no		= nb_link->link_no;
+ 	prim_data.conn.connection	= NULL;
+ 	prim_data.conn.priority		= 0;
+ 	prim.primitive			= P8022_CONNECT_PRIM;
+ 	prim.sap			= netbeui_sap;
+ 	rc = netbeui_sap->request(&prim);
+ 	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbll_request_llc_disconnect
+  *	Prepares and sends a disconnection request to LLC layer.
+  *
+  * Parameters:
+  *	nb_link	: pointer to link_t structure responsible for this connection
+  *		  A NetBEUI link_t is the counterpart of LLC connection struct.
+  *
+  * Returns:
+  *	0	: LLC accepted disconnection request
+  *	non-zero: LLC rejected disconnection request
+  *
+  * Note:
+  *	- Currently LLC always accepts disconnection request.
+  */
+ static int nbll_request_llc_disconnect(link_t *nb_link)
+ {
+ 	struct prim_if_block prim;
+ 	prim_data_u prim_data;
+ 	int rc;
+ 
+ 	nbll_link_hold(nb_link);
+ 	prim.data			= &prim_data;
+ 	prim_data.disc.connection	= nb_link->llc_handle;
+ 	prim.primitive			= P8022_DISCONNECT_PRIM;
+ 	prim.sap			= netbeui_sap;
+ 	rc = netbeui_sap->request(&prim);
+ 	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbll_isend_session_alive
+  *	Prepares a NetBIOS SESSION ALIVE frame and nbll_isends it to link
+  *
+  * Parameters:
+  *	nb_link	: pointer to link_t structure to send SESSION ALIVE to
+  *
+  * Returns: none
+  */
+ static void nbll_isend_session_alive(link_t *nb_link)
+ {
+ 	packet_t *hdr;
+ 	int llcmac_ihl,
+ 	    session_packet_len = nb_command_header_len[NETBEUI_SESSION_ALIVE];
+ 	struct sk_buff *skb;
+ 
+ 	nbll_link_hold(nb_link);
+ 	llcmac_ihl = LLCMAC_I_HEADLEN(nb_link->remote_dev);
+ 	skb = alloc_skb((session_packet_len + llcmac_ihl), GFP_ATOMIC);
+ 	if (!skb)
+ 		goto out;
+ 	skb_reserve(skb, llcmac_ihl);
+         skb->nh.raw = skb->h.raw = skb->data;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_SESSION_ALIVE;
+ 	hdr->data1		= 0;
+ 	hdr->data2		= 0;
+ 	hdr->xmit_correlator	= 0;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= 0;
+ 	hdr->source_num		= 0;
+ 	nbll_isend(nb_link->link_no, skb);
+ out:	nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Function: nbll_handle_event
+  *	This is the heart of Link Service State Machine, which performs a
+  *	transition from current state of link element to new state based
+  *	on event occurred and link state table contents.
+  *
+  * Parameters:
+  *	event	: An integer of NETBEUI_LINK_* family that implies type of event
+  *	nb_link	: pointer to link_t structure which the event occurred on
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- The state changes before actions be executed. This is due to
+  *	  non deterministic behavior of actions which may sleep the current
+  *	  process, thus stopping the function in the mid-way.
+  */
+ static void nbll_handle_event(link_event_t event, link_t *nb_link)
+ {
+ 	struct event_struct *ev;
+ 
+ 	nbll_link_hold(nb_link);
+ 	ev = &link_state_table[nb_link->state][event];
+ 	if (ev && ev->event_handler) {
+ 		link_state_t old_state = nb_link->state;
+ 
+ 		nb_link->state = ev->next_state;
+ 		if (ev->event_handler(nb_link))
+ 			nb_link->state = old_state;
+ 	}
+ 	nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Function: nbll_timer_function
+  *	This is the callback function triggered upon expiration of link
+  *	inactivity timer. It just injects an event into state machine for
+  *	its link.
+  *
+  * Parameters:
+  *	input	: pointer to link_t structure whose timer is expired.
+  *
+  * Returns: none
+  */
+ static void nbll_timer_function(unsigned long input)
+ {
+ 	link_t *nb_link = (link_t *)input;
+ 
+ 	nbll_link_hold(nb_link);
+ 	nbll_handle_event(NETBEUI_LINK_SESSION_ALIVE, nb_link);
+ 	nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Link service state machine functions
+  * Implementing transition functions
+  */
+ /*
+  * Function: nbll_xxxx_in_ssss
+  *	The section below contains functions that implement actions needed
+  *	to  legally transit from one state to another.
+  *
+  * Parameters:
+  *	nb_link	: pointer to link_t structure which the actions are to be
+  *		  applied to
+  *
+  * Returns:
+  *	0	: if all actions are done successfully
+  *	non-zero: if one of actions failed
+  *
+  * Note:
+  *	- For the sake of simplicity, the actions are automatically rollbacked
+  *	  in each function, if an action in transition fails. The design
+  *	  documents do not cover these parts of code.
+  */
+ static int nbll_conn_indicate_in_initial(link_t *nb_link)
+ {
+ 	int rc;
+ 
+ 	nbll_link_hold(nb_link);
+ 	nb_link->status = nbll_insert_link_into_table(nb_link);
+ 	if (!nb_link->status) {
+ 		nb_link->timer.expires = jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+ 		add_timer(&nb_link->timer);
+ 	}
+ 	rc = nb_link->status;
+ 	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ static int nbll_conn_request_in_connwait(link_t *nb_link)
+ {
+ 	int rc = -1;
+ 
+ 	nbll_link_hold(nb_link);
+ 	if (nbll_request_llc_connect(nb_link))
+ 		goto out;
+ 	sleep_on(&nb_link->waitq);
+ 	rc = 0;
+ out:	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ static int nbll_dummy_conn_in_initial(link_t *nb_link)
+ {
+ 	int rc;
+ 
+ 	nbll_link_hold(nb_link);
+ 	rc = nbll_insert_link_into_table(nb_link);
+ 	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ static int nbll_conn_confirm_in_connwait(link_t *nb_link)
+ {
+ 	nbll_link_hold(nb_link);
+ 	wake_up(&nb_link->waitq);
+ 	nb_link->timer.expires = jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+ 	add_timer(&nb_link->timer);
+ 	nb_link->status = 0;
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ static int nbll_conn_indicate_in_connwait(link_t *nb_link)
+ {
+ 	nbll_link_hold(nb_link);
+ 	nb_link->timer.expires = jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+ 	add_timer(&nb_link->timer);
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ static int nbll_conn_reject_in_connwait(link_t *nb_link)
+ {
+ 	nbll_link_hold(nb_link);
+ 	wake_up(&nb_link->waitq);
+ 	nbll_delete_link_from_table(nb_link);
+ 	nb_link->status = -ECONNREFUSED;
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ static int nbll_disc_request_in_connwait(link_t *nb_link)
+ {
+ 	nbll_link_hold(nb_link);
+ 	nbll_delete_link_from_table(nb_link);
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ static int nbll_reset_indicate_in_up(link_t *nb_link)
+ {
+ 	int index;
+ 
+ 	nbll_link_hold(nb_link);
+ 	for (index = nb_link->session_table.reserved;
+ 	     index < nb_link->session_table.size; index++) {
+ 		session_t *session = (session_t *)
+ 					nb_link->session_table.addr[index];
+ 		if (session) {
+     			nbss_abort_session(session);
+ 			dextab_delete_index(&nb_link->session_table,
+ 					    session->lsn);
+ 		}
+ 	}
+ 	del_timer(&nb_link->timer);
+ 	nb_link->iactivity	= 0;
+ 	nb_link->timer.expires	= jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+ 	add_timer(&nb_link->timer);
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ static int nbll_session_alive_in_up(link_t *nb_link)
+ {
+ 	nbll_link_hold(nb_link);
+ 	if (!nb_link->iactivity)
+ 		nbll_isend_session_alive(nb_link);
+ 	nb_link->iactivity	= 0;
+ 	nb_link->timer.expires	= jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+ 	add_timer(&nb_link->timer);
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ static int nbll_disc_request_in_up(link_t *nb_link)
+ {
+ 	nbll_link_hold(nb_link);
+ 	del_timer(&nb_link->timer);
+ 	nbll_request_llc_disconnect(nb_link);
+ 	nbll_delete_link_from_table(nb_link);
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ static int nbll_disc_indicate_in_up(link_t *nb_link)
+ {
+ 	int index;
+ 
+ 	nbll_link_hold(nb_link);
+ 	del_timer(&nb_link->timer);
+ 
+ 	for (index = nb_link->session_table.reserved;
+ 	     index < nb_link->session_table.size; index++) {
+ 		session_t *session = (session_t *)
+ 					nb_link->session_table.addr[index];
+ 		if (session) {
+ 			nbss_abort_session(session);
+ 			dextab_delete_index(&nb_link->session_table,
+ 					    session->lsn);
+ 		}
+ 	}
+ 	dextab_destruct(&nb_link->session_table);
+ 	nbll_delete_link_from_table(nb_link);
+ 	nbll_link_put(nb_link);
+ 	return 0;
+ }
+ 
+ /*
+  * Link service state machine functions
+  * Implementing interface functions
+  */
+ /*
+  * Function: get_disconnect_indicate
+  *	Accepts a connection indication from LLC layer. If it can establish
+  *	a link anyway, generates an event on link element, otherwise requests
+  *	LLC to disconnect (! this is LLC rule)
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns: none
+  */
+ static void nbll_get_connect_indicate(struct prim_if_block *prim)
+ {
+ 	prim_connect_t *prim_data = (prim_connect_t *)prim->data;
+ 	link_t *nb_link = nbll_find_link(prim_data->device,
+ 					 prim_data->source_addr.mac);
+ 
+ 	if (!nb_link)
+ 		nb_link = nbll_alloc_link();
+ 	if (nb_link) {
+ 		nbll_link_hold(nb_link);
+ 		nb_link->llc_handle = prim_data->connection;
+ 		nb_link->remote_dev = prim_data->device;
+ 		memcpy(nb_link->remote_mac, prim_data->source_addr.mac,
+ 		       nb_link->remote_dev->addr_len);
+ 		nbll_handle_event(NETBEUI_LINK_CONN_INDICATE, nb_link);
+ 	}
+ 	if (!nb_link || nb_link->state == NETBEUI_LINK_INITIAL) {
+ 		/* Request link disconnection */
+ 		((prim_disconnect_t *)(prim->data))->connection =
+ 						prim_data->connection;
+ 		prim->primitive = P8022_DISCONNECT_PRIM;
+ 		prim->sap	= netbeui_sap;
+ 		netbeui_sap->request(prim);
+ 		if (nb_link)
+ 			nbll_link_put(nb_link);
+ 	} else {
+ 		prim->primitive	   = P8022_CONNECT_PRIM;
+ 		prim->sap	   = netbeui_sap;
+ 		prim_data->link_no = nb_link->link_no;
+ 		netbeui_sap->response(prim);
+ 	}
+ 	if (nb_link)
+ 		nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Function: nbll_get_connect_confirm
+  *	Accepts a connection confirm for a previously requested connection from
+  *	LLC layer. The LLC may confirm a connection request positively or
+  *	negatively.
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns: none
+  */
+ static void nbll_get_connect_confirm(struct prim_if_block *prim)
+ {
+ 	prim_connect_t *prim_data = (prim_connect_t *)prim->data;
+ 	link_t *nb_link = link_table_entry(prim_data->link_no);
+ 
+ 	nbll_link_hold(nb_link);
+ 	if (prim_data->status == P8022_STATUS_CONNECT) {
+ 		nb_link->llc_handle = prim_data->connection;
+ 		nbll_handle_event(NETBEUI_LINK_CONN_CONFIRM, nb_link);
+ 	} else
+ 		nbll_handle_event(NETBEUI_LINK_CONN_REJECT, nb_link);
+ 	nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Function: nbll_get_data_confirm
+  *	Accepts a data confirm from LLC layer, according to a -EBUSY return
+  *	value on latest try to send I-Frame to a LLC connection. This primitive
+  *	informs NetBEUI to flush its link queue to LLC connection.
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns:
+  *	0 	: if all queue contents are flushed successfully.
+  *	non-Zero: if LLC does not accept all entries and queue has more entries
+  *		  to flush.
+  *
+  * Note:
+  *	- Since this function is raised via LLC, the return value has special
+  *	  meaning to both NetBEUI and LLC to sync their flags. The llc_busy
+  *	  flag in NetBEUI link demonstrates existence of skbs in link queue
+  *	  ready to send to LLC layer.
+  */
+ static int nbll_get_data_confirm(struct prim_if_block *prim)
+ {
+ 	prim_data_t *prim_data = (prim_data_t *)prim->data;
+ 	link_t *nb_link = link_table_entry(prim_data->link_no);
+ 	struct sk_buff *skb;
+ 	int rc = -EBUSY;
+ 
+ 	nbll_link_hold(nb_link);
+ 	while ((skb = __skb_dequeue(&nb_link->skbq)) != NULL)
+ 		if (nbll_isend_link(nb_link->remote_dev, nb_link->llc_handle,
+ 				    skb, prim_data->link_no, 1) == 1)
+ 			goto out;
+ 	rc = nb_link->llc_busy = 0;
+ out:	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbll_get_disconnect_indicate
+  *	Accepts a disconnection indication for a connection from LLC layer.
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns: none
+  */
+ static void nbll_get_disconnect_indicate(struct prim_if_block *prim)
+ {
+ 	link_t *nb_link = link_table_entry(((prim_disconnect_t *)
+ 							prim->data)->link_no);
+ 	nbll_link_hold(nb_link);
+ 	nbll_handle_event(NETBEUI_LINK_DISC_INDICATE, nb_link);
+ 	nbll_link_put(nb_link);
+ 	nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Function: nbll_get_disconnect_confirm
+  *	Accepts a disconnection confirm for a previous disconnect request, from
+  *	LLC layer.
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns: none
+  *
+  * Note:
+  *	- Currently LLC does not generate a disconnection confirm. Both NetBEUI
+  *	  and LLC assume that a disconnection request is always satisfied.
+  */
+ static void nbll_get_disconnect_confirm(struct prim_if_block *prim)
+ {
+ 	/* Nothing to do, we do not wait for disconnection confirmation */
+ }
+ 
+ /*
+  * Function: nbll_get_reset_indicate
+  *	Accepts a reset indication for a connection from LLC layer.
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns: none
+  *
+  * Note:
+  *	- LLC reset indication means close all sessions on link and reset
+  *	  link parameters. Just the link itself remains UP and RUNNING.
+  */
+ static void nbll_get_reset_indicate(struct prim_if_block *prim)
+ {
+ 	link_t *nb_link = link_table_entry(((prim_reset_t *)
+ 							prim->data)->link_no);
+ 
+ 	nbll_link_hold(nb_link);
+ 	nbll_handle_event(NETBEUI_LINK_RESET_INDICATE, nb_link);
+ 	nb_link->llc_busy  = 0;
+ 	nb_link->iactivity = 0;
+ 	skb_queue_purge(&nb_link->skbq);
+ 	nbll_link_put(nb_link);
+ }
+ 
+ /*
+  * Function: get_link_table
+  *	returns a pointer to NetBEUI link table. The proc support code uses
+  *	the link table to map its contents to /proc/sys/netbeui entry.
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	non-NULL: pointer to NetBEUI link table
+  */
+ dextab_t *nbll_get_link_table(void)
+ {
+ 	return &link_table;
+ }
+ 
+ link_t *nbll_get_link(int link_no)
+ {
+ 	link_t *nb_link = NULL;
+ 
+ 	spin_lock(&link_table.lock);
+ 	if (link_no <= link_table.size)
+ 		nb_link = link_table_entry(link_no);
+ 	if (nb_link)
+ 		nbll_link_hold(nb_link);
+ 	spin_unlock(&link_table.lock);
+ 	return nb_link;
+ }
+ 
+ /*
+  * Function: nbll_attach_session
+  *	This is a sophisticated interface to session service module, which
+  *	attaches (links) a session to a link. Depending on the existence and
+  *	state of the link, it interacts with LLC and manipulates link session
+  *	table to content the request.
+  *
+  * Parameters:
+  *	session	  : pointer to session_t structure to add to session table of
+  *		    link
+  *	dev	  : pointer to device structure the link to remote node is on
+  *	remote_mac: pointer to MAC address of remote node the link is to
+  *
+  * Returns:
+  *	0 	  : if the session is successfully added to link session table
+  *	-ENOSPC	  : if the link session table has no space to add session
+  *	-ENOMEM	  : if can not allocate memory for creating new link
+  *	-EHOSTUNREACH: if LLC connection request for a new link failed.
+  */
+ int nbll_attach_session(session_t *session, struct net_device *dev,
+ 			unsigned char *remote_mac)
+ {
+ 	link_t *nb_link = nbll_find_link(dev, remote_mac);
+ 	int session_no;
+ 	int rc;
+ 
+ 	/* If a link exists previously and is up or requested within an
+ 	   interrupt */
+ 	if (nb_link) {
+ 		session_no = dextab_insert_entry(&nb_link->session_table,
+ 						 session);
+ 		rc = -ENOSPC;
+ 		if (session_no < 0)
+ 			goto plink;
+ 		session = (session_t *)nb_link->session_table.addr[session_no];
+ 		session->link_no = nb_link->link_no;
+ 		session->lsn	 = session_no;
+ 		rc = 0;
+ 		goto plink;
+ 	}
+ 	/* Request for link (dummy) */
+ 	nb_link = nbll_alloc_link();
+ 	rc = -ENOMEM;
+ 	if (!nb_link)
+ 		goto out;
+ 	nbll_link_hold(nb_link);
+ 	nb_link->llc_handle = 0;
+ 	nb_link->remote_dev = dev;
+ 	memcpy(nb_link->remote_mac, remote_mac, dev->addr_len);
+ 	nbll_handle_event(NETBEUI_LINK_DUMMY_CONN, nb_link);
+ 	rc = -EHOSTUNREACH;
+ 	if (nb_link->state == NETBEUI_LINK_INITIAL) {
+ 		nbll_link_put(nb_link);
+ 		goto plink;
+ 	}
+ 	rc = nbll_attach_session(session, dev, remote_mac);
+ plink:	nbll_link_put(nb_link);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: nbll_link_session
+  *	This is a joke !!!!!
+  *	NetBEUI connection request has two steps NAME QUERY and LLC CONNECTION
+  *	establishment. To overcome some traditional limits in total session
+  *	count new implementations add a NAME FIND step before the other two
+  *	steps, thus letting the other two be used interchangeably.
+  *	Unfortunately Microsoft implementations force using NAME QUERY before
+  *	LLC CONNECTION. To overcome the problem we first put a link into
+  *	CONNWAIT, attach a session to it and first issue NAME QUERY then
+  *	request LLC CONNECTION. This function does the actual LLC connection
+  *	request on the dummy link.
+  *
+  * Parameters:
+  *	link_no	  : an integer representing link number in link table
+  *	session_no: an integer representing session number in link session table
+  *		    it is not currently used.
+  *
+  * Returns:
+  *	0	     : if dummy link is now established successfully.
+  *	-ECONNRESET  : if dummy link is reset
+  *	-EHOSTUNREACH: if LLC connection establishment failed.
+  */
+ int nbll_link_session(int link_no, unsigned char session_no)
+ {
+ 	link_t *nb_link;
+ 	int rc = -ECONNRESET;
+ 
+ 	spin_lock(&link_table.lock);
+ 	nb_link = link_table_entry(link_no);
+ 	if (!nb_link)
+ 		goto out;
+ 	nbll_link_hold(nb_link);
+ 	nbll_handle_event(NETBEUI_LINK_CONN_REQUEST, nb_link);
+ 	rc = -EHOSTUNREACH;
+ 	if (nb_link->state == NETBEUI_LINK_INITIAL) {
+ 		nbll_link_put(nb_link);
+ 		goto plink;
+ 	}
+ 	rc = 0;
+ plink:	nbll_link_put(nb_link);
+ out:	spin_unlock(&link_table.lock);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbll_detach_session
+  *	Detaches a session from its link session table. If the session was the
+  *	last session link, it tries to drop the link to free resources.
+  *
+  * Parameters:
+  *	link_no	  : an integer representing link number in link table
+  *	session_no: an integer representing session number in link session table
+  *
+  * Returns: none
+  */
+ void nbll_detach_session(int link_no, unsigned char session_no)
+ {
+ 	session_t *session;
+ 	link_t *nb_link;
+ 
+ 	spin_lock(&link_table.lock);
+ 	nb_link = link_table_entry(link_no);
+ 	if (!nb_link)
+ 		goto out;
+ 	nbll_link_hold(nb_link);
+ 	session = (session_t *)nb_link->session_table.addr[session_no];
+ 	if (session)
+ 		session->lsn = 0;
+ 	__dextab_delete_index(&nb_link->session_table, session_no);
+ 	if (dextab_count_entries(&nb_link->session_table) > 0)
+ 		goto plink;
+ 	nbll_handle_event(NETBEUI_LINK_DISC_REQUEST, nb_link);
+ 	nbll_link_put(nb_link);
+ plink:	nbll_link_put(nb_link);
+ out:	spin_lock(&link_table.lock);
+ }
+ 
+ /*
+  * Function: nbll_drop_link
+  *	Drops a specified link with its sessions.
+  *
+  * Parameters:
+  *	link_no	: an integer representing link number in link table.
+  *
+  * Returns: int
+  *	zero     : if the link dropped successfully.
+  *	negative : if operation fails.
+  *	           -EINVAL : the link number is invalid.
+  */
+ int nbll_drop_link(int link_no)
+ {
+ 	link_t *nb_link = nbll_get_link(link_no);
+ 	dextab_t *sn_tbl;
+ 	int i, sn_cnt, rc = -EINVAL;
+ 
+ 	if (!nb_link) /* Invalid link number */
+ 		goto out;
+ 	sn_tbl = &nb_link->session_table;
+ 	spin_lock_bh(&sn_tbl->lock);
+ 	rc = 0;
+ 	sn_cnt = sn_tbl->count;
+ 	for (i = sn_tbl->reserved; sn_cnt; i++) {
+ 		session_t *sn = sn_tbl->addr[i];
+ 
+ 		if (sn) {
+ 			nbll_detach_session(link_no, i);
+ 			nbss_abort_session(sn);
+ 			sn_cnt--;
+ 		}
+ 	}
+ 	spin_unlock_bh(&sn_tbl->lock);
+ 	nbll_link_put(nb_link);
+ out:	return rc;
+ }
+ 
+ /*
+  * LLC interface functions
+  * Data-in functions
+  */
+ /*
+  * Function: nbll_disconnect_all_links
+  *	Generates disconnection event on all NetBEUI links.
+  *
+  * Parameters: none
+  *
+  * Returns: none
+  */
+ static void nbll_disconnect_all_links(void)
+ {
+ 	int index;
+ 	link_t *nb_link;
+ 
+ 	spin_lock(&link_table.lock);
+ 	for (index = link_table.reserved; index < link_table.size; index++) {
+ 		nb_link = link_table_entry(index);
+ 		if (nb_link) {
+ 			nbll_handle_event(NETBEUI_LINK_DISC_REQUEST, nb_link);
+ 			nbll_link_put(nb_link);
+ 		}
+ 	}
+ 	spin_unlock(&link_table.lock);
+ }
+ 
+ /*
+  * Function: nbll_deliver_packet
+  *	While checking input I-Frame consistency, routes frame to session
+  *	service interface. Since manipulating I-Frames is always the
+  *	responsibility of session service, the dispatching mechanism is
+  *	implemented there.
+  *
+  * Parameters:
+  *	skb	 : sk_buff which holds actual data
+  *	prim_data: pointer to LLC primitive data description.
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- Imagine struct prim_if_block is the function that LLC calls in
+  *	  NetBEUI code and prim_data_u as argument to this function.
+  *
+  *	- This function is a barrier for ill frames with anomalous content.
+  */
+ static void nbll_deliver_packet(struct sk_buff *skb, prim_data_t *prim_data)
+ {
+ 	int command = ((packet_t *)(skb->data))->command;
+ 	link_t *nb_link = link_table_entry(prim_data->link_no);
+ 	session_t *session;
+ 
+ 	nbll_link_hold(nb_link);
+ 	/* Sanity check if command length and code is valid, all checks should
+ 	 * be done! */
+ 	/* It checks ill netbios headers, and prevents memory faults */
+ 	if (skb->len < NETBEUI_MIN_COMMAND_LEN ||
+ 	    command > NETBEUI_MAX_COMMAND_CODE ||
+ 	    skb->len < nb_command_header_len[command] ||
+ 	    ((packet_t *)skb->data)->delimiter != NETBEUI_DELIMITER ||
+ 	    ((packet_t *)skb->data)->dest_num >= nb_link->session_table.size)
+ 		goto err;
+ 	nb_link->iactivity++;
+ 	session = (session_t *)
+ 		nb_link->session_table.addr[((packet_t *)skb->data)->dest_num];
+ 	if (!session || command == NETBEUI_SESSION_ALIVE)
+ 		goto err;
+ 	nbss_deliver_frame(session, skb);
+ out:	nbll_link_put(nb_link);
+ 	return;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbll_deliver_datagram
+  *	The UI-Frame dispatcher
+  *	While checking input UI-Frame consistency, routes frame to final
+  *	destination in name service, session service and datagram distribution.
+  *	Due to different destinations the dispatching mechanism for UI-Frames is
+  *	implemented here in this function.
+  *
+  * Parameters:
+  *	skb	 : sk_buff which holds actual data
+  *	prim_data: pointer to LLC primitive data description.
+  *
+  * Returns: none
+  */
+ static void nbll_deliver_datagram(struct sk_buff *skb,
+ 				  prim_unit_data_t *prim_data)
+ {
+ 	int command = ((dgram_t *)(skb->data))->command;
+ 
+ 	/* Sanity check if command length and code is valid, all checks
+ 	 * should be done !!! */
+ 	/* It checks ill netbios headers, and prevents memory faults */
+ 	if (skb->len < NETBEUI_MIN_COMMAND_LEN ||
+ 	    command > NETBEUI_MAX_COMMAND_CODE ||
+ 	    skb->len < nb_command_header_len[command] ||
+ 	    ((dgram_t *)skb->data)->delimiter != NETBEUI_DELIMITER)
+ 		goto fskb;
+ 	/* Token Ring support */
+ 	skb->cb[0] = prim_data->lfb;
+ 
+ 	switch (command) {
+ 		case NETBEUI_ADD_GROUP_NAME_QUERY:
+ 			nbns_get_add_name_query(skb, prim_data->source_addr.mac,
+ 						NETBEUI_NAME_GROUP);
+ 			break;
+ 		case NETBEUI_ADD_NAME_QUERY:
+ 			nbns_get_add_name_query(skb, prim_data->source_addr.mac,
+ 						NETBEUI_NAME_UNIQUE);
+ 			break;
+ 		case NETBEUI_ADD_NAME_RESPONSE:
+ 			nbns_get_add_name_response(skb,
+ 						   prim_data->source_addr.mac);
+ 			break;
+ 		case NETBEUI_NAME_IN_CONFLICT:
+ 			nbns_get_name_conflict(skb);
+ 			break;
+ 		case NETBEUI_NAME_QUERY:
+ 			nbss_get_name_query(skb, prim_data->source_addr.mac);
+ 			break;
+ 		case NETBEUI_NAME_RECOGNIZED:
+ 			nbqs_get_name_recognized(skb,
+ 						 prim_data->source_addr.mac);
+ 			break;
+ 		case NETBEUI_DATAGRAM:
+ 			nbdg_get_datagram(skb);
+ 			break;
+ 		case NETBEUI_DATAGRAM_BROADCAST:
+ 			nbdg_get_datagram_broadcast(skb);
+ 			break;
+ 		case NETBEUI_STATUS_QUERY:
+ 			nbst_get_status_query(skb, prim_data->source_addr.mac);
+ 			break;
+ 		case NETBEUI_STATUS_RESPONSE:
+ 			nbst_get_status_response(skb,
+ 						 prim_data->source_addr.mac);
+ 			break;
+ 		case NETBEUI_TERMINATE_TRACE:
+ 		case NETBEUI_TERMINATE_TRACE2:
+ 			goto fskb;
+ 	}
+ out:	return;
+ fskb:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: netbeui_indicate
+  *	The callback for LLC indicate primitive dispatching
+  *	It dispatches LLC primitive to Link Service State Machine interfaces.
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns:
+  *	0	: always returns zero to LLC to inform indicate accepted.
+  *
+  * Note:
+  *	LLC flow control indication is not generated. We have used data
+  *	request/confirm to control flow. Think if it is a misconception
+  *	or is accepted anyway.
+  */
+ static int netbeui_indicate(struct prim_if_block *prim)
+ {
+ 	struct sk_buff *skb = NULL;
+ 
+ 	switch (prim->primitive) {
+ 		case P8022_DATAUNIT_PRIM:
+ 			skb = prim->data->udata.skb;
+ 			nbll_deliver_datagram(skb,
+ 					      (prim_unit_data_t *)prim->data);
+ 			break;
+ 		case P8022_CONNECT_PRIM:
+ 			nbll_get_connect_indicate(prim);
+ 			break;
+ 		case P8022_DATA_PRIM:
+ 			skb = prim->data->data.skb;
+ 			nbll_deliver_packet(skb, (prim_data_t *)prim->data);
+ 			break;
+ 		case P8022_DISCONNECT_PRIM:
+ 			nbll_get_disconnect_indicate(prim);
+ 			break;
+ 		case P8022_RESET_PRIM:
+ 			nbll_get_reset_indicate(prim);
+ 			break;
+ 		case P8022_FLOWCONTROL_PRIM:
+ 			break;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Function: netbeui_confirm
+  *	The callback for LLC confirm primitive dispatching
+  *	It dispatches LLC primitive to Link Service State Machine interfaces.
+  *
+  * Parameters:
+  *	prim	: pointer to primary interface block type, the LLC communication
+  *		  data structure. This is a union with different fields with
+  *		  different meaning for different purposes.
+  *
+  * Returns:
+  *	0	: always returns zero to LLC to inform confirm accepted.
+  *
+  * Note:
+  *	LLC reset confirm is not generated, since we never generate
+  *	reset request
+  */
+ static int netbeui_confirm(struct prim_if_block *prim)
+ {
+ 	int status = 0;
+ 
+ 	switch (prim->primitive) {
+ 		case P8022_CONNECT_PRIM:
+ 			nbll_get_connect_confirm(prim);		break;
+ 		case P8022_DATA_PRIM:
+ 			status = nbll_get_data_confirm(prim);	break;
+ 		case P8022_DISCONNECT_PRIM:
+ 			nbll_get_disconnect_confirm(prim);	break;
+ 		case P8022_RESET_PRIM:				break;
+ 	}
+ 	return status;
+ }
+ 
+ /*
+  * Function: netbeui_init
+  *	The starting point of NetBEUI module.
+  *	Since NetBEUI is distributed as a module, netbeui_init does all initial
+  *	steps itself.
+  *
+  * Parameters: none
+  *
+  * Returns: none
+  *	0 	: if module initialized successfully.
+  *	non-zero: if a step in initialization failed (mostly opening LLC sap)
+  */
+ static char banner[] __initdata =
+ 	KERN_INFO "NetBEUI 2.0 by Procom, 1997, Arnaldo C. Melo, 2001\n";
+ static char err_sap[] __initdata =
+ 	KERN_ERR "Error opening NetBIOS SAP 0x%X on LLC.\n";
+ static char err_socket[] __initdata =
+ 	KERN_ERR "Error registering NetBEUI socket.\n";
+ static char err_proc[] __initdata =
+ 	KERN_INFO "Error registering NetBEUI proc entries.\n";
+ 
+ static int __init netbeui_init(void)
+ {
+ 	int rc = 0;
+ 
+ 	printk(banner);
+ 	netbeui_sap = llc_sap_open(netbeui_indicate, netbeui_confirm,
+ 				   NetBEUI_SAP_NO);
+ 	if (!netbeui_sap) {
+ 		printk(err_sap);
+ 		goto err;
+ 	}
+ 	memset(adapters, 0, sizeof(adapters));
+ 
+ 	if (auto_bind) {
+ 		int i = 0;
+ 		struct net_device *dev;
+ 
+ 		read_lock(&dev_base_lock);
+ 		for (dev = dev_base; dev && i < NETBEUI_MAX_ADAPTERS;
+ 		     dev = dev->next)
+ 			if (nbcm_apt_dev(dev)) {
+ 				adapters[i++] = dev;
+ 				dev_mc_add(dev, NETBEUI_FUNCADDR(dev),
+ 					   dev->addr_len, 0);
+ 			}
+ 		read_unlock(&dev_base_lock);
+ 		binded_adapters_count = i;
+ 	}
+ 	nbns_init_name_number_1(adapters);
+ 	nbdg_set_dgbc_mtu();
+ 
+ 	if (nbso_init()) {
+ 		printk(err_socket);
+ 		goto err_sap;
+ 	}
+ 	if (netbeui_proc_init()) {
+ 		printk(err_proc);
+ 		goto err_nbso;
+ 	}
+ 	nbst_init_status();
+ out:	return rc;
+ err_nbso:
+ 	nbso_exit();
+ err_sap:
+ 	llc_sap_close(netbeui_sap);
+ err:	rc = -1;
+ 	goto out;
+ }
+ 
+ /*
+  * Function: netbeui_exit
+  *	The ending point of NetBEUI module.
+  *	Since NetBEUI is distributed as a module, netbeui_exit does all
+  *	housekeeping steps itself
+  *
+  * Parameters: none
+  *
+  * Returns: none
+  */
+ static char err_exit[] __exitdata =
+ 		KERN_ERR "Error unregistering NetBEUI socket.\n";
+ 
+ static void __exit netbeui_exit(void)
+ {
+ 	int i;
+ 
+ 	nbll_disconnect_all_links();
+ 	for (i = 0; i < binded_adapters_count; i++)
+ 		dev_mc_delete(adapters[i], NETBEUI_FUNCADDR(adapters[i]),
+ 		              adapters[i]->addr_len, 0);
+ 	if (nbso_exit())
+ 		printk(err_exit);
+ 	netbeui_proc_clean();
+ 	llc_sap_close(netbeui_sap);
+ }
+ module_init(netbeui_init);
+ module_exit(netbeui_exit);
Index: kernel-acme/net/netbeui/name_serve.c
diff -c /dev/null kernel-acme/net/netbeui/name_serve.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:38 2001
--- kernel-acme/net/netbeui/name_serve.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,973 ----
+ /*
+  * name_serve.c - Contains functions that implement NetBIOS Name Service
+  *
+  * Notes:
+  *	- Two intermixed structures hold local name table a dextab_t that is
+  *	  used for assigning numbers to names and implicit name rule checking
+  *	  and a unidirectional linked list which is used for name search. every
+  *	  name entry may be found in both data structures.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/sched.h>
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/errno.h>
+ #include <linux/timer.h>
+ #include <linux/skbuff.h>
+ #include <linux/netbeui.h>
+ 
+ static void nbns_timer_function(unsigned long input);
+ 
+ /* These functions are Name State Transition handlers */
+ static int nbns_add_name_in_initial(name_t *nb_name);
+ static int nbns_retry_timeout_in_all(name_t *nb_name);
+ static int nbns_response_timeout_in_addwait(name_t *nb_name);
+ static int nbns_add_name_response1_in_addwait(name_t *nb_name);
+ static int nbns_add_name_query_in_addwait(name_t *nb_name);
+ static int nbns_response_timeout_in_collided(name_t *nb_name);
+ static int nbns_add_name_response2_in_collided(name_t *nb_name);
+ static int nbns_add_name_query_in_acquired(name_t *nb_name);
+ static int nbns_name_conflict_in_acquired(name_t *nb_name);
+ static int nbns_remove_name_in_acquired(name_t *nb_name);
+ 
+ static void nbns_handle_event(name_event_t event, name_t *nb_name);
+ static unsigned short int nbns_correlator;
+ #define nbns_next_correlator() (++nbns_correlator)
+ 
+ /* We need to have two paths to access names from dextab and linked-list */
+ static name_t *name_list;
+ static rwlock_t name_list_lock = RW_LOCK_UNLOCKED;
+ dextab_t name_table = {
+ 	reserved:	2,
+ 	max_size:	NETBEUI_MAX_NAMES,
+ 	lock:		SPIN_LOCK_UNLOCKED
+ };
+ name_t name_number_1;
+ 
+ #define name_table_entry(i)	((name_t *)name_table.addr[i])
+ 
+ /* Name Service State Machine definition */
+ typedef int (* name_event_handler_t)(name_t *);
+ 
+ struct event_struct {
+ 	name_state_t  next_state;
+ 	name_event_handler_t event_handler;
+ };
+ static struct event_struct name_state_table[4][8] = {
+ 			/* NETBEUI_NAME_INITIAL */
+ {
+ { NETBEUI_NAME_ADDWAIT,
+ 	nbns_add_name_in_initial }, /* NETBEUI_NAME_ADD_NAME */
+ { -1, NULL },			    /* NETBEUI_NAME_RETRY_TIMEOUT */
+ { -1, NULL },			    /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+ { -1, NULL },			    /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+ { -1, NULL },			    /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+ { -1, NULL },			    /* NETBEUI_NAME_ADD_NAME_QUERY */
+ { -1, NULL },			    /* NETBEUI_NAME_NAME_CONFLICT */
+ { -1, NULL }			    /* NETBEUI_NAME_REMOVE_NAME */
+ },
+ 			/* NETBEUI_NAME_ADDWAIT  */
+ {
+ { -1, NULL },				   /* NETBEUI_NAME_ADD_NAME */
+ { NETBEUI_NAME_ADDWAIT,
+ 	nbns_retry_timeout_in_all },	   /* NETBEUI_NAME_RETRY_TIMEOUT */
+ { NETBEUI_NAME_ACQUIRED,
+ 	nbns_response_timeout_in_addwait }, /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+ { NETBEUI_NAME_COLLIDED,
+ 	nbns_add_name_response1_in_addwait }, /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+ { -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+ {NETBEUI_NAME_ADDWAIT,
+ 	nbns_add_name_query_in_addwait },  /* NETBEUI_NAME_ADD_NAME_QUERY */
+ { -1, NULL },				   /* NETBEUI_NAME_NAME_CONFLICT */
+ { -1, NULL }				   /* NETBEUI_NAME_REMOVE_NAME */
+ },
+ 			/* NETBEUI_NAME_COLLIDED */
+ {
+ { -1, NULL },				     /* NETBEUI_NAME_ADD_NAME */
+ { NETBEUI_NAME_COLLIDED,
+ 	nbns_retry_timeout_in_all },	     /* NETBEUI_NAME_RETRY_TIMEOUT */
+ { NETBEUI_NAME_INITIAL,
+ 	nbns_response_timeout_in_collided }, /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+ { -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+ { NETBEUI_NAME_INITIAL,
+ 	nbns_add_name_response2_in_collided }, /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+ { -1, NULL },				     /* NETBEUI_NAME_ADD_NAME_QUERY */
+ { -1, NULL },				     /* NETBEUI_NAME_NAME_CONFLICT */
+ { -1, NULL }				     /* NETBEUI_NAME_REMOVE_NAME */
+ },
+ 			/* NETBEUI_NAME_ACQUIRED */
+ {
+ { -1, NULL },				   /* NETBEUI_NAME_ADD_NAME */
+ { -1, NULL },				   /* NETBEUI_NAME_RETRY_TIMEOUT */
+ { -1, NULL }, 				   /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+ { -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+ { -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+ { NETBEUI_NAME_ACQUIRED,
+ 	nbns_add_name_query_in_acquired }, /* NETBEUI_NAME_ADD_NAME_QUERY */
+ { NETBEUI_NAME_ACQUIRED,
+ 	nbns_name_conflict_in_acquired },  /* NETBEUI_NAME_NAME_CONFLICT */
+ { NETBEUI_NAME_INITIAL,
+ 	nbns_remove_name_in_acquired },    /* NETBEUI_NAME_REMOVE_NAME */
+ }
+ };
+ 
+ /* NAME_NUMBER_1 assignment and interface functions */
+ /*
+  * Function: nbns_dev_name_number_1
+  *	Returns the name number of built by device MAC address
+  *
+  * Parameters:
+  *	dev	: pointer to device structure to build its NAME_NUMBER_1
+  *
+  * Returns:
+  *	non-NULL: pointer to NAME_NUMBER_1 built by device MAC address
+  *
+  * Note:
+  *	NAME_NUMBER_1 is defined as (16-n) bytes zero concatenated by (n)
+  *	bytes of MAC address, where n is size of MAC address in bytes.
+  */
+ unsigned char *nbns_dev_name_number_1(struct net_device *dev)
+ {
+ 	static char dev_name_number_1[NETBEUI_NAME_LEN];
+ 	int zero_count = NETBEUI_NAME_LEN - dev->addr_len;
+ 
+ 	memset(dev_name_number_1, 0, zero_count);
+ 	memcpy(dev_name_number_1 + zero_count, dev->dev_addr, dev->addr_len);
+ 	return dev_name_number_1;
+ }
+ 
+ /*
+  * Function: nbns_validate_name
+  *	Checks a NetBIOS name validity according to NetBIOS name rules.
+  *
+  * Parameters:
+  *	name	: pointer to NetBIOS name
+  *
+  * Returns:
+  *	0	: if name is a valid NetBIOS name
+  *	non-zero: if name is not a valid NetBIOS name
+  */
+ int nbns_validate_name(char *name)
+ {
+ 	return (!memcmp(name, "IBM", 3) ||
+ 		 memchr(name, '\0', NETBEUI_NAME_LEN - 1)) ? -1 : 0;
+ }
+ 
+ /*
+  * Function: nbns_init_name_number_1
+  *	Finds a correct value for NAME_NUMBER_1
+  *
+  * Parameters:
+  *	adapters: list of adapters the NetBEUI is bound to
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- A NetBEUI implementation should provide a unique NAME_NUMBER_1.
+  *	  Since our implementations supports both multiple interface and
+  *	  loopback device, we need to decide on the device that is used
+  *	  for generating NAME_NUMBER_1.
+  */
+ void nbns_init_name_number_1(struct net_device *adapters[])
+ {
+ 	name_number_1.type	  = NETBEUI_NAME_UNIQUE;
+ 	name_number_1.state	  = NETBEUI_NAME_ACQUIRED;
+ 	name_number_1.name_number = 1;
+ 
+ 	if (adapters[0] && !(adapters[0]->flags & IFF_LOOPBACK)) {
+ 		memcpy(name_number_1.name, nbns_dev_name_number_1(adapters[0]),
+ 		       NETBEUI_NAME_LEN);
+ 		goto out;
+ 	}
+ 	if (adapters[1]) {
+ 		memcpy(name_number_1.name, nbns_dev_name_number_1(adapters[1]),
+ 		       NETBEUI_NAME_LEN);
+ 		goto out;
+ 	}
+ 	if (adapters[0]) {
+ 		memcpy(name_number_1.name, "LOOPBACK DEVICE   ",
+ 		       NETBEUI_NAME_LEN);
+ 		goto out;
+ 	}
+ 	name_number_1.name_number = -1;
+ out:;
+ }
+ 
+ /*
+  * Function: nbns_name_number_1
+  *	The Name Service interface access routine for NAME_NUMBER_1
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	non-NULL: pointer to name_t structure that holds NAME_NUMBER_1
+  */
+ name_t *nbns_name_number_1(void)
+ {
+ 	return name_number_1.name_number == 1 ? &name_number_1 : NULL;
+ }
+ 
+ /*
+  * Name service state machine functions
+  * Implementing general functions
+  */
+ 
+ /*
+  * Function: nbns_alloc_skb
+  *	allocates a sk_buff that suits Name Service framing needs
+  *
+  * Parameters:
+  *	data_len: number of data bytes that the calling routine intends
+  *		  to put in skb
+  *
+  * Returns:
+  *	NULL	: if can not allocate memory for skb
+  *	non-NULL: pointer to skb allocated with data_len bytes space for data
+  */
+ static struct sk_buff *nbns_alloc_skb(int mac_hlen, int data_len)
+ {
+ 	struct sk_buff *skb = alloc_skb(CALC_DG_SKBLEN(mac_hlen, data_len),
+ 					GFP_ATOMIC);
+ 	if (!skb)
+ 		return NULL;
+ 	skb_reserve(skb, LLCMAC_UI_HEADLEN(mac_hlen));
+ 	skb->nh.raw = skb->h.raw = skb->data;
+ 	skb_put(skb, data_len);
+ 	skb->dev = NULL;
+ 	return skb;
+ }
+ 
+ /*
+  * Function: nbns_alloc_name
+  *	Allocates a name_t structure and does completely initialize all fields
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	NULL	: if can not allocate memory for name_t or its sk_buff
+  *	non-NULL: pointer to name_t
+  *
+  * Notes:
+  *	- An skb is attached to each new name for name registration purposes
+  *	- Name timer is initialized but not started.
+  *	- The call to memset does implicitly initialize all fields. Those
+  *	  fields that need explicit non-zero initialization are manipulated
+  *	  afterwards.
+  */
+ static name_t *nbns_alloc_name(void)
+ {
+ 	name_t *nb_name = kmalloc(sizeof(*nb_name), GFP_ATOMIC);
+ 
+ 	if (!nb_name)
+ 		goto out;
+ 	/* Implicitly initialize all fields */
+ 	memset(nb_name, 0, sizeof(*nb_name));
+ 	init_timer(&nb_name->timer);
+ 	nb_name->timer.data	= (unsigned long)nb_name;
+ 	nb_name->timer.function	= nbns_timer_function;
+ 	init_waitqueue_head(&nb_name->waitq);
+ 	atomic_set(&nb_name->refcnt, 1);
+ 	/* Allocate name skb */
+ 	nb_name->skb = nbns_alloc_skb(NETBEUI_MAC_B_HEADLEN,
+ 				 nb_command_header_len[NETBEUI_ADD_NAME_QUERY]);
+ 	if (!nb_name->skb) {
+ 		kfree(nb_name);
+ 		nb_name = NULL;
+ 	}
+ out:	return nb_name;
+ }
+ 
+ /*
+  * Function: nbns_free_name
+  *	Deallocates memory used for name_t and its sk_buff
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t memory to be freed
+  *
+  * Returns: none
+  */
+ static void __nbns_free_name(name_t *nb_name)
+ {
+ 	kfree_skb(nb_name->skb);
+ 	kfree(nb_name);
+ }
+ 
+ static void nbns_free_name(name_t *nb_name)
+ {
+ 	netbeui_proc_del_name(nb_name);
+ 	nbns_handle_event(NETBEUI_NAME_REMOVE_NAME, nb_name);
+ 	__nbns_free_name(nb_name);
+ }
+ 
+ inline void nbns_name_hold(name_t *nb_name)
+ {
+ 	atomic_inc(&nb_name->refcnt);
+ }
+ 
+ inline void nbns_name_put(name_t *nb_name)
+ {
+ 	if (atomic_dec_and_test(&nb_name->refcnt))
+ 		nbns_free_name(nb_name);
+ }
+ 
+ /*
+  * Function: nbns_add_name_to_table
+  *	Inserts a previously allocated/initialized name_t into system local
+  *	name table and local name list.
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t to insert
+  *
+  * Returns:
+  *	0	: if name is successfully inserted into name table
+  *	-ENOSPC : if local name table is full
+  */
+ static int nbns_add_name_to_table(name_t *nb_name)
+ {
+ 	/* Allocate a name table entry  */
+ 	int name_number = dextab_insert_entry(&name_table, nb_name);
+ 
+ 	if (name_number <= 1)
+ 		return -ENOSPC;
+ 	nb_name->name_number = name_number;
+ 	/* Add name to name list */
+ 	write_lock_bh(&name_list_lock);
+ 	nb_name->next	     = name_list;
+ 	name_list	     = nb_name;
+ 	write_unlock_bh(&name_list_lock);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbns_remove_name_from_table
+  *	Removes a name from system local name table.
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t to remove
+  *
+  * Returns: none
+  */
+ static void nbns_remove_name_from_table(name_t *nb_name)
+ {
+ 	name_t *entry;
+ 	name_t *prev_entry = NULL;
+ 
+ 	dextab_delete_entry(&name_table, nb_name);
+ 	write_lock_bh(&name_list_lock);
+ 	entry = name_list;
+ 	while (entry) {
+ 		if (entry == nb_name) {
+ 			if (prev_entry)
+ 				prev_entry->next = entry->next;
+ 			else
+ 				name_list = entry->next;
+ 			break;
+ 		}
+ 		prev_entry = entry;
+ 		entry = entry->next;
+ 	}
+ 	write_unlock_bh(&name_list_lock);
+ }
+ 
+ /*
+  * Function: nbns_find_correlator
+  *	Finds a name in local name list, which has a specific NetBIOS name
+  *	and has transmitted frames with a specific correlator
+  *
+  * Parameters:
+  *	correlator : a sixteen bit integer which contains the response
+  *	             correlator of input frame. It should be matched against
+  *		     xmit correlator of frames sent by the element.
+  *	name	   : pointer to NetBIOS name that the requested element should
+  *		     have
+  *
+  * Returns:
+  *	NULL	   : if no name_t element found with the requested
+  *		     characteristics
+  *	non-NULL   : pointer to matching name_t with requested characteristics
+  *
+  * Notes:
+  *	- This routine is useful for relating incoming response frames with
+  *	  name elements that have transmitted requests to remote nodes.
+  */
+ static name_t *nbns_find_correlator(unsigned short correlator, char *name)
+ {
+ 	name_t *nb_name;
+ 
+ 	read_lock_bh(&name_list_lock);
+ 	nb_name = name_list;
+ 	while (nb_name)
+ 		if (nb_name->resp_correlator == correlator &&
+ 		    nb_name->state != NETBEUI_NAME_ACQUIRED &&
+ 		    !memcmp(nb_name->name, name, NETBEUI_NAME_LEN))
+ 			break;
+ 		else
+ 			nb_name = nb_name->next;
+ 	if (nb_name)
+ 		nbns_name_hold(nb_name);
+ 	read_unlock_bh(&name_list_lock);
+ 	return nb_name;
+ }
+ 
+ /*
+  * Function: nbns_boradcast_add_name_query
+  *	Prepares a NetBIOS ADD NAME QUERY frame and nbll_uisends it to network
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t structure which the frame should be built
+  *		  for
+  *
+  * Returns:
+  *	0 	: if frame is successfully broadcasted to network
+  *	non-zero: if frame transmission encountered an error (usually at NDI
+  *		  layer)
+  *
+  * Notes:
+  *	- Since ADD NAME QUERY frames are retransmitted in timed intervals, it
+  *	  is considered to build frame once, but transmit it multiple times.
+  *	  having built frames in each retransmission does generate multiple
+  *	  correlators and does frustrate processing responses.
+  */
+ static int nbns_broadcast_add_name_query(name_t *nb_name)
+ {
+ 	if (!nb_name->retries) {
+ 		dgram_t *hdr = (dgram_t *)nb_name->skb->data;
+ 
+ 		hdr->length	= nb_command_header_len[NETBEUI_ADD_NAME_QUERY];
+ 		hdr->delimiter	= NETBEUI_DELIMITER;
+ 		hdr->command	= nb_name->type == NETBEUI_NAME_UNIQUE ?
+ 						   NETBEUI_ADD_NAME_QUERY :
+ 						   NETBEUI_ADD_GROUP_NAME_QUERY;
+ 		hdr->data1		= 0;
+ 		hdr->data2		= 0;
+ 		hdr->xmit_correlator	= 0;
+ 		hdr->resp_correlator	= nb_name->resp_correlator =
+ 							nbns_next_correlator();
+ 		memset(hdr->dest_name, 0, NETBEUI_NAME_LEN);
+ 		memcpy(hdr->source_name, nb_name->name, NETBEUI_NAME_LEN);
+ 	}
+ 	return nbll_uisend(NULL, nb_name->skb);
+ }
+ 
+ /*
+  * Function: nbns_broadcast_name_in_conflict
+  *	Prepares a NetBIOS NAME IN CONFLICT frame and nbll_uisends it to network
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t structure which the frame should be built
+  *		  for
+  *
+  * Returns:
+  *	0 	: if frame is successfully broadcasted to network
+  *	non-zero: if frame transmission encountered an error (usually at NDI
+  *		  layer)
+  */
+ static int nbns_broadcast_name_in_conflict(name_t *nb_name)
+ {
+ 	dgram_t *hdr = (dgram_t *)nb_name->skb->data;
+ 
+ 	hdr->length	= nb_command_header_len[NETBEUI_NAME_IN_CONFLICT];
+ 	hdr->delimiter	= NETBEUI_DELIMITER;
+ 	hdr->command	= NETBEUI_NAME_IN_CONFLICT;
+ 	hdr->data1	= hdr->data2 = 0;
+ 	hdr->xmit_correlator = hdr->resp_correlator = 0;
+ 	memcpy(hdr->dest_name, nb_name->name, NETBEUI_NAME_LEN);
+ 	memcpy(hdr->source_name, nbns_name_number_1()->name, NETBEUI_NAME_LEN);
+ 	return nbll_uisend(NULL, nb_name->skb);
+ }
+ 
+ /*
+  * Function: nbns_unicast_add_name_response
+  *	Prepares a NetBIOS ADD NAME RESPONSE frame and nbll_uisends it to
+  *	network
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t structure which the frame should be built
+  *		  for
+  *
+  * Returns:
+  *	0 	: if frame is successfully broadcasted to network
+  *	non-zero: if frame transmission encountered an error (usually at NDI
+  *		  layer) or it can not allocate memory for frame.
+  *
+  * Note:
+  *	- The lack of memory and inability to send response frame may cause
+  *	  a name to conflict on network. This is simply the case on a heavily
+  *	  loaded server, however since the query is retransmitted multiple times
+  *	  we hope the server would be able to defend its name at least once. In
+  *	  addition if an administrator finds the case he can increase either
+  *	  retransmissions or timeouts for all nodes on network.
+  */
+ static int nbns_unicast_add_name_response(name_t *nb_name)
+ {
+ 	dgram_t *hdr;
+ 	struct sk_buff *skb = nbns_alloc_skb(MAC_HEADLEN(nb_name->remote_dev),
+ 			      nb_command_header_len[NETBEUI_ADD_NAME_RESPONSE]);
+ 
+ 	if (!skb)
+ 		return -ENOMEM;
+ 	hdr		= (dgram_t *)skb->data;
+ 	hdr->length	= nb_command_header_len[NETBEUI_ADD_NAME_RESPONSE];
+ 	hdr->delimiter	= NETBEUI_DELIMITER;
+ 	hdr->command	= NETBEUI_ADD_NAME_RESPONSE;
+ 	hdr->data1	= nb_name->state == NETBEUI_NAME_ACQUIRED ? 0 : 1;
+ 	hdr->data2	= nb_name->type;
+ 	hdr->xmit_correlator	= nb_name->xmit_correlator;
+ 	hdr->resp_correlator	= 0;
+ 	memcpy(hdr->source_name, nb_name->name, NETBEUI_NAME_LEN);
+ 	memcpy(hdr->dest_name, nb_name->name, NETBEUI_NAME_LEN);
+ 	skb->dev	= nb_name->remote_dev;
+ 	return nbll_uisend(nb_name->remote_mac, skb);
+ }
+ 
+ /*
+  * Function: nbns_handle_event
+  *	This is the heart of Name Service State Machine, which performs a
+  *	transition from current state of name element to new state based
+  *	on event occurred and name state table contents.
+  *
+  * Parameters:
+  *	event	: An integer of NETBEUI_NAME_* family that implies type of event
+  *	nb_name	: pointer to name_t structure which the event occurred on
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- The state changes before actions be executed. This is due to
+  *	  non deterministic behavior of actions which may sleep the current
+  *	  process, thus stopping the function in the mid-way.
+  */
+ static void nbns_handle_event(name_event_t event, name_t *nb_name)
+ {
+ 	struct event_struct *ev = &name_state_table[nb_name->state][event];
+ 
+ 	if (ev && ev->event_handler) {
+ 		unsigned char old_state = nb_name->state;
+ 
+ 		nb_name->state = ev->next_state;
+ 		if (ev->event_handler(nb_name))
+ 			nb_name->state = old_state;
+ 	}
+ }
+ 
+ /*
+  * Function: nbns_timer_function
+  *	This is the callback function triggered upon expiration of name
+  *	retransmittion timer. It just injects an event into state machine for
+  *	its link.
+  *
+  * Parameters:
+  *	input	: pointer to name_t structure whose timer is expired.
+  *
+  * Returns: none
+  */
+ static void nbns_timer_function(unsigned long input)
+ {
+ 	name_t *nb_name = (name_t *)input;
+ 
+ 	if (nb_name->retries < NETBEUI_TRANSMIT_COUNT)
+ 		nbns_handle_event(NETBEUI_NAME_RETRY_TIMEOUT, nb_name);
+ 	else
+ 		nbns_handle_event(NETBEUI_NAME_RESPONSE_TIMEOUT, nb_name);
+ }
+ 
+ /*
+  * Name service state machine functions
+  * Implementing transition functions
+  */
+ /*
+  * Function: nbns_xxxx_in_ssss
+  *	The section below contains functions that implement actions needed
+  *	to  legally transit from one state to another.
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t structure which the actions are to be
+  *		  applied to
+  *
+  * Returns:
+  *	0	: if all actions are done successfully
+  *	non-zero: if one of actions failed
+  *
+  * Note:
+  *	- For the sake of simplicity, the actions are automatically rollbacked
+  *	  in each function, if an action in transition fails. The design
+  *	  documents do not cover these parts of code.
+  */
+ static int nbns_add_name_in_initial(name_t *nb_name)
+ {
+ 	int rc = -1;
+ 
+ 	nb_name->retries = 0;
+ 	nb_name->status  = nbns_broadcast_add_name_query(nb_name);
+ 	if (nb_name->status)
+ 		goto out;
+ 	nb_name->status = nbns_add_name_to_table(nb_name);
+ 	if (nb_name->status)
+ 		goto out;
+ 	rc = 0;
+ 	nb_name->retries++;
+ 	nb_name->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+ 	add_timer(&nb_name->timer);
+ 	sleep_on(&nb_name->waitq);
+ out:	return rc;
+ }
+ 
+ static int nbns_retry_timeout_in_all(name_t *nb_name)
+ {
+ 	nb_name->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+ 	add_timer(&nb_name->timer);
+ 
+ 	if (nbns_broadcast_add_name_query(nb_name))
+ 		return -1;
+ 	nb_name->retries++;
+ 	return 0;
+ }
+ 
+ static int nbns_response_timeout_in_addwait(name_t *nb_name)
+ {
+ 	wake_up(&nb_name->waitq);
+ 	return 0;
+ }
+ 
+ static int nbns_add_name_response1_in_addwait(name_t *nb_name)
+ {
+ 	nb_name->status = -EADDRINUSE;
+ 	return 0;
+ }
+ 
+ static int nbns_add_name_query_in_addwait(name_t *nb_name)
+ {
+ 	return nbns_unicast_add_name_response(nb_name) ? -1 : 0;
+ }
+ 
+ static int nbns_response_timeout_in_collided(name_t *nb_name)
+ {
+ 	wake_up(&nb_name->waitq);
+ 	nbns_remove_name_from_table(nb_name);
+ 	return 0;
+ }
+ 
+ static int nbns_add_name_response2_in_collided(name_t *nb_name)
+ {
+ 	nbns_broadcast_name_in_conflict(nb_name);
+ 	del_timer(&nb_name->timer);
+ 	wake_up(&nb_name->waitq);
+ 	nbns_remove_name_from_table(nb_name);
+ 	return 0;
+ }
+ 
+ static int nbns_add_name_query_in_acquired(name_t *nb_name)
+ {
+ 	return nbns_unicast_add_name_response(nb_name) ? -1 : 0;
+ }
+ 
+ static int nbns_name_conflict_in_acquired(name_t *nb_name)
+ {
+ 	nb_name->conflicted = 1;
+ 	return 0;
+ }
+ 
+ static int nbns_remove_name_in_acquired(name_t *nb_name)
+ {
+ 	nbns_remove_name_from_table(nb_name);
+ 	return 0;
+ }
+ 
+ /*
+  * Name service state machine functions
+  * Implementing interface functions
+  */
+ /*
+  * Function: nbns_add_name
+  *	Adds a name to local name table after checking network (being
+  *	permitted).
+  *
+  * Parameters:
+  *	name	: pointer to 16 byte NetBIOS name
+  *	type	: type of NetBIOS name that is NETBEUI_NAME_GROUP,
+  *		  NETBEUI_NAME_UNIQUE
+  *	out_name: pointer to name_t structure built for that name. Since this
+  *		  a result argument, its value depends on function return value
+  *		  if return value specifies successful operation then this
+  *		  argument contains a valid pointer.
+  *
+  * Returns:
+  *	0	   : if name successfully registered into local name table
+  *	-EINVAL    : if name is not a valid NetBIOS name
+  *	-EADDRINUSE: if name is registered either in local name table or
+  *		     on another machine in network.
+  *	-ENOMEM	   : if memory allocation for name element name_t fails
+  *	others	   : any other error value reported by LLC or system.
+  */
+ int nbns_add_name(char *name, name_type_t type, name_t **out_name)
+ {
+ 	name_t *nb_name;
+ 	int rc = -EINVAL;
+ 
+ 	if (nbns_validate_name(name))
+ 		goto out;
+ 	rc = -EADDRINUSE;
+ 	nb_name = nbns_find_name(name);
+ 	if (nb_name)
+ 		goto out_put;
+ 	nb_name = nbns_alloc_name();
+ 	rc = -ENOMEM;
+ 	if (!nb_name)
+ 		goto out;
+ 	*out_name = NULL;
+ 	nb_name->state	= NETBEUI_NAME_INITIAL;
+ 	nb_name->type	= type;
+ 	memcpy(nb_name->name, name, NETBEUI_NAME_LEN);
+ 	nbns_handle_event(NETBEUI_NAME_ADD_NAME, nb_name);
+ 	if (nb_name->state != NETBEUI_NAME_ACQUIRED) {
+ 		rc = nb_name->status ? : -1;
+ 		__nbns_free_name(nb_name);
+ 		goto out;
+ 	}
+ 	if (netbeui_proc_add_name(nb_name))
+ 		printk(KERN_WARNING __FUNCTION__
+ 		       ": netbeui_proc_add_name failed!\n");
+ 	rc = 0;
+ 	*out_name = nb_name;
+ 	nbns_name_hold(nb_name);
+ out:	return rc;
+ out_put:
+ 	nbns_name_put(nb_name);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbns_find_name
+  *	Finds a name with a specific 16 bytes NetBIOS name in local name table.
+  *
+  * Parameters:
+  *	name	: pointer to 16 bytes NetBIOS name to be located in local name
+  *		  table.
+  *
+  * Returns:
+  *	NULL	: if NetBIOS name not found in local name table
+  *	non-NULL: pointer to name_t element found in local name table.
+  */
+ name_t *nbns_find_name(char *name)
+ {
+ 	name_t *nb_name;
+ 
+ 	read_lock_bh(&name_list_lock);
+ 	nb_name = name_list;
+ 	while (nb_name) {
+ 		if (!memcmp(nb_name->name, name, NETBEUI_NAME_LEN))
+ 			break;
+ 		nb_name = nb_name->next;
+ 	}
+ 	if (nb_name)
+ 		nbns_name_hold(nb_name);
+ 	read_unlock_bh(&name_list_lock);
+ 	return nb_name;
+ }
+ 
+ /*
+  * Function: nbns_del_name
+  *	Removes a name_t element from local name table and local name list,
+  *	using its NetBIOS name.
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t element to remove from local name table
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- Removing the name_t is a multi-pass mechanism depending on the value
+  *	  of name use count. A name is actually removed from local name table
+  *	  when its use count reaches zero.
+  */
+ void nbns_del_name(name_t *nb_name)
+ {
+ 	if (nb_name->name_number != 1)
+ 		nbns_name_put(nb_name);
+ }
+ 
+ /*
+  * Function: nbns_del_identifier
+  *	Removes a name_t element from local name table and local name list,
+  *	using its identification number.
+  *
+  * Parameters:
+  *	id	: id or number of the name to remove from local name table
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- Refer to notes section of nbns_del_name comment
+  *	- The identification number is a notion used in sock_name. Every
+  *	  SOCK_NAME type socket assigns a unique identifier to all the name
+  *	  it registers, which lets not to keep another table of registered
+  *	  names in socket data structures. The value is simple memory address
+  *	  of socket and is assigned directly from SOCK_NAME codes.
+  *	- Multiple names may have similar identifier.
+  */
+ void nbns_del_identifier(unsigned long id)
+ {
+ 	name_t *nb_name;
+ 	int index;
+ 
+ 	for (index = name_table.reserved; index < name_table.size; index++) {
+ 		nb_name = name_table_entry(index);
+ 		if (nb_name && nb_name->identifier == id)
+ 			nbns_del_name(nb_name);
+ 	}
+ }
+ 
+ /*
+  * Function: nbns_get_add_name_query
+  *	Accepts an ADD NAME QUERY frame and generates an event for Name
+  *	Service State Machine.
+  *
+  * Parameters:
+  *	skb	  : pointer to sk_buff that holds the frame
+  *	remote_mac: pointer to MAC address of remote node, whom sent the frame
+  *	type	  : the flag indicates the type of query:
+  *			NETBEUI_NAME_GROUP indicates ADD GROUP NAME QUERY
+  *			NETBEUI_NAME_UNIQUE indicates ADD NAME QUERY
+  *
+  * Returns: none
+  */
+ void nbns_get_add_name_query(struct sk_buff *skb, unsigned char *remote_mac,
+ 			     int type)
+ {
+ 	dgram_t *hdr = (dgram_t *)skb->data;
+ 	name_t *nb_name = nbns_find_name(hdr->source_name);
+ 
+ 	/* If name not found in name table or both are group names */
+ 	if (!nb_name)
+ 	       goto out;
+ 	if ((skb->dev->flags & IFF_LOOPBACK) ||
+             (nb_name->type == NETBEUI_NAME_GROUP && type == NETBEUI_NAME_GROUP))
+ 		goto out_put;
+ 	memcpy(nb_name->remote_mac, remote_mac, skb->dev->addr_len);
+ 	nb_name->remote_dev	 = skb->dev;
+ 	nb_name->xmit_correlator = hdr->resp_correlator;
+ 	nbns_handle_event(NETBEUI_NAME_ADD_NAME_QUERY, nb_name);
+ out_put:
+ 	nbns_name_put(nb_name);
+ out:	kfree_skb(skb);
+ }
+ 
+ /*
+  * Function: nbns_get_add_name_response
+  *	Accepts an ADD NAME RESPONSE frame and generates an event for Name
+  *	Service State Machine.
+  *
+  * Parameters:
+  *	skb	  : pointer to sk_buff that holds the frame
+  *	remote_mac: pointer to MAC address of remote node, whom sent the frame
+  *
+  * Returns: none
+  */
+ void nbns_get_add_name_response(struct sk_buff *skb, unsigned char *remote_mac)
+ {
+ 	dgram_t *hdr = (dgram_t *)skb->data;
+ 	name_t *nb_name = nbns_find_correlator(hdr->xmit_correlator,
+ 					       hdr->dest_name);
+ 	/* If it does not match a query */
+ 	if (!nb_name)
+ 		goto out;
+ 	/* The name registration query got a negative response */
+ 	/* Test if it is a duplicate and already received */
+ 
+ 	if (nb_name->remote_dev != skb->dev ||
+ 	    memcmp(nb_name->remote_mac, remote_mac, skb->dev->addr_len)) {
+ 		nb_name->remote_dev = skb->dev;
+ 		memcpy(nb_name->remote_mac, remote_mac, skb->dev->addr_len);
+ 		nb_name->responses++;
+ 		if (nb_name->responses == 1)
+ 			nbns_handle_event(NETBEUI_NAME_ADD_NAME_RESPONSE1,
+ 					  nb_name);
+ 		else
+ 			nbns_handle_event(NETBEUI_NAME_ADD_NAME_RESPONSE2,
+ 					  nb_name);
+ 	}
+ 	nbns_name_put(nb_name);
+ out:	kfree_skb(skb);
+ }
+ 
+ /*
+  * Function: nbns_get_name_conflict
+  *	Accepts a NAME CONFLICT frame and generates an event for Name
+  *	Service State Machine.
+  *
+  * Parameters:
+  *	skb	  : pointer to sk_buff that holds the frame
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- The strategy chosen for manipulating NAME CONFLICT frames is to
+  *	  set a flag in name_t structure, which is available via /proc entry
+  *	  interface.
+  */
+ void nbns_get_name_conflict(struct sk_buff *skb)
+ {
+ 	name_t *nb_name = nbns_find_name(((dgram_t *)skb->data)->source_name);
+ 
+ 	if (nb_name) {
+ 		nbns_handle_event(NETBEUI_NAME_NAME_CONFLICT, nb_name);
+ 		nbns_name_put(nb_name);
+ 	}
+ 	kfree_skb(skb);
+ }
+ 
+ /*
+  * Function: nbns_get_link_table
+  *	returns a pointer to NetBEUI name table. The proc support code uses
+  *	the name table to map its contents to /proc/sys/netbeui entry.
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	non-NULL: pointer to NetBEUI name table
+  */
+ dextab_t *nbns_get_name_table(void)
+ {
+ 	return &name_table;
+ }
+ 
+ /*
+  * Function: nbns_get_name_list
+  *	returns a pointer to NetBEUI name list. The status module uses
+  *	the name list to prepare its status response.
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	NULL	: name list has no entry
+  *	non-NULL: pointer to NetBEUI name list
+  */
+ name_t *nbns_get_name_list(void)
+ {
+ 	return name_list;
+ }
+ 
+ /*
+  * Function: nbns_count_names
+  *	returns number of entries in name table. The status module uses
+  *	the this number to prepare its status response.
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	zero	: name table has no entry
+  *	positive: number of entries in name table
+  */
+ int nbns_count_names(void)
+ {
+ 	return name_table.count;
+ }
Index: kernel-acme/net/netbeui/nb_common.c
diff -c /dev/null kernel-acme/net/netbeui/nb_common.c:1.1.4.3
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/nb_common.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,163 ----
+ /*
+  * nb_common.c - Contains common in use functions for NetBEUI services.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/netbeui.h>
+ #include <linux/if_arp.h>
+ 
+ /*
+  * Function: NETBEUI_FUNCADDR
+  *	Returns functional address of a network device.
+  *
+  * Parameters:
+  *	dev : pointer to device that need to its functional address.
+  *
+  * Returns: char *
+  *
+  */
+ char *NETBEUI_FUNCADDR(struct net_device *dev)
+ {
+ 	switch (dev->type) {
+ #ifdef CONFIG_TR
+ 		case ARPHRD_IEEE802:
+ 			return NETBIOS_FUNC_ADDR_4TR;
+ #endif
+ 		case ARPHRD_ETHER:
+ 		case ARPHRD_EETHER:
+ 		case ARPHRD_LOOPBACK:
+ 			return NETBIOS_FUNC_ADDR_4ETH;
+ 		default:
+ 			return "\x00\x00\x00\x00\x00\x00";
+ 	}
+ }
+ 
+ /*
+  * Function: nbcm_dev_supported
+  *	Indicates that a network device is supported by us or not.
+  *
+  * Parameters:
+  *	dev_type : device type that must check it.
+  *
+  * Returns: unsigned char
+  *	0 : device not supported by us.
+  *	1 : device supported by us.
+  */
+ static inline unsigned char nbcm_dev_supported(unsigned int dev_type)
+ {
+ 	return dev_type == ARPHRD_ETHER || dev_type == ARPHRD_EETHER ||
+ 	       dev_type == ARPHRD_IEEE802 || dev_type == ARPHRD_LOOPBACK;
+ }
+ 
+ /*
+  * Function: nbcm_apt_dev
+  *
+  * Parameters:
+  *
+  * Returns: unsigned char
+  */
+ unsigned char nbcm_apt_dev(struct net_device *dev)
+ {
+ 	return (dev->flags & IFF_LOOPBACK) ||
+ 	       ((dev->flags & IFF_MULTICAST) && nbcm_dev_supported(dev->type));
+ }
+ 
+ /*
+  * Function: MAC_HEADLEN
+  *	Calculates the MAC header length of a device.
+  *
+  * Parameters:
+  *	dev : pointer to device that we need to its MAC header length.
+  *
+  * Returns: int
+  *	Always positive : MAC header length of the device.
+  *
+  * Note:
+  *	- if we do not recognize device type, the function returns ethernet
+  *	  MAC header length.
+  *
+  */
+ int MAC_HEADLEN(struct net_device *dev)
+ {
+ 	switch (dev->type) {
+ #ifdef CONFIG_TR
+ 			case ARPHRD_IEEE802:
+ 				return sizeof(struct trh_hdr);
+ #endif
+ 			case ARPHRD_ETHER:
+ 			case ARPHRD_EETHER:
+ 			default:
+ 				return sizeof(struct ethhdr);
+ 	}
+ }
+ 
+ /*
+  * Function: LLCMAC_I_HEADLEN
+  *	Calculates lengths of LLC header and MAC header together for 'I frames'
+  *	on a specific device.
+  *
+  * Parameters:
+  *	dev : pointer to device that calculation is performed for it.
+  *
+  * Returns: int
+  *       Always positive : I frame's MAC+LLC header length of the device.
+  */
+ inline int LLCMAC_I_HEADLEN(struct net_device *dev)
+ {
+ 	return MAC_HEADLEN(dev) + NETBEUI_LLC_I_HEADLEN;
+ }
+ 
+ /*
+  * Function: LLCMAC_UI_HEADLEN
+  *       Calculates lengths of LLC header and MAC header together for 'UI frames'.
+  *
+  * Parameters:
+  *	mac_hlen : MAC header length for UI frames.
+  *
+  * Returns: int
+  *       Always positive : UI frame's MAC+LLC header length of the device.
+  */
+ inline int LLCMAC_UI_HEADLEN(int mac_hlen)
+ {
+ 	return mac_hlen + NETBEUI_LLC_UI_HEADLEN;
+ }
+ 
+ /*
+  * Function: LLCMAC_UIB_HEADLEN
+  *       Calculates lengths of LLC header and MAC header together for broadcasted
+  *	'UI frames'.
+  *
+  * Parameters: none
+  *
+  * Returns: int
+  *       Always positive : broadcasted UI frame's MAC+LLC header length.
+  */
+ inline int LLCMAC_UIB_HEADLEN(void)
+ {
+ 	return NETBEUI_MAC_B_HEADLEN + NETBEUI_LLC_UI_HEADLEN;
+ }
+ 
+ /*
+  * Function: CALC_DG_SKBLEN
+  *	Calculates appropriate sk_buff length for sending UI frames.
+  *
+  * Parameters:
+  *	mac_hlen     : MAC header length.
+  *	user_datalen : length of data that must put into sk_buff after
+  *	               MAC+LLC headers (including NetBIOS header).
+  *
+  * Returns: int
+  *       Always positive : appropriate sk_buff length for sending UI frames.
+  */
+ inline int CALC_DG_SKBLEN(int mac_hlen, int user_datalen)
+ {
+ 	return LLCMAC_UI_HEADLEN(mac_hlen) + user_datalen;
+ }
Index: kernel-acme/net/netbeui/proc.c
diff -c /dev/null kernel-acme/net/netbeui/proc.c:1.1.4.7
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/proc.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,420 ----
+ /*
+  * proc.c - Implements directory entries for NETBEUI names , links and
+  *          sessions below proc filesystem in memory.
+  * Notes:
+  *	- Proc file system for NETBEUI is created under /proc/net/netbeui.
+  *      - There are two types of directory entries below netbeui under proc :
+  *	  Static directory entries which are created at module initialization
+  *	  into memory. Dynamic entries which are created at runtime like session
+  *	  entries per link.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/errno.h>
+ #include <linux/sched.h>
+ #include <linux/proc_fs.h>
+ #include <linux/stat.h>
+ #include <linux/string.h>
+ #include <linux/netdevice.h>
+ #include <asm/uaccess.h>
+ #include <linux/netbeui.h>
+ 
+ #define NETBEUI_PROJECT "Procom, 1997, Arnaldo C. Melo, 2001"
+ #define NETBEUI_RELEASE	"2.0"
+ #define MAX_NAME_LEN 10
+ 
+ static const char *netbeui_version = "NetBEUI version " NETBEUI_RELEASE " "
+ 				     NETBEUI_PROJECT "\n";
+ #define PROC_BUFSZ 8000 /* buffer size for printing proc info */
+ static struct proc_dir_entry *proc_netbeui,
+ 			     *proc_netbeui_links,
+ 			     *proc_netbeui_sessions,
+ 			     *proc_netbeui_names;
+ /* Proc filesystem interface */
+ /* Verify access rights. */
+ static int netbeui_proc_perms(struct inode* inode, int op)
+ {
+ 	return 0;
+ }
+ 
+ /*
+  *	Read netbeui proc directory entry.
+  *	This is universal routine for reading all entries in /proc/net/netbeui
+  *	directory.  Each directory entry contains a pointer to the 'method' for
+  *	preparing data for that entry.
+  *	o verify arguments
+  *	o allocate kernel buffer
+  *	o call get_info() to prepare data
+  *	o copy data to user space
+  *	o release kernel buffer
+  *
+  *	Return:	number of bytes copied to user space (0, if no data)
+  *		< 0	error
+  */
+ static ssize_t netbeui_proc_read(struct file* file, char* buf, size_t count,
+ 				loff_t *ppos)
+ {
+ 	struct inode *inode = file->f_dentry->d_inode;
+ 	struct proc_dir_entry* dent;
+ 	char* page;
+ 	int pos, offs, len = 0;
+ 
+ 	if (count <= 0)
+ 		goto out;
+ 	dent = inode->u.generic_ip;
+ 	if (!dent || !dent->get_info)
+ 		goto out;
+ 	page = kmalloc(PROC_BUFSZ, GFP_KERNEL);
+ 	len = -ENOBUFS;
+ 	if (!page)
+ 		goto out;
+ 	pos = dent->get_info(page, dent->data, 0, 0);
+ 	offs = file->f_pos;
+ 	len = 0;
+ 	if (offs < pos) {
+ 		len = min(int, pos - offs, count);
+ 		if (copy_to_user(buf, page + offs, len)) {
+ 			len = -EFAULT;
+ 			goto out_free;
+ 		}
+ 		file->f_pos += len;
+ 	}
+ out_free:
+ 	kfree(page);
+ out:	return len;
+ }
+ 
+ /* Generic /proc/net/netbeui/<file> file and inode operations */
+ static struct file_operations netbeui_fops = {
+ 	read:		netbeui_proc_read,
+ };
+ 
+ static struct inode_operations netbeui_inode = {
+ 	permission:	netbeui_proc_perms,
+ };
+ 
+ /* Functions to get data from netbeui name, links and session service */
+ extern dextab_t *nbll_get_link_table(void);
+ extern struct net_device *adapters[];
+ 
+ /*
+  * Function: netbeui_version_get_info
+  *	Contents of /proc/sys/netbeui/version which is netbeui version no
+  *
+  * Parameters:
+  *	buff : A buffer which contains the contents of file
+  *
+  * Returns:
+  *	Buffer data size in bytes
+  *
+  * (1997 DEC 2'th,  R.S. - Commenting)
+  */
+ static int netbeui_version_get_info(char *buff, char **start, off_t offset,
+ 				    int length)
+ {
+ 	return sprintf(buff, netbeui_version);
+ }
+ 
+ /*
+  * Function: netbeui_adapter_get_info
+  *	Contents of /proc/sys/netbeui/adapter which is local adapter status
+  *
+  * Parameters:
+  *	buff : A buffer which contains the contents of file
+  *
+  * Returns:
+  *	Buffer data size in bytes
+  *
+  * (1997 DEC 2'th,  R.S. - Commenting)
+  */
+ static int netbeui_adapter_get_info(char *buff, char **start, off_t offset,
+ 				    int length)
+ {
+ 	int i, l = 0;
+ 	int j = 0;
+ 	char *b;
+ 
+ 	for (i = 0, b = buff; adapters[i]; i++, j += l, b += l)
+ 		l = sprintf(b, "%s   %u   %02X:%02X:%02X:%02X:%02X:%02X\n",
+ 			adapters[i]->name, adapters[i]->mtu,
+ 			adapters[i]->dev_addr[0], adapters[i]->dev_addr[1],
+ 			adapters[i]->dev_addr[2], adapters[i]->dev_addr[3],
+ 			adapters[i]->dev_addr[4], adapters[i]->dev_addr[5]);
+ 	return j;
+ }
+ 
+ /*
+  * Function: netbeui_name_get_info
+  *	Contents of /proc/sys/netbeui/names which is netbeui name information
+  *
+  * Parameters:
+  *	buff	: A buffer which contains the contents of file
+  *
+  * Notes:
+  *	- There is a file entry for each name and the file name is the
+  *	  name number of that name
+  *
+  * Returns:
+  *	Buffer data size in bytes
+  *
+  * (1997 DEC 2'th,  R.S. - Commenting)
+  */
+ static int netbeui_name_get_info(char *buff, char **start, off_t offset,
+ 				 int length)
+ {
+ 	unsigned char printable_name[NETBEUI_NAME_LEN + 10];
+ 	unsigned char name_port;
+ 	name_t *nb_name = (name_t *)start;
+ 
+ 	memcpy(printable_name, nb_name->name, NETBEUI_NAME_LEN + 1);
+ 	name_port = nb_name->name[NETBEUI_NAME_LEN - 1];
+ 	if (name_port < 0x20 || name_port >= 0x80)
+ 		sprintf(printable_name + NETBEUI_NAME_LEN - 1, "<%2x>",
+ 			name_port);
+ 	return sprintf(buff, "%d : state\n%d : status\n\"%s\" : name\n"
+ 		"%u : conflicted\n%u : name_number\n%u : users\n",
+ 		nb_name->state, nb_name->status, printable_name,
+ 		nb_name->conflicted, nb_name->name_number,
+ 		atomic_read(&nb_name->refcnt));
+ }
+ 
+ /*
+  * Function: netbeui_session_get_info
+  *	Contents of /proc/sys/netbeui/sessions which is netbeui session
+  *	information classified per link
+  *
+  * Parameters:
+  *	buff	: A buffer which contains the contents of file
+  *	ino	: I-node number of the session file entry
+  *
+  * Notes:
+  *	- Session files are created per link and are placed below
+  *	  /proc/sys/netbeui/sessions/<link_no>/
+  *	- Each session file is named as <local_session_no>-<remote_session_no>
+  *
+  * Returns:
+  *	Buffer data size in bytes
+  *
+  * (1997 DEC 2'th,  R.S. - Commenting)
+  */
+ static int netbeui_session_get_info(char *buff, char **start, off_t offset,
+ 				    int length)
+ {
+ 	session_t *nlist = (session_t *)start;
+ 	char *name = 0;
+ 
+ 	if (nlist->local_name)
+ 		name = (char *)&nlist->local_name->name;
+ 
+ 	return sprintf(buff, "%d : state\n%d : status\n%u : link_no\n"
+ 		"\"%s\" : local_name\n\"%s\" : remote_name\n%u : lsn\n"
+ 		"%u : rsn\n%u : version\n%u : nack_indicator\n"
+ 		"%u : tr_frame_lf\n%u : mtu\n%u : o_total\n%u : i_total\n",
+ 		nlist->state, nlist->status, nlist->link_no, name,
+ 		nlist->remote_name, nlist->lsn, nlist->rsn, nlist->version,
+ 		nlist->nack_indicator, nlist->tr_frame_lf, nlist->mtu,
+ 		nlist->o_total, nlist->i_total);
+ }
+ 
+ /*
+  * Function: netbeui_link_get_info
+  *	Contents of /proc/sys/netbeui/links which is netbeui links
+  *	information
+  *
+  * Parameters:
+  *	buff	: A buffer which contains the contents of file
+  *	ino	: I-node number of the link file entry
+  *
+  * Returns:
+  *	Buffer data size in bytes
+  *
+  * (1997 DEC 2'th,  R.S. - Commenting)
+  */
+ static int netbeui_link_get_info(char *buff, char **start, off_t offset,
+ 				 int length)
+ {
+ 	link_t *nlist;
+ 	char *name = 0;
+ 
+ 	nlist = (link_t *)start;
+ 	if (nlist->remote_dev)
+ 		name = nlist->remote_dev->name;
+ 	return sprintf(buff, "%d : state\n%d : status\n%u : llc_handle\n"
+ 		       "%u : link_no\n%02X:%02X:%02X:%02X:%02X:%02X : "
+ 		       "remote_mac\n%s : remote_dev\n%u : llc_busy\n%u : "
+ 		       "frames\n",
+ 			nlist->state, nlist->status, nlist->llc_handle,
+ 			nlist->link_no, nlist->remote_mac[0],
+ 			nlist->remote_mac[1], nlist->remote_mac[2],
+ 			nlist->remote_mac[3], nlist->remote_mac[4],
+ 			nlist->remote_mac[5], name, nlist->llc_busy,
+ 			skb_queue_len(&nlist->skbq));
+ }
+ 
+ int netbeui_proc_add_name(name_t *name)
+ {
+ 	char printable_name[NETBEUI_NAME_LEN + 10];
+ 	unsigned char name_port;
+ 
+         memcpy(printable_name, name->name, NETBEUI_NAME_LEN + 1);
+         name_port = name->name[NETBEUI_NAME_LEN - 1];
+         if (name_port < 0x20 || name_port >= 0x80)
+                 sprintf(printable_name + NETBEUI_NAME_LEN - 1, "<%2x>",
+ 			name_port);
+ 	name->dent = create_proc_entry(printable_name, 0, proc_netbeui_names);
+ 	if (!name->dent)
+ 		return -ENOMEM;
+ 	name->dent->proc_fops = &netbeui_fops;
+ 	name->dent->proc_iops = &netbeui_inode;
+ 	name->dent->get_info  = netbeui_name_get_info;
+ 	name->dent->data      = name;
+ 	return 0;
+ }
+ 
+ int netbeui_proc_add_link(link_t *link)
+ {
+ 	char printable_name[16];
+ 
+ 	sprintf(printable_name, "%u", link->link_no);
+ 	link->dent = create_proc_entry(printable_name, 0, proc_netbeui_links);
+ 	if (!link->dent)
+ 		goto out;
+ 	link->dent_sessions = proc_mkdir(printable_name, proc_netbeui_sessions);
+ 	if (!link->dent_sessions)
+ 		goto out_link;
+ 	link->dent->proc_fops = &netbeui_fops;
+ 	link->dent->proc_iops = &netbeui_inode;
+ 	link->dent->get_info  = netbeui_link_get_info;
+ 	link->dent->data      = link;
+ 	return 0;
+ out_link:
+ 	remove_proc_entry(printable_name, proc_netbeui_links);
+ out:	return -ENOMEM;
+ }
+ 
+ int netbeui_proc_add_session(session_t *session)
+ {
+ 	char printable_name[32];
+ 	link_t *link = nbll_get_link(session->link_no);
+ 	int rc = -ENOENT;
+ 
+ 	if (!link)
+ 		goto out;
+ 	sprintf(printable_name, "%u-%u", session->lsn, session->rsn);
+ 	session->dent = create_proc_entry(printable_name, 0,
+ 					  link->dent_sessions);
+ 	rc = -ENOMEM;
+ 	if (!session->dent)
+ 		goto plink;
+ 	rc = 0;
+ 	session->dent->proc_fops = &netbeui_fops;
+ 	session->dent->proc_iops = &netbeui_inode;
+ 	session->dent->get_info  = netbeui_session_get_info;
+ 	session->dent->data      = session;
+ plink:	nbll_link_put(link);
+ out:	return rc;
+ }
+ 
+ void netbeui_proc_del_name(name_t *name)
+ {
+ 	if (name->dent)
+ 		remove_proc_entry(name->dent->name, proc_netbeui_names);
+ }
+ 
+ void netbeui_proc_del_link(link_t *link)
+ {
+ 	if (link->dent) {
+ 		remove_proc_entry(link->dent->name, proc_netbeui_links);
+ 		remove_proc_entry(link->dent_sessions->name,
+ 				  proc_netbeui_sessions);
+ 	}
+ }
+ 
+ void netbeui_proc_del_session(session_t *session)
+ {
+ 	if (session->dent) {
+ 		dextab_t *link_table = nbll_get_link_table();
+ 
+ 		if (session->link_no <= link_table->count) {
+ 			link_t *link = (link_t *)
+ 					link_table->addr[session->link_no];
+ 
+ 			if (link)
+ 				remove_proc_entry(session->dent->name,
+ 						  link->dent_sessions);
+ 		}
+ 	}
+ }
+ 
+ int netbeui_proc_init(void)
+ {
+ 	struct proc_dir_entry *p;
+ 	int rc = 0;
+ 
+ 	proc_netbeui = proc_mkdir("netbeui", proc_net);
+ 	if (!proc_netbeui)
+ 		goto out_err;
+ 	proc_netbeui_links = proc_mkdir("links", proc_netbeui);
+ 	if (!proc_netbeui_links)
+ 		goto out_proc;
+ 	proc_netbeui_sessions = proc_mkdir("sessions", proc_netbeui);
+ 	if (!proc_netbeui_sessions)
+ 		goto out_links;
+ 	proc_netbeui_names = proc_mkdir("names", proc_netbeui);
+ 	if (!proc_netbeui_names)
+ 		goto out_sessions;
+ 	p = create_proc_entry("version", 0, proc_netbeui);
+ 	if (!p)
+ 		goto out_names;
+ 	p->proc_fops = &netbeui_fops;
+ 	p->proc_iops = &netbeui_inode;
+ 	p->get_info  = netbeui_version_get_info;
+ 	p = create_proc_entry("adapter", 0, proc_netbeui);
+ 	if (!p)
+ 		goto out_names;
+ 	p->proc_fops = &netbeui_fops;
+ 	p->proc_iops = &netbeui_inode;
+ 	p->get_info  = netbeui_adapter_get_info;
+ out:	return rc;
+ out_names:
+ 	remove_proc_entry("names", proc_netbeui);
+ out_sessions:
+ 	remove_proc_entry("sessions", proc_netbeui);
+ out_links:
+ 	remove_proc_entry("links", proc_netbeui);
+ out_proc:
+ 	remove_proc_entry("netbeui", proc_net);
+ out_err:
+ 	rc = -ENOMEM;
+ 	goto out;
+ }
+ 
+ /*
+  * Function: proc_clean
+  *	Clears all netbeui directory entries for netbeui from /proc/sys/
+  *
+  * Parameters:
+  *	none
+  *
+  * Returns:
+  *	none
+  *
+  * (1997 DEC 2'th,  R.S. - Commenting)
+  */
+ void netbeui_proc_clean(void)
+ {
+ 	remove_proc_entry("links", proc_netbeui);
+ 	remove_proc_entry("sessions", proc_netbeui);
+ 	remove_proc_entry("names", proc_netbeui);
+ 	remove_proc_entry("version", proc_netbeui);
+ 	remove_proc_entry("adapter", proc_netbeui);
+ 	remove_proc_entry("netbeui", proc_net);
+ }
Index: kernel-acme/net/netbeui/query_serve.c
diff -c /dev/null kernel-acme/net/netbeui/query_serve.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/query_serve.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,778 ----
+ /*
+  * query_serve.c - Contains functions that implement NetBIOS Query Service.
+  *		   It also implements a remote name cache which is intended
+  * 		   to cache a mapping between NetBIOS name and MAC address.
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *	- Remote name cache needs upper layer considerations which makes its
+  *	  impossible or hardly possible in other modules. Up to now only Session
+  * 	  service uses this mechanism to speed-up connection establishment.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/sched.h>
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/errno.h>
+ #include <linux/timer.h>
+ #include <linux/skbuff.h>
+ #include <linux/netbeui.h>
+ 
+ static void nbqs_timer_function(unsigned long);
+ 
+ /* These functions are Query State Transition handlers */
+ static int nbqs_name_query_in_initial(query_t *nb_query);
+ static int nbqs_name_find_in_initial(query_t *nb_query);
+ static int nbqs_retry_timeout_in_all(query_t *nb_query);
+ static int nbqs_response_timeout_in_all(query_t *nb_query);
+ static int nbqs_name_recognized_in_qrywait(query_t *nb_query);
+ static int nbqs_name_recognized_in_findwait(query_t *nb_query);
+ static int nbqs_end_query_in_name_recognized(query_t *nb_query);
+ 
+ static unsigned short int nbqs_correlator;
+ #define nbqs_next_correlator() (++nbqs_correlator)
+ 
+ static query_t *query_list;
+ rwlock_t query_list_lock = RW_LOCK_UNLOCKED;
+ 
+ /* Remote name cache definition */
+ struct rnc_struct {
+ 	__u8 name[NETBEUI_NAME_LEN];
+ 	__u8 mac[6];
+ 	struct net_device *dev;
+ 	unsigned long int time_stamp;
+ 	struct rnc_struct *prev;
+ 	struct rnc_struct *next;
+ };
+ typedef struct rnc_struct rnc_t;
+ 
+ static rnc_t *rnc_list;
+ static int rnc_count;
+ static spinlock_t rnc_list_lock = SPIN_LOCK_UNLOCKED;
+ 
+ /* Query Service State Machine definition */
+ typedef int (* query_event_handler_t)(query_t *);
+ 
+ struct event_struct {
+ 	query_state_t next_state;
+ 	query_event_handler_t event_handler;
+ };
+ 
+ static struct event_struct query_state_table[4][6] = {
+ 			/* NETBEUI_QUERY_INITIAL */
+ {
+ { NETBEUI_QUERY_QRYWAIT,
+ 	nbqs_name_query_in_initial },	   /* NETBEUI_QUERY_NAME_QUERY */
+ { NETBEUI_QUERY_FINDWAIT,
+ 	nbqs_name_find_in_initial },	   /* NETBEUI_QUERY_NAME_FIND */
+ { -1, NULL },				   /* NETBEUI_QUERY_RETRY_TIMEOUT */
+ { -1, NULL },				   /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+ { -1, NULL },				   /* NETBEUI_QUERY_NAME_RECOGNIZED */
+ { -1, NULL },				   /* NETBEUI_QUERY_END_QURY */
+ },
+ 			/* NETBEUI_QUERY_QRYWAIT */
+ {
+ { -1, NULL },				    /* NETBEUI_QUERY_NAME_QUERY */
+ { -1, NULL },				    /* NETBEUI_QUERY_NAME_FIND */
+ { NETBEUI_QUERY_QRYWAIT,
+ 	nbqs_retry_timeout_in_all },	    /* NETBEUI_QUERY_RETRY_TIMEOUT */
+ { NETBEUI_QUERY_INITIAL,
+ 	nbqs_response_timeout_in_all },	    /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+ { NETBEUI_QUERY_RECOGNIZED,
+ 	nbqs_name_recognized_in_qrywait },  /* NETBEUI_QUERY_NAME_RECOGNIZED */
+ { -1, NULL },				    /* NETBEUI_QUERY_END_QURY */
+ },
+ 			/* NETBEUI_QUERY_FINDWAIT */
+ {
+ { -1, NULL },				    /* NETBEUI_QUERY_NAME_QUERY */
+ { -1, NULL },				    /* NETBEUI_QUERY_NAME_FIND */
+ { NETBEUI_QUERY_FINDWAIT,
+ 	nbqs_retry_timeout_in_all },	    /* NETBEUI_QUERY_RETRY_TIMEOUT */
+ { NETBEUI_QUERY_INITIAL,
+ 	nbqs_response_timeout_in_all },	    /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+ { NETBEUI_QUERY_FINDWAIT,
+ 	nbqs_name_recognized_in_findwait }, /* NETBEUI_QUERY_NAME_RECOGNIZED */
+ { -1, NULL },				    /* NETBEUI_QUERY_END_QURY */
+ },
+ 			/* NETBEUI_QUERY_RECOGNIZED */
+ {
+ { -1, NULL },				    /* NETBEUI_QUERY_NAME_QUERY */
+ { -1, NULL },				    /* NETBEUI_QUERY_NAME_FIND */
+ { -1, NULL },				    /* NETBEUI_QUERY_RETRY_TIMEOUT */
+ { -1, NULL },				    /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+ { -1, NULL },				    /* NETBEUI_QUERY_NAME_RECOGNIZED */
+ { NETBEUI_QUERY_INITIAL,
+ 	nbqs_end_query_in_name_recognized },/* NETBEUI_QUERY_END_QURY */
+ }
+ };
+ /*
+  * Query service state machine functions
+  * Implementing remote name cache
+  */
+ /*
+  * Function: nbqs_remove_rnc
+  *	Removes a rnc_t entry from remote name cache list rnc_list
+  *
+  * Parameters:
+  *	nb_rnc	: pointer to rnc_t entry to remove
+  *
+  * Returns: none
+  */
+ static void __nbqs_remove_rnc(rnc_t *nb_rnc)
+ {
+ 	if (nb_rnc->next)
+ 		nb_rnc->next->prev = nb_rnc->prev;
+ 	if (nb_rnc->prev)
+ 		nb_rnc->prev->next = nb_rnc->next;
+ 	else
+ 		rnc_list = nb_rnc->next;
+ }
+ 
+ static inline void nbqs_remove_rnc(rnc_t *nb_rnc)
+ {
+ 	spin_lock(&rnc_list_lock);
+ 	__nbqs_remove_rnc(nb_rnc);
+ 	spin_unlock(&rnc_list_lock);
+ }
+ 
+ /*
+  * Function: nbqs_find_rnc
+  *	Finds a rnc_t entry in remote name cache list for a specific NetBIOS
+  *	16 byte name.
+  *
+  * Parameters:
+  *	name	: NetBIOS name of remote node to find its rnc_t
+  *
+  * Returns:
+  *	NULL	: if no matching entry found in remote cache name list
+  *	non-NULL: pointer to rnc_t in remote_cache name list
+  */
+ static inline rnc_t *__nbqs_find_rnc(char *name)
+ {
+ 	rnc_t *nb_rnc = rnc_list;
+ 
+ 	while (nb_rnc) {
+ 		if (!memcmp(nb_rnc->name, name, NETBEUI_NAME_LEN)) {
+ 			nb_rnc->time_stamp = jiffies;
+ 			break;
+ 		}
+ 		nb_rnc = nb_rnc->next;
+ 	}
+ 	return nb_rnc;
+ }
+ 
+ static inline rnc_t *nbqs_find_rnc(char *name)
+ {
+ 	rnc_t *nb_rnc;
+ 
+ 	spin_lock(&rnc_list_lock);
+ 	nb_rnc = __nbqs_find_rnc(name);
+ 	spin_unlock(&rnc_list_lock);
+ 	return nb_rnc;
+ }
+ 
+ /*
+  * Function: nbqs_cleanup_rnc
+  *	This routine will throw those cache entries who live in cache more
+  *	than a specific time (measured in jiffies) <NETBEUI_QUERY_CACHE_LIVING_TIME>.
+  *
+  * Parameters: none
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- For the sake of efficiency, remote name cache list wont grow more
+  *	  than a specific size <NETBEUI_QUERY_MAX_CACHE_ENTRIES>. Note that this is
+  *	  just a high water mark. Refer to nbqs_add_rnc
+  */
+ static void __nbqs_cleanup_rnc(void)
+ {
+ 	rnc_t *nb_rnc = rnc_list;
+ 
+ 	while (nb_rnc) {
+ 		if (jiffies - nb_rnc->time_stamp > NETBEUI_QUERY_CACHE_LIVING_TIME) {
+ 			rnc_t *tmp_rnc = nb_rnc;
+ 
+ 			nb_rnc = nb_rnc->next;
+ 			nbqs_remove_rnc(tmp_rnc);
+ 			kfree(tmp_rnc);
+ 		} else {
+ 			rnc_count++;
+ 			nb_rnc = nb_rnc->next;
+ 		}
+ 	}
+ }
+ 
+ static inline void nbqs_cleanup_rnc(void)
+ {
+ 	spin_lock(&rnc_list_lock);
+ 	__nbqs_cleanup_rnc();
+ 	spin_unlock(&rnc_list_lock);
+ }
+ 
+ /*
+  * Function: nbqs_add_rnc
+  *	Adds/Updates an entry to remote name cache list
+  *
+  * Parameters:
+  *	name	: pointer to NetBIOS name of remote node
+  *	dev	: pointer to device structure node is connected via
+  *	mac	: pointer to MAC address of remote node
+  *
+  * Returns: none
+  *	
+  * Notes:
+  *	- If an rnc_t corresponding to NetBIOS name exists in cache it is
+  *	  updated else a new entry is created.
+  *	- This routine handles cache grow beyond NETBEUI_QUERY_MAX_CACHE_ENTRIES
+  *	  but does not guarantee to preserve the entry count below the value
+  *	- This routine does not guarantee adding memory since it may fail
+  *	  to allocate memory. This does not affect the system consistency.
+  */
+ void nbqs_add_rnc(char *name, struct net_device *dev, unsigned char *mac)
+ {
+ 	rnc_t *nb_rnc;
+ 
+ 	spin_lock(&rnc_list_lock);
+ 	nb_rnc = __nbqs_find_rnc(name);
+ 	if (nb_rnc) {
+ 		memcpy(nb_rnc->mac, mac, 6);
+ 		nb_rnc->dev		= dev;
+ 		nb_rnc->time_stamp	= jiffies;
+ 	}
+ 	if (rnc_count >= NETBEUI_QUERY_MAX_CACHE_ENTRIES)
+ 		__nbqs_cleanup_rnc();
+ 	nb_rnc = kmalloc(sizeof(rnc_t), GFP_KERNEL);
+ 	if (!nb_rnc)
+ 		goto out;
+ 	rnc_count++;
+ 	memcpy(nb_rnc->name, name, NETBEUI_NAME_LEN);
+ 	memcpy(nb_rnc->mac, mac, 6);
+ 	nb_rnc->dev		= dev;
+ 	nb_rnc->time_stamp	= jiffies;
+ 	if (rnc_list) {
+ 		rnc_list->prev	= nb_rnc;
+ 		nb_rnc->next	= rnc_list;
+ 		nb_rnc->prev	= NULL;
+ 		rnc_list	= nb_rnc;
+ 	} else {
+ 		rnc_list	= nb_rnc;
+ 		nb_rnc->next	= nb_rnc->prev = NULL;
+ 	}
+ out:	spin_unlock(&rnc_list_lock);
+ }
+ 
+ /*
+  * Function: nbqs_delete_rnc
+  *	This is a wrapper to nbqs_remove_rnc which both remove entry from
+  *	remote name cache and deallocates memory.
+  *
+  * Parameters:
+  *	name	: NetBIOS name of remote node to remove its rnc_t
+  *
+  * Returns: none
+  */
+ void nbqs_delete_rnc(char *name)
+ {
+ 	rnc_t *nb_rnc;
+ 
+ 	spin_lock(&rnc_list_lock);
+ 	nb_rnc = __nbqs_find_rnc(name);
+ 	if (nb_rnc) {
+ 		__nbqs_remove_rnc(nb_rnc);
+ 		kfree(nb_rnc);
+ 		rnc_count--;
+ 	}
+ 	spin_unlock(&rnc_list_lock);
+ }
+ 
+ /*
+  * Query service state machine functions
+  * Implementing general functions
+  */
+ /*
+  * Function: nbqs_alloc_query
+  *	Allocates a query_t structure and does completely initialize all fields
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	NULL	: if can not allocate memory for query_t or its sk_buff
+  *	non-NULL: pointer to query_t
+  *	
+  * Notes:
+  *	- An skb is attached to each new query for query processing purposes
+  *	- query timer is initialized but not started.
+  *	- The call to memset does implicitly initialize all fields. Those
+  *	  fields that need explicit non-zero initialization are manipulated
+  *	  afterwards.
+  */
+ static query_t *nbqs_alloc_query(void)
+ {
+ 	int name_dgram_len;
+ 	query_t *nb_query = kmalloc(sizeof(*nb_query), GFP_KERNEL);
+ 
+ 	if (!nb_query)
+ 		goto out;
+ 	/* Implicitly initialize all fields */
+ 	memset(nb_query, 0, sizeof(*nb_query));
+ 	init_timer(&nb_query->timer);
+ 	nb_query->timer.data	 = (unsigned long)nb_query;
+ 	nb_query->timer.function = nbqs_timer_function;
+ 	init_waitqueue_head(&nb_query->waitq);
+ 
+ 	/* Allocate query skb */
+ 	/* All commands use same length */
+ 	name_dgram_len = nb_command_header_len[NETBEUI_NAME_QUERY];
+ 	nb_query->skb = alloc_skb(CALC_DG_SKBLEN(NETBEUI_MAC_B_HEADLEN,
+ 				  name_dgram_len), GFP_KERNEL);
+ 	if (!nb_query->skb)
+ 		goto err;
+ 	skb_reserve(nb_query->skb, LLCMAC_UIB_HEADLEN());
+ 	nb_query->skb->nh.raw = nb_query->skb->h.raw = nb_query->skb->data;
+ 	skb_put(nb_query->skb, name_dgram_len);
+ 	nb_query->skb->dev = NULL;
+ out:	return nb_query;
+ err:	kfree(nb_query);
+ 	nb_query = NULL;
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbqs_free_query
+  *	Deallocates memory used for a query_t and its sk_buff
+  *
+  * Parameters:
+  *	nb_query : pointer to query_t memory to be freed
+  *
+  * Returns: none
+  */
+ static inline void nbqs_free_query(query_t *nb_query)
+ {
+ 	kfree_skb(nb_query->skb);
+ 	kfree(nb_query);
+ }
+ 
+ /*
+  * Function: nbqs_add_query_to_list
+  *	Inserts a previously allocated/initialized query_t into query list
+  *
+  * Parameters:
+  *	nb_query : pointer to query_t to insert
+  *
+  * Returns:
+  *	0 	 : always returns zero
+  */
+ static inline int nbqs_add_query_to_list(query_t *nb_query)
+ {
+ 	write_lock(&query_list_lock);
+ 	nb_query->next	= query_list;
+ 	query_list	= nb_query;
+ 	write_unlock(&query_list_lock);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbqs_remove_query_from_list
+  *	Removes a query_t from query list
+  *
+  * Parameters:
+  *	nb_query : pointer to query_t to remove
+  *
+  * Returns: none
+  */
+ static void nbqs_remove_query_from_list(query_t *nb_query)
+ {
+ 	query_t *entry, *prev_entry = NULL;
+ 
+ 	write_lock(&query_list_lock);
+ 	entry = query_list;
+ 	while (entry) {
+ 		if (entry == nb_query) {
+ 			if (prev_entry)
+ 				prev_entry->next = entry->next;
+ 			else
+ 				query_list = entry->next;
+ 			break;
+ 		}
+ 		prev_entry = entry;
+ 		entry = entry->next;
+ 	}
+ 	write_unlock(&query_list_lock);
+ }
+ 
+ /*
+  * Function: nbqs_find_correlator
+  *	finds a query_t in query_list, which has transmitted frames with
+  *	specific correlator.
+  *
+  * Parameters:
+  *	correlator : a sixteen bit integer which contains the response
+  *	             correlator of input frame. It should be matched against
+  *		     xmit correlator of frames sent by the element.
+  *
+  * Returns:
+  *	NULL	   : if no query_t element found with the requested
+  *		     characteristic.
+  *	non-NULL   : pointer to matching query_t with the requested
+  *		     characteristic.
+  */
+ static query_t *nbqs_find_correlator(unsigned short correlator)
+ {
+ 	query_t *nb_query;
+ 	
+ 	read_lock(&query_list_lock);
+ 	nb_query = query_list;
+ 	while (nb_query) {
+ 		if (nb_query->resp_correlator == correlator)
+ 			break;
+ 		nb_query = nb_query->next;
+ 	}
+ 	read_unlock(&query_list_lock);
+ 	return nb_query;
+ }
+ 
+ /*
+  * Function: nbqs_boradcast_name_query
+  *	Prepares a NetBIOS NAME QUERY frames and nbll_uisends it to network.
+  *
+  * Parameters:
+  *	nb_query : pointer to query_t element which the frame should be built
+  *		   from
+  *
+  * Returns:
+  *	0 	 : if frame is successfully broadcasted to network
+  *	non-zero : if frame transmission encountered an error (usually at NDI
+  *		   layer)
+  *	
+  * Notes:
+  *	- Since ADD NAME QUERY frames are retransmitted in timed intervals, it
+  *	  is considered to build frame once, but transmit it multiple times.
+  *	  having built frames in each retransmission does generate multiple
+  *	  correlators and does frustrate processing responses.
+  */
+ static int nbqs_broadcast_name_query(query_t *nb_query)
+ {
+ 	if (!nb_query->retries) {
+ 		dgram_t *hdr = (dgram_t *)nb_query->skb->data;
+ 	
+ 		hdr->length	= nb_command_header_len[NETBEUI_NAME_QUERY];
+ 		hdr->delimiter	= NETBEUI_DELIMITER;
+ 		hdr->command	= NETBEUI_NAME_QUERY;
+ 		hdr->data1	= 0;
+ 		if (nb_query->lsn > 0)
+ 			hdr->data2 =
+ 				NETBEUI_CALL_DATA2(nb_query->calling_name->type,
+ 						   nb_query->lsn);
+ 		else
+ 			hdr->data2 = 0;
+ 		hdr->xmit_correlator = 0;
+ 		hdr->resp_correlator =
+ 			nb_query->resp_correlator = nbqs_next_correlator();
+ 		memcpy(hdr->dest_name, nb_query->called_name, NETBEUI_NAME_LEN);
+ 		if (nb_query->lsn > 0)
+ 			memcpy(hdr->source_name, nb_query->calling_name->name,
+ 			       NETBEUI_NAME_LEN);
+ 		else
+ 			memset(hdr->source_name, 0, NETBEUI_NAME_LEN);
+ 	}
+ 	return nbll_uisend(NULL, nb_query->skb);
+ }
+ 
+ /*
+  * Function: nbqs_handle_event
+  *	This is the heart of Query Service State Machine, which performs a
+  *	transition from current state of query element to new state based
+  *	on event occurred and query state table contents.
+  *
+  * Parameters:
+  *	event	: An integer of NETBEUI_QUERY_* family that implies type of
+  *		  event
+  *	nb_name	: pointer to query_t structure which the event occurred on
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- The state changes before actions be executed. This is due to
+  *	  non deterministic behavior of actions which may sleep the current
+  *	  process, thus stopping the function in the mid-way.
+  */
+ static void nbqs_handle_event(query_event_t event, query_t *nb_query)
+ {
+ 	struct event_struct *ev = &query_state_table[nb_query->state][event];
+ 
+ 	if (ev && ev->event_handler) {
+ 		unsigned char old_state = nb_query->state;
+ 
+ 		nb_query->state = ev->next_state;
+ 		if (ev->event_handler(nb_query))
+ 			nb_query->state = old_state;
+ 	}
+ }
+ 
+ /*
+  * Function: nbqs_timer_function
+  *	This is the callback function triggered upon expiration of name
+  *	retransmittion timer. It just injects an event into state machine for
+  *	its link.
+  *
+  * Parameters:
+  *	input	: pointer to query_t structure whose timer is expired.
+  *
+  * Returns: none
+  */
+ static void nbqs_timer_function(unsigned long input)
+ {
+ 	query_t *nb_query = (query_t *)input;
+ 
+ 	if (nb_query->retries < NETBEUI_TRANSMIT_COUNT)
+ 		nbqs_handle_event(NETBEUI_QUERY_RETRY_TIMEOUT, nb_query);
+ 	else
+ 		nbqs_handle_event(NETBEUI_QUERY_RESPONSE_TIMEOUT, nb_query);
+ }
+ 
+ /*
+  * Query service state machine functions
+  * Implementing transition actions
+  */
+ /*
+  * Function: nbqs_xxxx_in_ssss
+  *	The section below contains functions that implement actions needed
+  *	to  legally transit from one state to another.
+  *
+  * Parameters:
+  *	nb_query: pointer to query_t structure which the actions are to be
+  *		  applied to
+  *
+  * Returns:
+  *	0	: if all actions are done successfully
+  *	non-zero: if one of actions failed
+  *
+  * Note:
+  *	- For the sake of simplicity, the actions are automatically rollbacked
+  *	  in each function, if an action in transition fails. The design
+  *	  documents do not cover these parts of code.
+  */
+ static int nbqs_name_query_in_initial(query_t *nb_query)
+ {
+ 	nb_query->retries = nb_query->responses	= 0;
+ 
+ 	if (nbqs_broadcast_name_query(nb_query))
+ 		return -ENOMEM;
+ 	nb_query->retries++;
+ 	nb_query->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+ 	add_timer(&nb_query->timer);
+ 	nbqs_add_query_to_list(nb_query);
+ 	sleep_on(&nb_query->waitq);
+ 	return 0;
+ }
+ 
+ static int nbqs_name_find_in_initial(query_t *nb_query)
+ {
+ 	nb_query->retries = nb_query->responses	= nb_query->buff_ofs = 0;
+ 
+ 	if (nbqs_broadcast_name_query(nb_query))
+ 		return -ENOMEM;
+ 	nb_query->retries++;
+ 	nb_query->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+ 	add_timer(&nb_query->timer);
+ 	nbqs_add_query_to_list(nb_query);
+ 	sleep_on(&nb_query->waitq);
+ 	return 0;
+ }
+ 
+ static int nbqs_retry_timeout_in_all(query_t *nb_query)
+ {
+ 	nb_query->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+ 	add_timer(&nb_query->timer);
+ 
+ 	if (nbqs_broadcast_name_query(nb_query))
+ 		return -ENOMEM;
+ 	nb_query->retries++;
+ 	return 0;
+ }
+ 
+ static int nbqs_response_timeout_in_all(query_t *nb_query)
+ {
+ 	wake_up(&nb_query->waitq);
+ 	nbqs_remove_query_from_list(nb_query);
+ 	return 0;
+ }
+ 
+ static int nbqs_name_recognized_in_qrywait(query_t *nb_query)
+ {
+ 	del_timer(&nb_query->timer);
+ 	wake_up(&nb_query->waitq);
+ 	nbqs_remove_query_from_list(nb_query);
+ 	return 0;
+ }
+ 
+ static int nbqs_name_recognized_in_findwait(query_t *nb_query)
+ {
+ 	/* Here we should add the MAC header to buffer, considering
+ 	 * unicity of resp */
+ 	int i;
+ 	struct net_device *dev;
+ 	char *mac_buff = nb_query->mac_buff;
+ 
+ 	for (i = 0; i < nb_query->buff_ofs; i++) {
+ 		dev = nb_query->dev_buff[i];
+ 
+ 		if (nb_query->remote_dev == dev &&
+ 		    !memcmp(nb_query->remote_mac, mac_buff, dev->addr_len))
+ 			return 0;
+ 		mac_buff += dev->addr_len;
+ 	}
+ 	if (nb_query->buff_ofs < nb_query->buff_len) {
+ 		dev = nb_query->remote_dev;
+ 		nb_query->dev_buff[nb_query->buff_ofs] = dev;
+ 		memcpy(mac_buff, nb_query->remote_mac, dev->addr_len);
+ 		nb_query->buff_ofs++;
+ 	}
+ 	return 0;
+ }
+ 
+ static int nbqs_end_query_in_name_recognized(query_t *nb_query)
+ {
+ 	return 0;
+ }
+ 
+ /*
+  * Query service state machine functions
+  * Implementing interface functions
+  */
+ /*
+  * Function: nbqs_query_name
+  *	Does the first step of session establishment process and determines
+  *	remote session number, Largest Frame Bits and response correlator for
+  *	further negotiations.
+  *
+  * Parameters:
+  *	called_name    : pointer to NetBIOS name of remote node
+  *	calling_name   : pointer to name_t element registered locally
+  *	lsn	       : local session number
+  *	rsn	       : (VRP) pointer to remote session number
+  *			  valid if return value is zero
+  *	lfb            : (VRP) pointer to Largest Frame Bits (for support of
+  *	                 Token-Ring)
+  *	xmit_correlator: (VRP) pointer to xmit correlator found in NAME RESPONSE
+  *			  valid if return value is zero
+  *
+  * Returns:
+  *	0 	       : if query was successful
+  *	-EINVAL	       : if called_name is not a valid NetBIOS name
+  *	-ENOMEM	       : if memory allocation for query_t element failed
+  *	-ETIMEDOUT     : if remote node did not respond
+  */
+ int nbqs_query_name(char *called_name, name_t *calling_name, unsigned char lsn,
+ 		    unsigned char *rsn, unsigned char *lfb,
+ 		    unsigned short *xmit_correlator)
+ {
+ 	query_t *nb_query;
+ 
+ 	if (nbns_validate_name(called_name))
+ 		return -EINVAL;
+ 	nb_query = nbqs_alloc_query();
+ 	if (!nb_query)
+ 		return -ENOMEM;
+ 	nb_query->state		= NETBEUI_QUERY_INITIAL;
+ 	nb_query->calling_name	= calling_name;
+ 	memcpy(nb_query->called_name, called_name, NETBEUI_NAME_LEN);
+ 	nb_query->lsn		= lsn;
+ 	nbqs_handle_event(NETBEUI_QUERY_NAME_QUERY, nb_query);
+ 
+ 	if (nb_query->state != NETBEUI_QUERY_RECOGNIZED) {
+ 		nbqs_free_query(nb_query);
+ 		return -ETIMEDOUT;
+ 	}
+ 	*rsn = nb_query->rsn;
+ 	*lfb = nb_query->tr_lfb;
+ 	*xmit_correlator = nb_query->xmit_correlator;
+ 	nbqs_handle_event(NETBEUI_QUERY_END_QUERY, nb_query);
+ 	nbqs_free_query(nb_query);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbqs_find_name
+  *	This is NAME FIND interface which determines MAC address of a remote
+  *	node with a specific name. It also finds the device which connects
+  *	the host with remote node.
+  *
+  * Parameters:
+  *	called_name : pointer to NetBIOS name of remote node
+  *	mac_buff    : pointer to array of MAC buffers
+  *	dev_buff    : pointer to array of device pointers
+  *	buff_len    : maximum number of entries in mac_buff and dev_buff arrays
+  *
+  * Returns:
+  *	>= 0	    : count of dev_buff and mac_buff entries corresponding to
+  *		      to nodes which own called_name
+  *	-EINVAL	    : if called_name is not a valid NetBIOS name
+  *	-ENOMEM	    : if memory allocation for query_t element failed
+  *
+  * Notes:
+  *	- This routines is the point in which RNC cache is used for NetBIOS
+  *	  name resolution. The consistency of cache contents depends on
+  *	  upper layers which insert/delete cache entries.
+  */
+ int nbqs_find_name(char *called_name, char *mac_buff,
+ 		   struct net_device **dev_buff, int buff_len)
+ {
+ 	int names_found;
+ 	query_t *nb_query;
+ 	rnc_t *nb_rnc;
+ 
+ 	if (nbns_validate_name(called_name))
+ 		return -EINVAL;
+ 	nb_rnc = nbqs_find_rnc(called_name);
+ 	if (nb_rnc) {
+ 		*dev_buff = nb_rnc->dev;
+ 		memcpy(mac_buff, nb_rnc->mac, 6);
+ 		return 1;
+ 	}
+ 	nb_query = nbqs_alloc_query();
+ 	if (!nb_query)
+ 		return -ENOMEM;
+ 	nb_query->state		= NETBEUI_QUERY_INITIAL;
+ 	nb_query->calling_name	= NULL;
+ 	memcpy(nb_query->called_name, called_name, NETBEUI_NAME_LEN);
+ 	nb_query->lsn		= 0;
+ 	nb_query->mac_buff	= mac_buff;
+ 	nb_query->dev_buff	= dev_buff;
+ 	nb_query->buff_len	= buff_len;
+ 	nbqs_handle_event(NETBEUI_QUERY_NAME_FIND, nb_query);
+ 	names_found		= nb_query->buff_ofs;
+ 	nbqs_free_query(nb_query);
+ 	if (names_found > 0)
+ 		nbqs_add_rnc(called_name, *dev_buff, mac_buff);
+ 	return names_found;
+ }
+ 
+ void nbqs_get_name_recognized(struct sk_buff *skb, unsigned char *remote_mac)
+ {
+ 	dgram_t *dgram = (dgram_t *)skb->data;
+ 	unsigned short data2 = dgram->data2;
+ 	query_t *nb_query =  nbqs_find_correlator(dgram->xmit_correlator);
+ 
+ 	/* If it does not match a query */
+ 	if (!nb_query)
+ 		goto out;
+ 	nb_query->rsn		  = NETBEUI_CALL_SS(data2);
+ 	nb_query->remote_dev	  = skb->dev;
+ 	memcpy(nb_query->remote_mac, remote_mac, 6);
+ 	nb_query->xmit_correlator = dgram->resp_correlator;
+ 	nb_query->tr_lfb	  = skb->cb[0]; /* Token Ring support */
+ 	nb_query->responses++;
+ 	/* We should also set mac_header */
+ 	nbqs_handle_event(NETBEUI_QUERY_NAME_RECOGNIZED, nb_query);
+ out:	kfree_skb(skb);
+ }
Index: kernel-acme/net/netbeui/session_serve.c
diff -c /dev/null kernel-acme/net/netbeui/session_serve.c:1.1.4.10
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/session_serve.c	Thu Aug 30 19:42:35 2001
***************
*** 0 ****
--- 1,3047 ----
+ /*
+  * session_serve.c - Contains functions that implement NetBIOS Session Service
+  *
+  * Important Note:
+  *	- Consider the following design issues when reading session service
+  *	  sources
+  *		1- Session Establishment, Session Termination and Session Data
+  *		   Output Stream are joined to from the Session States
+  *		2- Session Data Input Stream does is not implemented in State
+  *		   Machine model, it is simply a buffering and acknowledgement
+  *		   mechanism.
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *	- Session Service is the most complicated service in NetBIOS. Numerous
+  *	  states and events used for session establishment, session data
+  *	  transfer and session termination need to much effort to overcome.
+  *	  Please read documentations before changing even a bit (!) in source
+  *	  codes.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/config.h>
+ #include <linux/sched.h>
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/errno.h>
+ #include <linux/timer.h>
+ #include <linux/skbuff.h>
+ #include <asm/uaccess.h>
+ #include <linux/netbeui.h>
+ #include <linux/if_arp.h>
+ 
+ extern int llc_in_progress;
+ 
+ /* These functions are used for locking sessions to avoid race conditions */
+ static void nbss_lock_session(session_t *session);
+ static int nbss_release_session(session_t *session);
+ 
+ static void nbss_wait_timer_function(unsigned long input);
+ static void nbss_resource_timer_function(unsigned long input);
+ static int nbss_abort_send_in_all(session_t *session);
+ 
+ /* These functions are Session Service State Transition handlers */
+ static int nbss_call_in_initial(session_t *session);
+ static int nbss_listen_in_initial(session_t *session);
+ 
+ static int nbss_confirm_in_callwait(session_t *session);
+ static int nbss_reject_in_callwait(session_t *session);
+ static int nbss_abort_in_callwait(session_t *session);
+ 
+ static int nbss_connect_in_confwait(session_t *session);
+ static int nbss_timeout_in_confwait(session_t *session);
+ static int nbss_abort_in_confwait(session_t *session);
+ 
+ static int nbss_confirm_in_listenwait(session_t *session);
+ static int nbss_reject_in_listenwait(session_t *session);
+ 
+ static int nbss_connect_in_initwait(session_t *session);
+ static int nbss_timeout_in_initwait(session_t *session);
+ static int nbss_reject_in_initwait(session_t *session);
+ static int nbss_abort_in_initwait(session_t *session);
+ 
+ static int nbss_hangup_in_connected(session_t *session);
+ static int nbss_first_middle_cont_in_connected(session_t *session);
+ static int nbss_first_middle_in_connected(session_t *session);
+ static int nbss_only_last_ack_in_connected(session_t *session);
+ static int nbss_only_last_in_connected(session_t *session);
+ static int nbss_resource_in_connected(session_t *session);
+ static int nbss_end_in_connected(session_t *session);
+ static int nbss_abort_in_connected(session_t *session);
+ 
+ static int nbss_hangup_in_discwait(session_t *session);
+ 
+ static int nbss_continue_in_contwait(session_t *session);
+ static int nbss_restart_in_contwait(session_t *session);
+ static int nbss_pause_in_contwait(session_t *session);
+ static int nbss_nonblock_in_contwait(session_t *session);
+ 
+ static int nbss_restart_in_standwait(session_t *session);
+ static int nbss_pause2_in_standwait(session_t *session);
+ 
+ static int nbss_data_acked_in_ackwait(session_t *session);
+ static int nbss_restart_in_ackwait(session_t *session);
+ static int nbss_pause_in_ackwait(session_t *session);
+ static int nbss_nonblock_in_ackwait(session_t *session);
+ 
+ static int nbss_norm_retry_in_rsrcwait(session_t *session);
+ static int nbss_conn_retry_in_rsrcwait(session_t *session);
+ 
+ static int nbss_first_middle_in_normal(session_t *session);
+ static int nbss_only_last_ack_in_normal(session_t *session);
+ static int nbss_only_last_in_normal(session_t *session);
+ static int nbss_pause_in_normal(session_t *session);
+ static int nbss_restart_in_normal(session_t *session);
+ static int nbss_resource_in_normal(session_t *session);
+ static int nbss_nonblock_in_normal(session_t *session);
+ 
+ static unsigned short int nbss_correlator;
+ #define nbss_next_correlator() (++nbss_correlator)
+ 
+ /* This is a list for pending session listened for incoming session
+  * establishment requests */
+ static session_t *session_list;
+ static spinlock_t session_list_lock = SPIN_LOCK_UNLOCKED;
+ 
+ /* Session service state machine definition */
+ typedef int (*session_event_handler_t)(session_t *session);
+ 
+ struct event_struct {
+ 	session_state_t next_state;
+ 	session_event_handler_t event_handler;
+ };
+ 
+ static struct event_struct session_state_table[12][23] = {
+ 			/* NETBEUI_SESS_INITIAL */
+ {
+ { NETBEUI_SESS_CALLWAIT,
+ 	nbss_call_in_initial },		/* NETBEUI_SESS_CALL */
+ { NETBEUI_SESS_LISTENWAIT,
+ 	nbss_listen_in_initial },	/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+ { -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+ { -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+ },			
+ 			/* NETBEUI_SESS_CALLWAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { NETBEUI_SESS_CONFWAIT,
+ 	nbss_confirm_in_callwait },	/* NETBEUI_SESS_CONFIRM */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_reject_in_callwait },	/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_abort_in_callwait },	/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+ { -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+ { -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+ },	
+ 			/* NETBEUI_SESS_CONFWAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_connect_in_confwait },	/* NETBEUI_SESS_CONNECT */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_timeout_in_confwait },	/* NETBEUI_SESS_TIMEOUT */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_abort_in_confwait },	/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+ { -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+ { -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+ },
+ 			/* NETBEUI_SESS_LISTENWAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { NETBEUI_SESS_INITWAIT,
+ 	nbss_confirm_in_listenwait },	/* NETBEUI_SESS_CONFIRM */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_reject_in_listenwait },	/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+ { -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+ { -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+ },	
+ 			/* NETBEUI_SESS_INITWAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_reject_in_initwait },	/* NETBEUI_SESS_REJECT */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_connect_in_initwait },	/* NETBEUI_SESS_CONNECT */
+ { NETBEUI_SESS_LISTENWAIT,
+ 	nbss_timeout_in_initwait },	/* NETBEUI_SESS_TIMEOUT */
+ { NETBEUI_SESS_LISTENWAIT,
+ 	nbss_abort_in_initwait },	/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+ { -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+ { -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+ },	
+ 			/* NETBEUI_SESS_CONNECTED */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { NETBEUI_SESS_DISCWAIT,
+ 	nbss_abort_in_connected },	/* NETBEUI_SESS_ABORT */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_hangup_in_connected },	/* NETBEUI_SESS_HANGUP */
+ { NETBEUI_SESS_DISCWAIT,
+ 	nbss_end_in_connected },	/* NETBEUI_SESS_END */
+ { NETBEUI_SESS_CONTWAIT,
+ 	nbss_first_middle_cont_in_connected }, /* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_first_middle_in_connected },  /* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_CONTINUE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL }, 				   /* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL }, 				   /* NETBEUI_SESS_RESTART */
+ { NETBEUI_SESS_ACKWAIT,
+ 	nbss_only_last_ack_in_connected }, /* NETBEUI_SESS_ONLY_LAST_ACK */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_only_last_in_connected },     /* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				   /* NETBEUI_SESS_DATA_ACKED */
+ { NETBEUI_SESS_RSRCWAIT,
+ 	nbss_resource_in_connected },	   /* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				   /* NETBEUI_SESS_NORM_RETRY */
+ { -1, NULL }				   /* NETBEUI_SESS_ABORT_SEND */
+ },
+ 			/* NETBEUI_SESS_DISCWAIT */
+ {
+ { -1, NULL },				   /* NETBEUI_SESS_CALL */
+ { -1, NULL },				   /* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				   /* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				   /* NETBEUI_SESS_REJECT */
+ { -1, NULL },				   /* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				   /* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				   /* NETBEUI_SESS_ABORT */
+ { NETBEUI_SESS_INITIAL,
+ 	nbss_hangup_in_discwait },	   /* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				   /* NETBEUI_SESS_END */
+ { -1, NULL },				   /* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				   /* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_CONTINUE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL }, 				   /* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL }, 				   /* NETBEUI_SESS_RESTART */
+ { -1, NULL }, 				   /* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL }, 				   /* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				   /* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL }, 				   /* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				   /* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				   /* NETBEUI_SESS_NORM_RETRY */
+ { -1, NULL }				   /* NETBEUI_SESS_ABORT_SEND */
+ },
+ 	   	       /* NETBEUI_SESS_CONTWAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_continue_in_contwait },	/* NETBEUI_SESS_CONTINUE */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_nonblock_in_contwait },	/* NETBEUI_SESS_NONBLOCK */
+ { NETBEUI_SESS_STANDWAIT,
+ 	nbss_pause_in_contwait },	/* NETBEUI_SESS_PAUSE */
+ { -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_restart_in_contwait }, 	/* NETBEUI_SESS_RESTART */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+ },
+ 		       /* NETBEUI_SESS_STANDWAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL },				/* NETBEUI_SESS_CONTINUE */
+ { -1, NULL },				/* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL },				/* NETBEUI_SESS_PAUSE */
+ { NETBEUI_SESS_STANDWAIT,
+ 	nbss_pause2_in_standwait },	/* NETBEUI_SESS_PAUSE2 */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_restart_in_standwait }, 	/* NETBEUI_SESS_RESTART */
+ { -1, NULL },				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL },				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL },				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL },				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL },				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL },				/* NETBEUI_SESS_NORM_RETRY */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+ },
+ 		       /* NETBEUI_SESS_ACKWAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_nonblock_in_ackwait },	/* NETBEUI_SESS_NONBLOCK */
+ { NETBEUI_SESS_STANDWAIT,
+ 	nbss_pause_in_ackwait },	/* NETBEUI_SESS_PAUSE */
+ { -1, NULL },				/* NETBEUI_SESS_PAUSE2 */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_restart_in_ackwait },	/* NETBEUI_SESS_RESTART */
+ { -1, NULL },				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL },				/* NETBEUI_SESS_ONLY_LAST */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_data_acked_in_ackwait },	/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL },				/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL },				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL },				/* NETBEUI_SESS_NORM_RETRY */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+ },
+ 		       /* NETBEUI_SESS_RSRCAIT */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL },				/* NETBEUI_SESS_CONTINUE */
+ { -1, NULL },				/* NETBEUI_SESS_NONBLOCK */
+ { -1, NULL },				/* NETBEUI_SESS_PAUSE */
+ { -1, NULL },				/* NETBEUI_SESS_PAUSE2 */
+ { -1, NULL },				/* NETBEUI_SESS_RESTART */
+ { -1, NULL },				/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { -1, NULL },				/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL },				/* NETBEUI_SESS_DATA_ACKED */
+ { -1, NULL },				/* NETBEUI_SESS_RESOURCE */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_conn_retry_in_rsrcwait },	/* NETBEUI_SESS_CONN_RETRY */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_norm_retry_in_rsrcwait },	/* NETBEUI_SESS_NORM_RETRY */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+ },
+ 		       /* NETBEUI_SESS_NORMAL */
+ {
+ { -1, NULL },				/* NETBEUI_SESS_CALL */
+ { -1, NULL },				/* NETBEUI_SESS_LISTEN */
+ { -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+ { -1, NULL },				/* NETBEUI_SESS_REJECT */
+ { -1, NULL },				/* NETBEUI_SESS_CONNECT */
+ { -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+ { -1, NULL },				/* NETBEUI_SESS_ABORT */
+ { -1, NULL },				/* NETBEUI_SESS_HANGUP */
+ { -1, NULL },				/* NETBEUI_SESS_END */
+ { -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_first_middle_in_normal },	/* NETBEUI_SESS_FIRST_MIDDLE */
+ { -1, NULL },				/* NETBEUI_SESS_CONTINUE */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_nonblock_in_normal },	/* NETBEUI_SESS_NONBLOCK */
+ { NETBEUI_SESS_STANDWAIT,
+ 	nbss_pause_in_normal },		/* NETBEUI_SESS_PAUSE */
+ { -1, NULL },				/* NETBEUI_SESS_PAUSE2 */
+ { NETBEUI_SESS_NORMAL,
+ 	nbss_restart_in_normal },	/* NETBEUI_SESS_RESTART */
+ { NETBEUI_SESS_ACKWAIT,
+ 	nbss_only_last_ack_in_normal },	/* NETBEUI_SESS_ONLY_LAST_ACK */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_only_last_in_normal },	/* NETBEUI_SESS_ONLY_LAST */
+ { -1, NULL },				/* NETBEUI_SESS_DATA_ACKED */
+ { NETBEUI_SESS_RSRCWAIT,
+ 	nbss_resource_in_normal },	/* NETBEUI_SESS_RESOURCE */
+ { -1, NULL },				/* NETBEUI_SESS_CONN_RETRY */
+ { -1, NULL },				/* NETBEUI_SESS_NORM_RETRY */
+ { NETBEUI_SESS_CONNECTED,
+ 	nbss_abort_send_in_all}		/* NETBEUI_SESS_ABORT_SEND */
+ }
+ };
+ 
+ /*
+  * Session service state machine functions
+  * Implementing General functions
+  */
+ /*
+  * Function: nbss_free_session
+  *	Deallocates memory used for session_t and does a complete housekeeping
+  *
+  * Parameters:
+  *	session : pointer to session_t memory to be freed
+  *
+  * Returns: none
+  */
+ static void nbss_free_session(session_t *session)
+ {
+ 	skb_queue_purge(&session->back_log);
+ 	skb_queue_purge(&session->i_skbq);
+ 	kfree(session);
+ }
+ 
+ static inline void session_put(session_t *session)
+ {
+ 	if (atomic_dec_and_test(&session->refcnt))
+ 		nbss_free_session(session);
+ }
+ 
+ static inline void session_hold(session_t *session)
+ {
+ 	atomic_inc(&session->refcnt);
+ }
+ /*
+  * Function: NETBEUI_CALC_SESS_MTU
+  *	Calculates MAXimum length of user data that can send through a
+  *	session, and sets the 'mtu' field of it.
+  *
+  * Parameters:
+  *	sn : pointer to session that calculation is for it.
+  *
+  * Returns: none
+  */
+ static void NETBEUI_CALC_SESS_MTU(session_t *sn)
+ {
+ 	session_hold(sn);
+ 	sn->mtu = sn->remote_dev->type == ARPHRD_LOOPBACK ? 1500 :
+ 			sn->remote_dev->mtu;
+ 	if (sn->remote_dev->type == ARPHRD_IEEE802) { /* Token Ring */
+ 		__u16 dolfb;
+ 
+ 		switch (sn->tr_frame_lf) {
+ 			case 0x00: dolfb = 516;		break;
+ 			case 0x01: dolfb = 1470;	break;
+ 			case 0x02: dolfb = 2052;	break;
+ 			case 0x03: dolfb = 4399;	break;
+ 			case 0x04: dolfb = 8130;	break;
+ 			case 0x05: dolfb = 11407;	break;
+ 			case 0x06: dolfb = 17749;	break;
+ 			case 0x07:
+ 			default: dolfb = 0xFFFF;	break;
+ 		}
+ 		if (sn->mtu > dolfb)
+ 			sn->mtu = dolfb;
+ 	}
+ 	sn->mtu = sn->mtu - sn->llcmac_ihl - NETBEUI_ILEN;
+ 	session_put(sn);
+ }
+ 
+ /*
+  * Function: nbss_alloc_session
+  *	Allocates a session_t structure and does completely initialize all
+  *	fields
+  *
+  * Parameters: none
+  *
+  * Returns:
+  *	NULL	: if can not allocate memory for session_t
+  *	non-NULL: pointer to session_t
+  *
+  * Notes:
+  *	- Session timer is initialized but not started.
+  *	- The call to memset does implicitly initialize all fields. Those
+  *	  fields that need explicit non-zero initialization are manipulated
+  *	  afterwards.
+  */
+ static session_t *nbss_alloc_session(void)
+ {
+ 	session_t *session = kmalloc(sizeof(*session), GFP_KERNEL);
+ 
+ 	if (!session)
+ 		goto out;
+ 	/* Implicitly initialize all fields */
+ 	memset(session, 0, sizeof(*session));
+ 	init_timer(&session->timer);
+ 	session->timer.data	= (unsigned long)session;
+ 	session->timer.function	= nbss_wait_timer_function;
+ 	init_waitqueue_head(&session->waitq);
+ 	session->version	= NETBEUI_VERSION_2xx;
+ 	session->nack_indicator	= NETBEUI_NACK_ABLE;
+ 	skb_queue_head_init(&session->back_log);
+ 	skb_queue_head_init(&session->i_skbq);
+ 	session->o_receive_continue = 1;
+ 	session->i_rcvbuf	    = 0xFFFF;
+ 	atomic_set(&session->refcnt, 1);
+ out:	return session;
+ }
+ 
+ /*
+  * Function: nbss_ack_bytes
+  *	Acknowledges reception of some bytes from input stream, by correctly
+  *	setting control variables of session.
+  *
+  * Parameters:
+  *	session : pointer to session_t whose bytes are to be acknowledged.
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- This function is used in transition handlers.
+  *	- It does not actually acknowledge byte, it simply justifies
+  *	  acknowledgement control variables.
+  */
+ static void nbss_ack_bytes(session_t *session)
+ {
+ 	unsigned short r_nacked;
+ 		
+ 	session_hold(session);
+ 	r_nacked = session->o_txed - session->r_acked;
+ 	session->o_size += r_nacked;
+ 	session->o_buff -= r_nacked;
+ 	session->o_acked += session->r_acked;
+ 	session->o_txed = session->r_acked = 0;
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_sleep_on
+  *	This is a process control routine and customized version of Linux
+  *	kernel sleep_on for session operations. It works in conjunction
+  *	with session locking facilities to provide a secure mechanism for
+  *	process control.
+  *
+  * Parameters:
+  *	session : pointer to session_t whose process is to be controlled
+  *	state 	: Linux state parameter that describes how to sleep. Usually
+  *		  TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE are values passed
+  *		  for this argument.
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- The only difference between nbss_sleep_on and sleep_on is in the
+  *	  decision made before schedule() which in nbss_sleep_on is determined
+  *	  by nbss_release_session(). The reason is in abrupt termination of a
+  *	  session while the sleeping procedure runs. This routines integrates
+  *	  conditions so that race conditions are avoided.
+  */
+ static inline void nbss_sleep_on(session_t *session, int state)
+ {
+ 	wait_queue_t wait;
+ 
+ 	session_hold(session);
+ 	init_waitqueue_entry(&wait, current);
+ 	set_current_state(state);
+ 	add_wait_queue(&session->waitq, &wait);
+ 	
+ 	if (!nbss_release_session(session)) {
+ 		dprintk("about to call schedule\n");
+ 		schedule();
+ #if WAITQUEUE_DEBUG
+ 		dprintk("sleeper=%p, waker=%lx\n",
+ 			 current_text_addr(), wait.__waker);
+ #endif
+ 	} else
+ 		set_current_state(TASK_RUNNING);
+ 	remove_wait_queue(&session->waitq, &wait);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_add_session_to_list
+  *	Inserts a previously allocated/initialized session_t into session
+  *	pending list.
+  *
+  * Parameters:
+  *	session : pointer to session_t to add to pending session list
+  *
+  * Returns: none
+  */
+ static void __nbss_add_session_to_list(session_t *session)
+ {
+ 	session->next = session_list;
+ 	session_list  = session;
+ }
+ 
+ static void nbss_add_session_to_list(session_t *session)
+ {
+ 	spin_lock_bh(&session_list_lock);
+ 	__nbss_add_session_to_list(session);
+ 	spin_unlock_bh(&session_list_lock);
+ }
+ 
+ /*
+  * Function: nbss_remove_session_from_list
+  *	Removes a session from pending session list
+  *
+  * Parameters:
+  *	session : pointer to session_t to remove from pending session list
+  *
+  * Returns: none
+  */
+ static void nbss_remove_session_from_list(session_t *session)
+ {
+ 	session_t *entry, *prev_entry = NULL;
+ 
+ 	spin_lock_bh(&session_list_lock);
+ 	entry = session_list;
+ 	while (entry) {
+ 		if (entry == session) {
+ 			if (prev_entry)
+ 				prev_entry->next = entry->next;
+ 			else
+ 				session_list = entry->next;
+ 		}
+ 		prev_entry	= entry;
+ 		entry		= entry->next;
+ 	}
+ 	spin_unlock_bh(&session_list_lock);
+ }
+ 
+ /*
+  * Function: nbss_find_listen
+  *	Finds a session_t in session pending list who listens to a specific
+  *	name.
+  *
+  * Parameters:
+  *	name	: pointer to NetBIOS name the session listens to
+  *
+  * Returns:
+  *	NULL	: if no pending session found listening to name
+  *	non-NULL: pointer to a pending session in list who listens to name
+  */
+ static session_t *nbss_find_listen(unsigned char *name)
+ {
+ 	session_t *session;
+ 
+ 	spin_lock_bh(&session_list_lock);
+ 	session = session_list;
+ 	while (session) {
+ 		if (session->state == NETBEUI_SESS_LISTENWAIT &&
+ 		    !memcmp(session->local_name->name, name, NETBEUI_NAME_LEN))
+ 			break;
+ 		session = session->next;
+ 	}
+ 	if (session)
+ 		session_hold(session);
+ 	spin_unlock_bh(&session_list_lock);
+ 	return session;
+ }
+ 
+ /*
+  * Function: nbss_unicast_name_recognized
+  *	Prepares a NetBIOS NAME RECOGNIZED frame and nbll_uisends it to network
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built from
+  *		  this session usually is selected from pending session list.
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to network.
+  *	non-zero: if frame transmission encountered an error (usually at NDI
+  *		  layer)
+  *
+  * Notes:
+  *	- NetBIOS NAME RECOGNIZED frame is the response to a NetBIOS NAME QUERY
+  *	  frame received from network. The interface which accepts NAME QUERY
+  *	  frame passes the sk_buff via session->skb to reuse it for NAME
+  *	  RECOGNIZED frame, thus reducing memory consumption.
+  */
+ static int nbss_unicast_name_recognized(session_t *session)
+ {
+ 	/* It is supposed that name query skb is put in session->skb f/ reuse */
+ 	dgram_t *hdr;
+ 	int rc;
+ 
+ 	session_hold(session);
+ 	hdr = (dgram_t *)session->skb->data;
+ 	hdr->length	= nb_command_header_len[NETBEUI_NAME_RECOGNIZED];
+ 	hdr->command	= NETBEUI_NAME_RECOGNIZED;
+ 	hdr->data1	= 0;
+ 	hdr->data2	= NETBEUI_CALL_DATA2(session->local_name->type,
+ 					     session->lsn);
+ 	hdr->xmit_correlator	= hdr->resp_correlator;
+ 	hdr->resp_correlator	=
+ 		session->resp_correlator = nbss_next_correlator();
+ 	memcpy(hdr->dest_name, hdr->source_name, NETBEUI_NAME_LEN);
+ 	memcpy(hdr->source_name, session->local_name->name, NETBEUI_NAME_LEN);
+ 	rc = nbll_uisend(session->remote_mac, session->skb);
+ 	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_alloc_session_skb
+  *	Allocates and prepares a skb for session service purposes
+  *
+  * Parameters:
+  *	sn	: pointer to session that sk_buff is allocated for it.
+  *	len	: length of data in skb
+  *	priority: a Linux kernel style memory allocation policy flag from
+  *		  GFP_* (GFP_KERNEL, GF_ATOMIC, GFP_USER, ...) family.
+  *
+  * Returns:
+  *	NULL	: if can not allocate memory for sk_buff
+  *	non-NULL: pointer to sk_buff
+  */
+ static struct sk_buff *nbss_alloc_session_skb(session_t *sn, int len,
+ 					      int priority)
+ {
+ 	struct sk_buff *skb;
+ 
+ 	session_hold(sn);
+ 	skb = alloc_skb(len + sn->llcmac_ihl, priority);
+ 	if (skb) {
+ 		skb_reserve(skb, sn->llcmac_ihl);
+ 		skb->nh.raw = skb->h.raw = skb->data;
+ 	}
+ 	session_put(sn);
+ 	return skb;
+ }
+ 
+ /*
+  * Function: nbss_ack_with_data
+  *	Acknowledges incoming bytes with an outgoing frame by justifying
+  *	data control bytes.
+  *
+  * Parameters:
+  *	session	: pointer to session_t, the acknowledgement is generated for
+  *	hdr	: pointer to packet_t header of outgoing frame.
+  *
+  * Returns: none
+  */
+ static void nbss_ack_with_data(session_t *session, packet_t *hdr)
+ {
+ 	session_hold(session);
+ 	barrier();
+ 	if (session->o_ack_correlator) {
+ 		del_timer(&session->timer);
+ 		NETBEUI_INCLUDE_ACK_WITH_DATA(hdr);
+ 		hdr->xmit_correlator = (unsigned short)
+ 						session->o_ack_correlator;
+ 		session->o_ack_correlator = 0;
+ 	}
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_isend_session_initialize
+  *	Prepares a NetBIOS SESSION INITIALIZE frame and nbll_isends it toward
+  *	remote session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to network.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  *
+  * Notes:
+  *	- NetBIOS NAME RECOGNIZED frame is the response to a NetBIOS NAME QUERY
+  *	  frame received from network. The interface which accepts NAME QUERY
+  *	  frame passes the sk_buff via session->skb to reuse it for NAME
+  *	  RECOGNIZED frame, thus reducing memory consumption.
+  */
+ static int nbss_isend_session_initialize(session_t *session)
+ {
+ 	int session_packet_len =
+ 			nb_command_header_len[NETBEUI_SESSION_INITIALIZE];
+ 	struct sk_buff *skb;
+ 	packet_t *hdr;
+ 	int rc = -ENOMEM;
+ 
+ 	session_hold(session);
+ 	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_ATOMIC);
+ 	if (!skb)
+ 		goto out;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_SESSION_INITIALIZE;
+ 	hdr->data1		= 0x81; /* NetBIOS 2.2 with ability to
+ 					   handle nack */
+ 	/* Token Ring support */
+ 	NETBEUI_CALC_SESS_MTU(session);
+ 	hdr->data1		|= (session->tr_frame_lf << 1) & 0x0E;
+ 	hdr->data2		= session->mtu;
+ 	hdr->xmit_correlator	= session->xmit_correlator;
+ 	hdr->resp_correlator	=
+ 		session->resp_correlator = nbss_next_correlator();
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 	rc = nbll_isend(session->link_no, skb);
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_isend_session_confirm
+  *	Prepares a NetBIOS SESSION CONFIRM frame and nbll_isends it toward
+  *	remote session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	non-zero: if frame transmission encountered an error
+  *
+  * Notes:
+  *	- NetBIOS SESSION INITIALIZE frame is the response to a NetBIOS SESSION
+  *	  CONFIRM frame received from remote session. The interface which
+  *	  accepts SESSION INITIALIZE frame passes the sk_buff via session->skb
+  *	  to reuse it for SESSION CONFIRM frame, thus reducing memory
+  *	  consumption.
+  */
+ static int nbss_isend_session_confirm(session_t *session)
+ {
+ 	/* I suppose get_session_initialize has set session->skb for reuse */
+ 	packet_t *hdr;
+ 	int rc;
+ 
+ 	session_hold(session);
+ 	hdr		= (packet_t *)session->skb->data;
+ 	hdr->length	= nb_command_header_len[NETBEUI_SESSION_CONFIRM];
+ 	hdr->command	= NETBEUI_SESSION_CONFIRM;
+ 	hdr->data1	= 0x81; /* NetBIOS 2.2 with ability to
+ 					    handle nack */
+ 	hdr->data2	= session->mtu;
+ 	session->resp_correlator = hdr->resp_correlator;
+ 	hdr->resp_correlator	 = session->xmit_correlator;
+ 	hdr->xmit_correlator	 = session->resp_correlator;
+ 	hdr->dest_num		 = session->rsn;
+ 	hdr->source_num		 = session->lsn;
+ 	rc = nbll_isend(session->link_no, session->skb);
+ 	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_isend_data_first_middle
+  *	Prepares a NetBIOS DATA FIRST MIDDLE frame and nbll_isends it toward
+  *	remote session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *	cflow	: flag that indicates requesting RECEIVE CONTINUE from remote session
+  *		  zero means do not request RECEIVE CONTINUE
+  *		  non-zero means request RECEIVE CONTINUE
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  */
+ static int nbss_isend_data_first_middle(session_t *session, int cflow)
+ {
+ 	int session_packet_len =
+ 			nb_command_header_len[NETBEUI_DATA_FIRST_MIDDLE];
+ 	struct sk_buff *skb;
+ 	packet_t *hdr;
+ 	int rc = -ENOMEM;
+ 
+ 	session_hold(session);
+ 	skb = nbss_alloc_session_skb(session, session_packet_len + session->mtu,
+ 				     GFP_KERNEL);
+ 	if (!skb)
+ 		goto out;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_DATA_FIRST_MIDDLE;
+ 	hdr->data1		= 0;
+ 	hdr->data2		= session->o_receive_outstanding;
+ 	session->o_receive_outstanding = 0;
+ 	hdr->xmit_correlator	= 0;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 	
+ 	if (cflow) {
+ 		NETBEUI_REQUEST_RECEIVE_CONTINUE(hdr);
+ 		session->o_receive_continue = 0;
+ 		hdr->resp_correlator =
+ 			session->resp_correlator = nbss_next_correlator();
+ 	}
+ 	if (session->o_noack)
+ 		NETBEUI_INDICATE_NACK(hdr);
+ 	rc = -EFAULT;
+ 	if (copy_from_user(skb_put(skb, session->mtu), session->o_buff,
+ 			   session->mtu))
+ 		goto err;
+ 	nbss_ack_with_data(session, hdr);
+ 	rc = nbll_isend(session->link_no, skb);
+ out:	session_put(session);
+ 	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbss_isend_data_only_last
+  *	Prepares a NetBIOS DATA ONLY LAST frame and nbll_isends it toward
+  *	remote session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  */
+ static int nbss_isend_data_only_last(session_t *session)
+ {
+ 	int session_packet_len = nb_command_header_len[NETBEUI_DATA_ONLY_LAST];
+ 	struct sk_buff *skb;
+ 	packet_t *hdr;
+ 	int rc = -ENOMEM;
+ 
+ 	session_hold(session);
+ 	skb = nbss_alloc_session_skb(session, session_packet_len +
+ 						session->o_size, GFP_KERNEL);
+ 	if (!skb)
+ 		goto out;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_DATA_ONLY_LAST;
+ 	hdr->data1		= 0;
+ 	hdr->data2		= session->o_receive_outstanding;
+ 	session->o_receive_outstanding = 0;
+ 	hdr->xmit_correlator	= 0;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 
+ 	if (session->o_noack)
+ 		NETBEUI_INDICATE_NACK(hdr);
+ 	else {
+ 		hdr->resp_correlator = session->resp_correlator =
+ 			nbss_next_correlator();
+ 		NETBEUI_ALLOW_ACK_WITH_DATA(hdr);
+ 	}
+ 	rc = -EFAULT;
+ 	if (copy_from_user(skb_put(skb, session->o_size), session->o_buff,
+ 				   session->o_size))
+ 		goto err;
+ 	nbss_ack_with_data(session, hdr);
+ 	rc = nbll_isend(session->link_no, skb);
+ out:	session_put(session);
+ 	return rc;
+ err:	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbss_isend_receive_continue
+  *	Prepares a NetBIOS RECEIVE CONTINUE frame and nbll_isends it toward
+  *	remote session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *	hdr	: pointer to packet_t header of the incoming frame which the
+  *		  RECEIVE CONTINUE frame is built for.
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  */
+ static int nbss_isend_receive_continue(packet_t *source_hdr, session_t *session)
+ {
+ 	packet_t *hdr;
+ 	int session_packet_len =
+ 				nb_command_header_len[NETBEUI_RECEIVE_CONTINUE];
+ 	struct sk_buff *skb;
+ 	int rc = -ENOMEM;
+ 
+ 	session_hold(session);
+ 	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_ATOMIC);
+ 	if (!skb)
+ 		goto out;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_RECEIVE_CONTINUE;
+ 	hdr->data1		= 0;
+ 	hdr->data2		= 0;
+ 	hdr->xmit_correlator	= source_hdr->resp_correlator;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 	rc = nbll_isend(session->link_no, skb);
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_isend_no_receive
+  *	Prepares a NetBIOS RECEIVE CONTINUE frame and nbll_isends it toward
+  *	remote session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *	skb	: pointer to sk_buff to use for building frame. This sk_buff
+  *		  is the one that contained incoming frame and since its data
+  *		  is not accepted from input stream, it is passed for reuse.
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  */
+ static int nbss_isend_no_receive(struct sk_buff *skb, session_t *session)
+ {
+ 	int session_packet_len = nb_command_header_len[NETBEUI_NO_RECEIVE];
+ 	packet_t *hdr;
+ 	unsigned char data1;
+ 	int rc;
+ 
+ 	session_hold(session);
+ 	data1 = NETBEUI_NACK_INDICATOR(((packet_t *)skb->data));
+ 	skb_trim(skb, 0);
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_NO_RECEIVE;
+ 	hdr->data1		= data1;
+ 	hdr->data2		= session->i_notacked;
+ 	hdr->xmit_correlator	= 0;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 
+ 	rc = nbll_isend(session->link_no, skb);
+ 	if (!rc) {
+ 		session->i_state	= NETBEUI_RECV_NO_RECEIVE;
+ 		session->i_notacked	= 0;
+ 	}
+ 	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_isend_receive_outstanding
+  *	Prepares a NetBIOS RECEIVE OUTSTANDING frame and nbll_isends it toward
+  *	remote session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  *
+  * Notes:
+  *	- Since the frame is transmitted within a user process context,
+  *	  and and works with input state variable, it locks a session during
+  *	  transmission period.
+  */
+ static int nbss_isend_receive_outstanding(session_t *session)
+ {
+ 	int session_packet_len =
+ 			nb_command_header_len[NETBEUI_RECEIVE_OUTSTANDING];
+ 	struct sk_buff *skb;
+ 	packet_t *hdr;
+ 	int rc = -ENOMEM;
+ 
+ 	session_hold(session);
+ 	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_KERNEL);
+ 	if (!skb)
+ 		goto out;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_RECEIVE_OUTSTANDING;
+ 	hdr->data1		= 0;
+ 	hdr->data2		= 0;
+ 	hdr->xmit_correlator	= 0;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 	nbss_lock_session(session);
+ 
+ 	rc = nbll_isend(session->link_no, skb);
+ 	if (!rc)
+ 		session->i_state = NETBEUI_RECV_RECEIVE_OUTSTANDING;
+ 	nbss_release_session(session);
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_isend_data_ack
+  *	Prepares a NetBIOS DATA ACK frame and nbll_isends it toward remote
+  *	session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *	ack_correlator: this is the xmit correlator found in the incoming frame
+  *		        passed to be put in response correlator of the DATA ACK
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  */
+ static int nbss_isend_data_ack(session_t *session,
+ 			       unsigned short ack_correlator)
+ {
+ 	int session_packet_len = nb_command_header_len[NETBEUI_DATA_ACK];
+ 	struct sk_buff *skb;
+ 	packet_t *hdr;
+ 	int rc = -ENOMEM;
+ 
+ 	session_hold(session);
+ 	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_ATOMIC);
+ 	if (!skb)
+ 		goto out;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_DATA_ACK;
+ 	hdr->data1		= 0;
+ 	hdr->data2		= 0;
+ 	hdr->xmit_correlator	= ack_correlator;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 	rc = nbll_isend(session->link_no, skb);
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_ack_session_data
+  *	Actually acknowledges incoming session data depending on current
+  *	condition either by sending DATA ACK frame or by postponing and
+  *	sending ACK WITH DATA.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *	hdr	: pointer to packet_t header of the incoming frame which the
+  *		  acknowledgement is built for.
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  */
+ static int nbss_ack_session_data(packet_t *hdr, session_t *session)
+ {
+ 	int rc = 0;
+ 
+ 	session_hold(session);
+ 	if (NETBEUI_ACK_WITH_DATA_ALLOWED(hdr) &&
+ 	    !session->o_ack_correlator && !session->urgent_ack) {
+ 		session->o_ack_correlator = hdr->resp_correlator |
+ 					    NETBEUI_ACK_FLAG;
+ 		session->timer.expires	= jiffies + NETBEUI_DATA_ACK_TIMEOUT;
+ 		add_timer(&session->timer);
+ 		goto out;
+ 	}
+ 	rc = nbss_isend_data_ack(session, hdr->resp_correlator);
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_ack_timer_function
+  *	Handles delayed acknowledgement for a session when its timer expires
+  *	by sending a DATA ACK frame.
+  *
+  * Parameters:
+  *	input	: pointer to session_t structure whose timer is expired.
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- We never re-enter LLC from its upper layer interface since it is
+  *	  not re-entrant. However ack timers expire and thus cause NetBEUI
+  *	  to send DATA ACK which re-enters LLC.
+  */
+ static void nbss_ack_timer_function(unsigned long input)
+ {
+ 	session_t *session = (session_t *)input;
+ 
+ 	session_hold(session);
+ 	if (llc_in_progress ||
+ 	    nbss_isend_data_ack(session, session->o_ack_correlator)) {
+ 		session->timer.expires = jiffies + NETBEUI_DATA_ACK_TIMEOUT;
+ 		add_timer(&session->timer);
+ 	} else
+ 		session->o_ack_correlator = 0;
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_isend_session_end
+  *	Prepares a NetBIOS SESSION END frame and nbll_isends it toward remote
+  *	session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame should be built for
+  *
+  * Returns:
+  *	0	: if frame is successfully transmitted to remote session.
+  *	-ENOMEM : if memory allocation for sk_buff failed.
+  *	other   : if frame transmission encountered an error
+  */
+ static int nbss_isend_session_end(session_t *session)
+ {
+ 	int session_packet_len = nb_command_header_len[NETBEUI_SESSION_END];
+ 	struct sk_buff *skb;
+ 	packet_t *hdr;
+ 	int rc = -ENOMEM;
+ 
+ 	session_hold(session);
+ 	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_KERNEL);
+ 	if (!skb)
+ 		goto out;
+ 	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+ 	hdr->length		= session_packet_len;
+ 	hdr->delimiter		= NETBEUI_DELIMITER;
+ 	hdr->command		= NETBEUI_SESSION_END;
+ 	hdr->data1		= 0;
+ 	hdr->data2		= 0;
+ 	hdr->xmit_correlator	= 0;
+ 	hdr->resp_correlator	= 0;
+ 	hdr->dest_num		= session->rsn;
+ 	hdr->source_num		= session->lsn;
+ 	rc = nbll_isend(session->link_no, skb);
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbns_handle_event
+  *	This is the heart of Session Service State Machine, which performs a
+  *	transition from current state of session element to new state based
+  *	on event occurred and session state table contents.
+  *
+  * Parameters:
+  *	event	: An integer of NETBEUI_SESS_* family that implies type of event
+  *	nb_name	: pointer to name_t structure which the event occurred on
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- The state changes before actions be executed. This is due to
+  *	  non deterministic behavior of actions which may sleep the current
+  *	  process, thus stopping the function in the mid-way.
+  */
+ static void nbss_handle_event(session_event_t event, session_t *session)
+ {
+ 	struct event_struct *ev;
+ 
+ 	session_hold(session);
+ 	ev = &session_state_table[session->state][event];
+ 	if (ev && ev->event_handler) {
+ 		unsigned char old_state	= session->state;
+ 
+ 		session->state	= ev->next_state;
+ 		if (ev->event_handler(session))
+ 			session->state = old_state;
+ 	}
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_wait_timer_function
+  *	This is the callback function triggered upon expiration of session
+  *	wait timer used first during session establishment and then for
+  *	delaying acknowledgements.
+  *
+  * Parameters:
+  *	input	: pointer to session_t structure whose timer is expired.
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- This timer function, set in session allocation time is used during
+  *	  session establishment.
+  */
+ static void nbss_wait_timer_function(unsigned long input)
+ {
+ 	session_t *session = (session_t *)input;
+ 
+ 	session_hold(session);
+ 	session->status = -ETIMEDOUT;
+ 	nbss_handle_event(NETBEUI_SESS_TIMEOUT, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function:
+  *	This is the callback function trigerred upon expiration of session
+  *	resource timer used when resources (usually memory) are ended up.
+  *
+  * Parameters:
+  *	input	: pointer to session_t structure whose timer is expired.
+  *
+  * Returns: none
+  */
+ static void nbss_resource_timer_function(unsigned long input)
+ {
+ 	session_t *session = (session_t *)input;
+ 
+ 	session_hold(session);
+ 	switch (session->o_rsrc_origin) {
+ 		case NETBEUI_ORIGIN_CONNECTED:
+ 			nbss_handle_event(NETBEUI_SESS_CONN_RETRY, session);
+ 			break;
+ 		case NETBEUI_ORIGIN_NORMAL:
+ 			nbss_handle_event(NETBEUI_SESS_NORM_RETRY, session);
+ 			break;
+ 		default:
+ 			printk(KERN_ERR "NetBEUI serious error: Resource "
+ 			       "timer expired from %u\n",
+ 			       session->o_rsrc_origin);
+ 			break;
+ 		}
+ 	session_put(session);
+ }
+ 
+ /*
+  * Session service state machine functions
+  * Implementing transition actions
+  */
+ static int nbss_abort_send_in_all(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_aborted = 1;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_call_in_initial(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbll_attach_session(session, session->remote_dev,
+ 					      session->remote_mac);
+ 	if (session->status)
+ 		goto out;
+ 	nbss_add_session_to_list(session);
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_listen_in_initial(session_t *session)
+ {
+ 	__nbss_add_session_to_list(session);
+ 	return 0;
+ }
+ 
+ static int nbss_confirm_in_callwait(session_t *session)
+ {
+ 	int rc;
+ 
+ 	session_hold(session);
+ 	session->status = nbll_link_session(session->link_no, session->lsn);
+ 	if (session->status) {
+ 		rc = session->status;
+ 		goto out;
+ 	}
+ 	session->status = nbss_isend_session_initialize(session);
+ 	rc = -ENOMEM;
+ 	if (session->status)
+ 		goto out;
+ 	nbss_remove_session_from_list(session);
+ 	session->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT *
+ 					   NETBEUI_TRANSMIT_COUNT;
+ 	add_timer(&session->timer);
+ 	sleep_on(&session->waitq);
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_reject_in_callwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_remove_session_from_list(session);
+ 	nbll_detach_session(session->link_no, session->lsn);
+ 	session->status = -ECONNABORTED;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_abort_in_callwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_remove_session_from_list(session);
+ 	session->status = -ECONNRESET;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_connect_in_confwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	del_timer(&session->timer);
+ 	wake_up(&session->waitq);
+ 	session->status = 0;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_timeout_in_confwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbll_detach_session(session->link_no, session->lsn);
+ 	wake_up(&session->waitq);
+ 	session->status = -ECONNREFUSED;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_abort_in_confwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	del_timer(&session->timer);
+ 	wake_up(&session->waitq);
+ 	session->status = -ECONNRESET;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_confirm_in_listenwait(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbll_attach_session(session, session->remote_dev,
+ 					      session->remote_mac);
+ 	if (session->status)
+ 		goto out;
+ 	session->status = nbss_unicast_name_recognized(session);
+ 	if (session->status) {
+ 		nbll_detach_session(session->link_no, session->lsn);
+ 		goto out;
+ 	}
+ 	session->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT *
+ 					   NETBEUI_TRANSMIT_COUNT;
+ 	add_timer(&session->timer);
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_reject_in_listenwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_remove_session_from_list(session);
+ 	session->status = -ECONNABORTED;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_connect_in_initwait(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbss_isend_session_confirm(session);
+ 	if (session->status)
+ 		goto out;
+ 	del_timer(&session->timer);
+ 	nbss_remove_session_from_list(session);
+ 	session->session_ready_callback(session->owner, session);
+ 	session->status = 0;
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_timeout_in_initwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbll_detach_session(session->link_no, session->lsn);
+ 	session->status = -ECONNREFUSED;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_abort_in_initwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	del_timer(&session->timer);
+ 	session->status = -ECONNRESET;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_reject_in_initwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	del_timer(&session->timer);
+ 	nbll_detach_session(session->link_no, session->lsn);
+ 	nbss_remove_session_from_list(session);
+ 	session->status = -ECONNABORTED;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_abort_in_connected(session_t *session)
+ {
+ 	session_hold(session);
+ 	if (session->owner)
+ 		session->abort_owner_callback(session->owner, session);
+ 	session->status = -ECONNRESET;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_hangup_in_connected(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_isend_session_end(session);
+ 	nbll_detach_session(session->link_no, session->lsn);
+ 	session->status = -ECONNABORTED;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_end_in_connected(session_t *session)
+ {
+ 	session_hold(session);
+ 	if (session->owner)
+ 		session->abort_owner_callback(session->owner, session);
+ 	nbll_detach_session(session->link_no, session->lsn);
+ 	session->status = -ECONNRESET;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_hangup_in_discwait(session_t *session)
+ {
+ 	return 0;
+ }
+ 
+ static inline void nbss_wait_event(session_t *session)
+ {
+         set_current_state(TASK_UNINTERRUPTIBLE);
+         if (!nbss_release_session(session))
+                 wait_event(session->waitq, (!session->o_txed ||
+                                             session->o_aborted));
+         else
+                 set_current_state(TASK_RUNNING);
+ }
+ 
+ static int nbss_first_middle_cont_in_connected(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbss_isend_data_first_middle(session, 1);
+ 	if (session->status)
+ 		goto out;
+ 	session->o_buff += session->mtu;
+ 	session->o_size -= session->mtu;
+ 	session->o_txed += session->mtu;
+ 	nbss_wait_event(session);
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_first_middle_in_connected(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbss_isend_data_first_middle(session, 0);
+ 	if (session->status)
+ 		goto out;
+ 	session->o_buff += session->mtu;
+ 	session->o_size -= session->mtu;
+ 	session->o_txed += session->mtu;
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_only_last_ack_in_connected(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbss_isend_data_only_last(session);
+ 	if (session->status)
+ 		goto out;
+ 	session->o_buff += session->o_size;
+ 	session->o_txed += session->o_size;
+ 	session->o_size -= session->o_size;
+ 	nbss_wait_event(session);
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_only_last_in_connected(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbss_isend_data_only_last(session);
+ 	if (session->status)
+ 		goto out;
+ 	session->o_buff += session->o_size;
+ 	session->o_txed += session->o_size;
+ 	session->o_size -= session->o_size;
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_resource_in_connected(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_rsrc_origin	= NETBEUI_ORIGIN_CONNECTED;
+ 	session->timer.expires	= jiffies + NETBEUI_RESOURCE_TIMEOUT;
+ 	session->timer.function	= nbss_resource_timer_function;
+ 	add_timer(&session->timer);
+ 	sleep_on(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_continue_in_contwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_acked += session->o_txed;
+ 	session->o_txed = 0;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_restart_in_contwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_pause_in_contwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	session->o_no_receive = 1;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_nonblock_in_contwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	session->o_no_receive = 1;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_restart_in_standwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_no_receive = 0;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_pause2_in_standwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_sleep_on(session, TASK_INTERRUPTIBLE);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_data_acked_in_ackwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_acked += session->o_txed;
+ 	session->o_txed = 0;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_restart_in_ackwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_pause_in_ackwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	session->o_no_receive = 1;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_nonblock_in_ackwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	session->o_no_receive = 1;
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_norm_retry_in_rsrcwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_conn_retry_in_rsrcwait(session_t *session)
+ {
+ 	session_hold(session);
+ 	wake_up(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_first_middle_in_normal(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbss_isend_data_first_middle(session, 0);
+ 	if (session->status)
+ 		goto out;
+ 	session->o_buff += session->mtu;
+ 	session->o_size -= session->mtu;
+ 	session->o_txed += session->mtu;
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_restart_in_normal(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_only_last_ack_in_normal(session_t *session)
+ {
+ 	int rc = -1;
+ 
+ 	session_hold(session);
+ 	session->status = nbss_isend_data_only_last(session);
+ 	if (session->status)
+ 		goto out;
+ 	session->o_buff += session->o_size;
+ 	session->o_txed += session->o_size;
+ 	session->o_size -= session->o_size;
+ 	nbss_wait_event(session);
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_only_last_in_normal(session_t *session)
+ {
+ 	int rc = -1;
+ 	
+ 	session_hold(session);
+ 	session->status = nbss_isend_data_only_last(session);
+ 	if (session->status)
+ 		goto out;
+ 	session->o_buff += session->o_size;
+ 	session->o_txed += session->o_size;
+ 	session->o_size -= session->o_size;
+ 	rc = 0;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ static int nbss_pause_in_normal(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	session->o_no_receive = 1;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_nonblock_in_normal(session_t *session)
+ {
+ 	session_hold(session);
+ 	nbss_ack_bytes(session);
+ 	session->o_no_receive = 1;
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ static int nbss_resource_in_normal(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_rsrc_origin	= NETBEUI_ORIGIN_NORMAL;
+ 	session->timer.expires	= jiffies + NETBEUI_RESOURCE_TIMEOUT;
+ 	session->timer.function	= nbss_resource_timer_function;
+ 	add_timer(&session->timer);
+ 	sleep_on(&session->waitq);
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ /*
+  * Session service state machine functions
+  * Implementing interface functions
+  */
+ /*
+  * Function: nbss_call
+  *	This is a sophisticated interface routine for establishing a session
+  *	with a remote hosts. Finding host that owns name, establishing session
+  *	building LLC connection and configuring session are the phases a session
+  *	element passes through them to prepare session for transferring data.
+  *
+  * Parameters:
+  *	calling_name   : pointer to name_t structure that the session is built
+  *			 either registered by client or NAME_NUMBER_1 auto bound
+  *	called_name    : pointer to NetBIOS name of remote node
+  *	owner	       : pointer to a data structure of the owner of session
+  *			 used for calling its call backs
+  *	itf_abort_owner: pointer to a callback routine for alerting owner, of
+  *			 session abortion
+  *	session_ptr    : (VRP) pointer to session_structure if return value
+  *			 indicates a valid value which is a pointer to session_t
+  *			 The owner later uses this value for getting services
+  *			 from Session Service module
+  *
+  * Returns:
+  *	0		: if a session successfully established to remote node
+  * 	-ENOMEM 	: if failed to allocate memory for session_t structure.	
+  *	-EHOSTUNREACH	: if can not find a node on network who owns the name.
+  *	-ETOONAMYREFS	: if more than one node responded to session
+  *			  establishment request. This means that it can not
+  *			  establish session with group names.
+  *	-ECONNREFUSED	: if node responded to request but refused to establish
+  *			  a session anyway.
+  *	-ECONNRESET	: if connection reset by LLC before session
+  *			  establishment ends
+  *	other		: any other error reported by LLC.
+  */
+ int nbss_call(name_t *calling_name, char *called_name, struct sock *owner,
+ 	      abort_owner_cbt itf_abort_owner, session_t **session_ptr)
+ {
+ 	int status;
+ #define MAX_FIND 3
+ 	char macs[MAX_FIND][6];
+ 	struct net_device *devs[MAX_FIND];
+ 	session_t *session = nbss_alloc_session();
+ 	int rc = -ENOMEM;
+ 
+ 	if (!session)
+ 		goto out;
+ 	*session_ptr			= NULL;
+ 	session->state			= NETBEUI_SESS_INITIAL;
+ 	session->owner			= owner;
+ 	session->local_name		= calling_name;
+ 	memcpy(session->remote_name, called_name, NETBEUI_NAME_LEN);
+ 	session->abort_owner_callback	= itf_abort_owner;
+ 
+ 	rc = status = nbqs_find_name(called_name, (char *)macs, devs, MAX_FIND);
+ 	if (status < 0)
+ 		goto sput;
+ 	else if (!status) {
+ 		rc = -EHOSTUNREACH;
+ 		goto sput;
+ 	} else if (status != 1) {
+ 		rc = -ETOOMANYREFS;
+ 		goto sput;
+ 	}
+ 	session_hold(session);
+ 	session->remote_dev = devs[0];
+ 	memcpy(session->remote_mac, macs, session->remote_dev->addr_len);
+ 
+ 	for (;;) {
+ 		nbss_handle_event(NETBEUI_SESS_CALL, session);
+ 		if (session->state == NETBEUI_SESS_INITIAL) {
+ 			rc = status = session->status;
+ 			goto dsput;
+ 		}
+ 		session->status = nbqs_query_name(called_name, calling_name,
+ 						  session->lsn, &session->rsn,
+ 						  &session->tr_frame_lf,
+ 						  &session->xmit_correlator);
+ 		/* We may have got a session abort here */
+ 		if (session->state == NETBEUI_SESS_INITIAL)
+ 			continue;
+ 		else
+ 			break;
+ 	}
+ 	/* We may also could not query server */
+ 	rc = -ECONNREFUSED;
+ 	if (session->status || !session->rsn || session->rsn == 0xFF) {
+ 		nbss_handle_event(NETBEUI_SESS_REJECT, session);
+ 		goto dsput;
+ 	}
+ 	/* Token Ring support */
+ 	session->llcmac_ihl = LLCMAC_I_HEADLEN(session->remote_dev);
+ 	nbss_handle_event(NETBEUI_SESS_CONFIRM, session);
+ 	if (session->state != NETBEUI_SESS_CONNECTED || session->status) {
+ 		status = session->status;
+ 		nbqs_delete_rnc(called_name);
+ 		rc = status ? : -ECONNRESET;
+ 		goto dsput;
+ 	}
+ 	rc = 0;
+ 	*session_ptr = session;
+ dsput:	session_put(session);
+ sput:	session_put(session);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: __nbss_listen
+  *	Prepares backlog session_ts for a server who is going to listen on
+  *	a name, kept in pending session list. Has to be called with
+  *	session_list_lock held, with spin_lock_bh or spin_lock, depending
+  *	on the context (process or BH).
+  *
+  * Parameters:
+  *	nb_name	: pointer to name_t the sessions listen to connection requests
+  *		  on it
+  *	backlog	: count of concurrent session establishments the session service
+  *		  should process at once.
+  *	owner	: pointer to a data structure of the owner of session
+  *		  used for calling its call backs
+  *	itf_abort_owner: pointer to a callback routine for alerting owner, of
+  *	     	  session abortion
+  * 	itf_session_ready: 	pointer to callback routine alerting owner, of
+  *		  existence of an established session.
+  *
+  * Returns:
+  *	>= 0	: count of backlog pending session in list who listen to name
+  *		  for connection establishment requests.
+  *
+  * Notes:
+  *	- The session does not guarantee to have as many pending sessions
+  *	  as requested by backlog parameter due to memory allocation fails.
+  *	  This should be considered by upper layer routines.
+  */
+ int __nbss_listen(name_t *nb_name, int backlog, struct sock *owner,
+ 		  abort_owner_cbt itf_abort_owner,
+ 		  session_ready_cbt itf_session_ready)
+ {
+ 	int count, exist = 0;
+ 	session_t *session = session_list;
+ 
+ 	while (session) {
+ 		if (session->local_name == nb_name)
+ 			exist++;
+ 		session = session->next;
+ 	}
+ 	for (count = exist; count < backlog; count++) {
+ 		session = nbss_alloc_session();
+ 		if (session) {
+ 			session->state			= NETBEUI_SESS_INITIAL;
+ 			session->owner			= owner;
+ 			session->local_name		= nb_name;
+ 			session->abort_owner_callback	= itf_abort_owner;
+ 			session->session_ready_callback	= itf_session_ready;
+ 			nbss_handle_event(NETBEUI_SESS_LISTEN, session);
+ 			exist++;
+ 		} else
+ 			break;
+ 	}
+ 	return exist;
+ }
+ 
+ int nbss_listen(name_t *nb_name, int backlog, struct sock *owner,
+ 		abort_owner_cbt itf_abort_owner,
+ 		session_ready_cbt itf_session_ready)
+ {
+ 	int rc;
+ 	spin_lock(&session_list_lock);
+ 	rc = __nbss_listen(nb_name, backlog, owner, itf_abort_owner,
+ 			   itf_session_ready);
+ 	spin_unlock(&session_list_lock);
+ 	return rc;
+ }
+ 
+ int nbss_listen_bh(name_t *nb_name, int backlog, struct sock *owner,
+ 		   abort_owner_cbt itf_abort_owner,
+ 		   session_ready_cbt itf_session_ready)
+ {
+ 	int rc;
+ 	spin_lock_bh(&session_list_lock);
+ 	rc = __nbss_listen(nb_name, backlog, owner, itf_abort_owner,
+ 			   itf_session_ready);
+ 	spin_unlock_bh(&session_list_lock);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_end_listen
+  *	Removes session_ts on pending session list who listen to session
+  *	establishment requests on a specific name, called only from
+  *	nbso_session_release, in process context, so no need to spin_lock_bh,
+  *	plain spin_lock is enough.
+  *
+  * Parameters:
+  *	nb_name	: pointer to name which sessions listening to it should be
+  *		  removed from pending session list.
+  *
+  * Returns: none
+  */
+ void __nbss_end_listen(name_t *nb_name)
+ {
+ 	session_t *next_session;
+ 	session_t *session;
+ 
+ 	session = session_list;
+ 	while (session) {
+ 		next_session = session->next;
+ 		if (session->local_name == nb_name) {
+ 			nbss_handle_event(NETBEUI_SESS_REJECT, session);
+ 			session_put(session);
+ 		}
+ 		session = next_session;
+ 	}
+ }
+ 
+ /*
+  * Function: nbss_send
+  *	This is the heart of output data stream.
+  *	Sends a block of user data to remote session by fragmenting and
+  *	controlling flow of data. In addition to simplicity it operates
+  *	a considerable part of Session Service State Machine by generating
+  *	different events carefully
+  *
+  * Parameters:
+  *	session	: pointer to session_t to send data on
+  *	buf	: pointer to user buffer that contains data
+  *	size	: size of data in user buffer
+  *	nonblock: flag that indicates to block user process or not block
+  *		  it (0/1)
+  *	noack	: flag that indicates to receive data receive acknowledgement
+  *		  or not (0/1)
+  *
+  * Returns:
+  *	>= 0		: count of data bytes successfully sent to remote
+  *			  session
+  *	-ECONNABORTED	: if session aborted.
+  *	-EINPROGRESS	: if another process currently sends data in session
+  *			  this may happen if two process share a socket.
+  *	-ETIME		: if send timeout. this happens if interface layer
+  *			  calls nbss_send_abort when its timers expire.
+  */
+ int nbss_send(session_t *session, unsigned char *buf, unsigned short size,
+ 	      unsigned char nonblock, unsigned char noack)
+ {
+ 	int rc = -ECONNABORTED;
+ 
+ 	session_hold(session);
+ 	if (session->zapped)
+ 		goto out;
+ 	rc = -EINPROGRESS;
+ 	if (session->state != NETBEUI_SESS_CONNECTED)
+ 		goto out;
+ 	session->o_nonblock    = nonblock;
+ 	session->o_noack       = session->version == NETBEUI_VERSION_2xx ? noack : 0;
+ 	session->o_no_receive  = 0;
+ 	session->o_rsrc_origin = 0;
+ 	session->o_buff	       = buf;
+ 	session->o_buffsize    = size;
+ 	session->o_size	       = size;
+ 	session->o_txed	       = 0;
+ 	session->o_acked       = 0;
+ 	session->r_acked       = 0;
+ 	session->o_aborted     = 0;
+ 	while (session->o_acked < session->o_buffsize) {
+ 		nbss_lock_session(session);
+ 		session->status = 0;
+ 
+ 		if (session->o_size > session->mtu &&
+  		    session->o_size == session->o_buffsize &&
+ 		    session->o_receive_continue)
+ 			nbss_handle_event(NETBEUI_SESS_FIRST_MIDDLE_CONT, session);
+ 		else if (session->o_size > session->mtu)
+ 			nbss_handle_event(NETBEUI_SESS_FIRST_MIDDLE, session);
+ 		else if (!noack && session->o_size > 0)
+ 			nbss_handle_event(NETBEUI_SESS_ONLY_LAST_ACK, session);
+ 		else if (session->o_size > 0)
+ 			nbss_handle_event(NETBEUI_SESS_ONLY_LAST, session);
+ 		rc = session->status;
+ 		if (nbss_release_session(session))
+ 			goto out;
+ 		rc = -ETIME;
+ 		if (session->o_aborted)
+ 			goto out;
+ 		if (session->o_no_receive && session->o_nonblock) {
+ 			rc = session->o_acked;
+ 			break;
+ 		}
+ 		if (session->o_no_receive) {
+ 			nbss_lock_session(session);
+ 			nbss_handle_event(NETBEUI_SESS_PAUSE2, session);
+ 			nbss_release_session(session);
+ 			if (signal_pending(current)) {
+ 				rc = session->o_acked > 0 ? session->o_acked :
+ 							    -ERESTART;
+ 				break;
+ 			}
+ 		}
+ 		if (session->status == -ENOMEM) {
+ 			nbss_lock_session(session);
+ 			nbss_handle_event(NETBEUI_SESS_RESOURCE, session);
+ 			nbss_release_session(session);
+ 		}
+ 		rc = session->o_acked;
+ 	}
+ 	session->state = NETBEUI_SESS_CONNECTED;
+ 	if (rc > size)
+ 		rc = size;
+ 	if (rc > 0)
+ 		session->o_total += rc;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_send_zero
+  *	Sends a zero byte DATA ONLY LAST frame to remote node.
+  *
+  * Parameters:
+  *	session	: pointer to session_t to send frame on
+  *	buf	: pointer to a user buffer that is referenced in transition
+  *		  handlers of state machine
+  *
+  * Returns:
+  *	>= 0		: if size of data bytes successfully sent to remote
+  *			  session
+  *	-ECONNABORTED	: if session aborted.
+  *	-EINPROGRESS	: if another process currently sends data in session
+  *			  this may happen if two process share a socket.
+  *
+  * Notes:
+  *	- This feature is activated via ioctl interface and has special
+  *	  meaning to SAMBA that operates over NetBEUI
+  */
+ int nbss_send_zero(session_t *session, char *buf)
+ {
+ 	int rc = -ECONNABORTED;
+ 
+ 	session_hold(session);
+ 	if (session->zapped)
+ 		goto out;
+ 	rc = -EINPROGRESS;
+ 	if (session->state != NETBEUI_SESS_CONNECTED)
+ 		goto out;
+ 	session->o_nonblock	= 1;
+ 	session->o_noack	= 1;
+ 	session->o_no_receive	= 0;
+ 	session->o_rsrc_origin	= 0;
+ 	session->o_buff		= buf;
+ 	session->o_buffsize	= 0;
+ 	session->o_size		= 0;
+ 	session->o_txed		= 0;
+ 	session->o_acked	= 0;
+ 	session->r_acked	= 0;
+ 	session->o_aborted	= 0;
+ 	session->status		= 0;
+ 	nbss_handle_event(NETBEUI_SESS_ONLY_LAST, session);
+ 	rc = session->status;
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_abort_send
+  *	The interface which aborts a send operation, usually called from
+  *	upper interface when send timers expire.
+  *
+  * Parameters:
+  *	session	: pointer to session_t whose send operation is to be aborted.
+  *
+  * Returns: none
+  */
+ void nbss_abort_send(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_aborted = 1;
+ 	nbss_handle_event(NETBEUI_SESS_ABORT_SEND, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_send_ready
+  *	Determines if session is ready to send data or not
+  *
+  * Parameters:
+  *	session	: pointer to session_t.
+  *
+  * Returns:
+  *	1	: if session is ready to send data
+  *	0	: if session is not ready to send data
+  */
+ int nbss_send_ready(session_t *session)
+ {
+ 	int rc;
+ 
+ 	session_hold(session);
+ 	rc = !session->zapped && session->state == NETBEUI_SESS_CONNECTED ? 1 : 0;
+ 	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_receive
+  *	Receives data from input stream buffer and copies it into user
+  *	buffer.
+  *
+  * Parameters:
+  *	session	: pointer to session_t to receive data from
+  *	buf	: pointer to user space buffer to put data into
+  *	size	: maximum size of data to put in buf
+  *	nonblock: flag that indicates whether to block user process if
+  *	          data was not available
+  *
+  * Returns:
+  *	>= 0		: count of data bytes fetched from input stream queue
+  *	-ECONNABORTED	: if session aborted.
+  *	-ETIME		: if receive timeout. this happens if interface layer
+  *			  calls nbss_receive_abort when its timers expire.
+  *	-ERESTART	: if process caught a signal
+  *	-EAGAIN		: if zero data bytes received.
+  */
+ int nbss_receive(session_t *session, unsigned char *buf, unsigned short size,
+ 		 unsigned char nonblock)
+ {
+ 	unsigned short i_size = size;
+ 	struct sk_buff *skb;
+ 	int rc = -ECONNABORTED;
+ 	
+ 	session_hold(session);
+ 	if (session->zapped && !skb_queue_len(&session->i_skbq))
+ 		goto out;
+ 	session->i_aborted = 0;
+ try_read:
+ 	nbss_lock_session(session);
+ 
+ 	while (i_size > 0 && (skb = skb_peek(&session->i_skbq)) != NULL) {
+ 		nbss_release_session(session);
+ 		if (i_size >= skb->len) {
+ 			rc = -EFAULT;
+ 			if (copy_to_user(buf, skb->data, skb->len))
+ 				goto out;
+ 			i_size -= skb->len;
+ 			buf += skb->len;
+ 			nbss_lock_session(session);
+ 			__skb_unlink(skb, &session->i_skbq);
+ 			session->i_size -= skb->len;
+ 			kfree_skb(skb);
+ 		} else {
+ 			rc = -EFAULT;
+ 			if (copy_to_user(buf, skb->data, i_size))
+ 				goto out;
+ 			skb_pull(skb, i_size);
+ 			buf += i_size;
+ 			nbss_lock_session(session);
+ 			session->i_size -= i_size;
+ 			i_size = 0;
+ 		}
+ 	}
+ 	while (i_size == size && !nonblock) {
+ 		dprintk("entering loop...\n");
+ 		rc = 0;
+ 		if (session->i_state == NETBEUI_RECV_NO_RECEIVE &&
+ 		    nbss_isend_receive_outstanding(session)) {
+ 			dprintk("session->i_state == "
+ 				"NETBEUI_RECV_NO_RECEIVE && "
+ 				"nbss_isend_receive_outstanding(session)\n");
+ 			goto out;
+ 		}
+ 		nbss_sleep_on(session, TASK_INTERRUPTIBLE);
+ 		rc = -ERESTART;
+ 		if (signal_pending(current)) {
+ 			dprintk("signal_pending(current)\n");
+ 			goto out;
+ 		}
+ 		if (session->i_size) {
+ 			dprintk("session->i_size != 0, goto try_read\n");
+ 			goto try_read;
+ 		}
+ 		rc = -ECONNABORTED;
+ 		if (session->zapped) {
+ 			dprintk("session->zapped != 0\n");
+ 			goto out;
+ 		}
+ 		rc = -ETIME;
+ 		if (session->i_aborted) {
+ 			dprintk("session->i_aborted != 0\n");
+ 			goto out;
+ 		}
+ 	}
+ 	nbss_release_session(session);
+ 	rc = i_size == size ? -EAGAIN : (size - i_size);
+ out:	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_abort_receive
+  *	The interface which aborts a receive operation, usually called from
+  *	upper interface when receive timers expire.
+  *
+  * Parameters:
+  *	session	: pointer to session_t whose send operation is to be aborted.
+  *
+  * Returns: none
+  */
+ void nbss_abort_receive(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->i_aborted	= 1;
+ 	session->status		= -ETIME;
+ 	wake_up_interruptible(&session->waitq);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_receive_ready
+  *	Determines if session has data in input stream queue or not
+  *
+  * Parameters:
+  *	session	: pointer to session_t.
+  *
+  * Returns:
+  *	1	: if session is ready to send data
+  *	0	: if session is not ready to send data
+  */
+ int nbss_receive_ready(session_t *session)
+ {
+ 	int rc;
+ 	session_hold(session);
+ 	rc = session->i_size;
+ 	session_put(session);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbss_trim_data
+  *	Removes some bytes from a DATA ONLY LAST frame which is fetched
+  *	before.
+  *
+  * Parameters:
+  *	session	: pointer to session_t.
+  *
+  * Returns:
+  *	0	: always returns zero
+  *
+  * Notes:
+  *	- This feature is activated via ioctl interface and has special
+  *	  meaning to SAMBA that operates over NetBEUI
+  *	- skb->acked flags the frame as a DATA ONLY LAST frame
+  *	- skb->used  indicates that some of frame data is fetched
+  *
+  * Important Note:
+  *	- Windows API implements NetBEUI socket interface of type SOCK_SEQPACKET
+  *	  and sends garbage at end of SMB messages. We have implemented
+  *	  SOCK_STREAM which accepts those garbages. The users process
+  *	  activates an IOCTL to remove unused data bytes from the stream of
+  *	  bytes.
+  *
+  *	- Another solution is modifying socket read mechanism so that a process
+  *	  can read the whole message. This may significantly improve SAMBA reads
+  *	  but reduces NetBEUI extensibility.
+  */
+ int nbss_trim_data(session_t *session)
+ {
+ 	struct sk_buff *skb;
+ 
+ 	session_hold(session);
+ 	skb = skb_peek(&session->i_skbq);
+ 	if (skb) {
+ 		nbss_lock_session(session);
+ 		__skb_unlink(skb, &session->i_skbq);
+ 		session->i_size -= skb->len;
+ 		nbss_release_session(session);
+ 		kfree_skb(skb);
+ 	}
+ 	session_put(session);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbss_hangup
+  *	The upper layer interface which terminates a session by generating a
+  *	proper event.
+  *
+  * Parameters:
+  *	session	: pointer to session_t which is to be terminated
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- During session termination there may be some unacknowledged data
+  *	  in input stream queue whose acknowledgement is not a an action
+  *	  of session transition handlers, since session data input stream
+  *	  is not part of Session State Machine.
+  */
+ void nbss_hangup(session_t *session)
+ {
+ 	session_hold(session);
+ 	del_timer(&session->timer);
+ 	if (session->o_ack_correlator)
+ 		nbss_isend_data_ack(session,
+ 				    (unsigned short)session->o_ack_correlator);
+ 	nbss_handle_event(NETBEUI_SESS_HANGUP, session);
+ 	session_put(session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_abort_session
+  *	This upper layer interface abnormally terminates a session.
+  *
+  * Parameters:
+  *	session	: pointer to session_t which is to be aborted
+  *
+  * Returns: none
+  */
+ void nbss_abort_session(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->zapped = 1;
+ 	del_timer(&session->timer);
+ 	nbss_abort_receive(session);
+ 	nbss_handle_event(NETBEUI_SESS_ABORT_SEND, session);
+ 	nbss_handle_event(NETBEUI_SESS_ABORT, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_name_query
+  *	Accepts a NAME QUERY frame and depending on FIND/QUERY characteristic
+  *	of it either responds NAME FIND or generates an event to start
+  *	session establishment.
+  *
+  * Parameters:
+  *	skb	  : pointer to sk_buff that holds the frame
+  *	remote_mac: pointer to MAC address of remote node who sent the frame
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- NAME FIND and NAME QUERY use the same frame format with different
+  *	  flags and field values.
+  *	- NAME FIND processing is simply responding with a NAME RECOGNIZED
+  *	- NAME QUERY processing is doing the first step of session establishment
+  *	- Since the skb is reused for generating response frame it is passed
+  *	  to element in session->skb
+  */
+ void nbss_get_name_query(struct sk_buff *skb, unsigned char *remote_mac)
+ {
+ 	dgram_t *hdr = (dgram_t *)skb->data;
+ 	name_t *nb_name = nbns_find_name(hdr->dest_name);
+ 	session_t *session = nbss_find_listen(hdr->dest_name);
+ 	session_t tmp_session;
+ 
+ 	if (!session) {
+ 		session			= &tmp_session;
+ 		session->local_name	= nb_name;
+ 		session->rsn		= 0;
+ 		atomic_set(&session->refcnt, 1);
+ 		session_hold(session);
+ 	} else
+ 		session->rsn = NETBEUI_CALL_SS(hdr->data2);
+ 	if (!nb_name) {
+ 		kfree_skb(skb);
+ 		goto out;
+ 	}
+ 	session->skb		= skb;
+ 	session->remote_dev	= skb->dev;
+ 	memcpy(session->remote_mac, remote_mac, skb->dev->addr_len);
+ 	memcpy(session->remote_name, hdr->source_name, NETBEUI_NAME_LEN);
+ 	session->lsn		= 0;
+ 	if (!session->rsn || session->rsn == 0xFF)
+ 		nbss_unicast_name_recognized(session);
+ 	else {
+ 		/* Token Ring support */
+ 		session->llcmac_ihl = LLCMAC_I_HEADLEN(session->remote_dev);
+ 		nbss_handle_event(NETBEUI_SESS_CONFIRM, session);
+ 	}
+ 	nbns_name_put(nb_name);
+ out:	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_session_initialize
+  *	Accepts a SESSION INITIALIZE frame and generates proper event.
+  *
+  * Parameters:
+  *	skb	: pointer to sk_buff that holds the frame
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- Due to implementation of events in NetBEUI whose data is put
+  *	  element temporary variable and just event identifier is passed
+  *	  to state machine, the routine first checks if the session is
+  *	  in a proper state to accept event or not.
+  *	- Since the skb is reused for generating response frame it is passed
+  *	  to element in session->skb
+  *	- At this point session_t element timer callback function changes to
+  *	  the callback that processes delayed acknowledgements of input data
+  */
+ static void nbss_get_session_initialize(struct sk_buff *skb, session_t *session)
+ {
+ 	packet_t *hdr;
+ 	unsigned short data2;
+ 
+ 	session_hold(session);
+ 	hdr = (packet_t *)skb->data;
+ 	data2 = hdr->data2;
+ 	if (session->state != NETBEUI_SESS_INITWAIT ||
+ 	    session->resp_correlator != hdr->xmit_correlator) {
+ 		kfree_skb(skb);
+ 		goto out;
+ 	}
+ 	if (!NETBEUI_IS_ABLE_TO_HANDLE_NACK(hdr))
+ 		session->nack_indicator = NETBEUI_NACK_NONE;
+ 	if (!NETBIOS_VERSION(hdr))
+ 		session->version = NETBEUI_VERSION_1xx;
+ 	session->tr_frame_lf = NETBEUI_TR_FRAME_LF(hdr);
+ 	/* Token Ring support */
+ 	NETBEUI_CALC_SESS_MTU(session);
+ 	if (session->mtu > data2)
+ 		session->mtu = data2;
+ 	session->skb = skb;
+ 	nbss_handle_event(NETBEUI_SESS_CONNECT, session);
+ 	/* From now on, the session timer is used for ACK piggy-backing */
+ 	session->timer.function = nbss_ack_timer_function;
+ 	/* skb is reused, thus we don't need to free it */
+ out:	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_session_confirm
+  *	Accepts a SESSION confirm frame and generates proper event.
+  *
+  * Parameters:
+  *	hdr	: pointer to packet_t which is frame header in sk_buff
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- Due to implementation of events in NetBEUI whose data is put
+  *	  element temporary variable and just event identifier is passed
+  *	  to state machine, the routine first checks if the session is
+  *	  in a proper state to accept event or not.
+  *	- At this point session_t element timer callback function changes to
+  *	  the callback that processes delayed acknowledgements of input data
+  */
+ static void nbss_get_session_confirm(packet_t *hdr, session_t *session)
+ {
+ 	unsigned short data2;
+ 
+ 	session_hold(session);
+ 	data2 = hdr->data2;
+ 	if (session->state != NETBEUI_SESS_CONFWAIT ||
+ 	    session->resp_correlator != hdr->xmit_correlator)
+ 		goto out;
+ 	if (!NETBEUI_IS_ABLE_TO_HANDLE_NACK(hdr))
+ 		session->nack_indicator = NETBEUI_NACK_NONE;
+ 	if (!NETBIOS_VERSION(hdr))
+ 		session->version = NETBEUI_VERSION_1xx;
+ 	if (session->mtu > data2)
+ 		session->mtu = data2;
+ 	nbss_handle_event(NETBEUI_SESS_CONNECT, session);
+ 	/* From now on, the session timer is used for ACK piggy-backing */
+ 	session->timer.function = nbss_ack_timer_function;
+ out:	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_data_ack
+  *	Accepts a DATA ACK frame and generates proper event.
+  *
+  * Parameters:
+  *	hdr	: pointer to packet_t which is frame header in sk_buff
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  */
+ static void nbss_get_data_ack(packet_t *hdr, session_t *session)
+ {
+ 	session_hold(session);
+ 	if (session->resp_correlator == hdr->xmit_correlator)
+ 		nbss_handle_event(NETBEUI_SESS_DATA_ACKED, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_session_data
+  *	Accepts DATA FIRST MIDDLE and DATA ONLY LAST frames and tries to
+  *	process frame by checking input state, data acknowledgement,
+  *	controlling flow of data and queueing frame in input stream queue.
+  *	(it does more than you may think at first glance)
+  *
+  * Parameters:
+  *	skb	: pointer to sk_buff which holds the frame
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- The frame pointers are adjusted to user data when frame is queued.
+  *	- skb->acked is set for DATA ONLY LAST frames and is used in trimming
+  *	  user data in nbss_trim_data(). It is since we adjust pointers to
+  *	  user data not NetBIOS header of frame.
+  */
+ static void nbss_get_session_data(struct sk_buff *skb, session_t *session)
+ {
+ 	packet_t *hdr;
+ 
+ 	session_hold(session);
+ 	hdr = (packet_t *)skb->data;
+ 	if (NETBEUI_ACK_WITH_DATA_INCLUDED(hdr))
+ 		nbss_get_data_ack(hdr, session);
+ 	if (session->i_state == NETBEUI_RECV_NO_RECEIVE ||
+ 	    (session->i_state == NETBEUI_RECV_RECEIVE_OUTSTANDING &&
+ 	     NETBEUI_RESYNCH_INDICATOR(hdr) != 0x0001) ||
+ 	    (session->i_state == NETBEUI_RECV_NORMAL &&
+ 	     NETBEUI_RESYNCH_INDICATOR(hdr) != 0x0000)) {
+ 		kfree_skb(skb);
+ 		goto out;
+ 	}
+ 	session->i_state = NETBEUI_RECV_NORMAL;
+ 
+ 	if (session->i_size > session->i_rcvbuf ||
+ 	    (hdr->command == NETBEUI_DATA_FIRST_MIDDLE &&
+ 	     NETBEUI_RECEIVE_CONTINUE_REQUESTED(hdr) &&
+ 	     nbss_isend_receive_continue(hdr, session)) ||
+ 	    (hdr->command == NETBEUI_DATA_ONLY_LAST &&
+ 	     !NETBEUI_NACK_INDICATOR(hdr) &&
+ 	     nbss_ack_session_data(hdr, session))) {
+ 		nbss_isend_no_receive(skb, session);
+ 		goto out;
+ 	}
+ 	skb_pull(skb, hdr->length);
+ 	__skb_queue_tail(&session->i_skbq, skb);
+ 	session->i_size += skb->len;
+ 	if (hdr->command == NETBEUI_DATA_FIRST_MIDDLE) {
+ 		if (!NETBEUI_RECEIVE_CONTINUE_REQUESTED(hdr))
+ 			session->i_notacked += skb->len;
+ 		else
+ 			session->i_notacked = 0;
+ 	} else  /* DATA ONLY LAST */
+ 		session->i_notacked = 0;
+ 
+ 	wake_up_interruptible(&session->waitq);
+ 	session->i_total += skb->len;
+ out:	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_receive_continue
+  *	Accepts a RECEIVE CONTINUE frame and generates a proper event.
+  *
+  * Parameters:
+  *	hdr	: pointer to packet_t which is frame header in sk_buff
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  */
+ static void nbss_get_receive_continue(packet_t *hdr, session_t *session)
+ {
+ 	session_hold(session);
+ 	if (session->resp_correlator == hdr->xmit_correlator)
+ 		nbss_handle_event(NETBEUI_SESS_CONTINUE, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_no_receive
+  *	Accepts a NO RECEIVE frame and generates proper events. The session
+  *	state digram purpose different events for blocking and non-blocking
+  *	sends
+  *
+  * Parameters:
+  *	hdr	: pointer to packet_t which is frame header in sk_buff
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  */
+ static void nbss_get_no_receive(packet_t *hdr, session_t *session)
+ {
+ 	session_hold(session);
+ 	session->o_receive_continue = 1;
+ 	if (!session->o_nonblock)
+ 		nbss_handle_event(NETBEUI_SESS_PAUSE, session);
+ 	else
+ 		nbss_handle_event(NETBEUI_SESS_NONBLOCK, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_receive_outstanding
+  *	Accepts a RECEIVE OUTSTANDING frame and generates a proper event.
+  *
+  * Parameters:
+  *	hdr	: pointer to packet_t which is frame header in sk_buff
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  */
+ static void nbss_get_receive_outstanding(packet_t *hdr, session_t *session)
+ {
+ 	session_hold(session);
+ 	if (session->version == NETBEUI_VERSION_1xx)
+ 		hdr->data2 = 0;
+ 	session->o_receive_outstanding	= 1;
+ 	session->r_acked		= hdr->data2;
+ 	nbss_handle_event(NETBEUI_SESS_RESTART, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_get_session_end
+  *	Accepts a SESSION END frame and generates a proper event.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  */
+ static void nbss_get_session_end(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->zapped = 1;
+ 	del_timer(&session->timer);
+ 	nbss_abort_receive(session);
+ 	nbss_handle_event(NETBEUI_SESS_ABORT_SEND, session);
+ 	nbss_handle_event(NETBEUI_SESS_END, session);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_switch_frame
+  *	This is the I-frame dispatcher.
+  *
+  * Parameters:
+  *	skb	: pointer to sk_buff which holds the frame
+  *	session : pointer to session_t structure the frame is received from
+  *
+  * Returns: none
+  */
+ static void nbss_switch_frame(session_t *session, struct sk_buff *skb)
+ {
+ 	packet_t *hdr;
+ 
+ 	session_hold(session);
+ 	hdr = (packet_t *)skb->data;
+ 	switch (hdr->command) {
+ 		case NETBEUI_DATA_FIRST_MIDDLE:
+ 		case NETBEUI_DATA_ONLY_LAST:
+ 			nbss_get_session_data(skb, session);
+ 			goto out;
+ 		case NETBEUI_DATA_ACK:
+ 			nbss_get_data_ack(hdr, session);
+ 			break;
+ 		case NETBEUI_RECEIVE_CONTINUE:
+ 			nbss_get_receive_continue(hdr, session);
+ 			break;
+ 		case NETBEUI_NO_RECEIVE:
+ 			nbss_get_no_receive(hdr, session);
+ 			break;
+ 		case NETBEUI_RECEIVE_OUTSTANDING:
+ 			nbss_get_receive_outstanding(hdr, session);
+ 			break;
+ 		case NETBEUI_SESSION_INITIALIZE:
+ 			nbss_get_session_initialize(skb, session);
+ 			goto out;  /* SKB is reused */
+ 		case NETBEUI_SESSION_CONFIRM:
+ 			nbss_get_session_confirm(hdr, session);
+ 			break;
+ 		case NETBEUI_SESSION_END:
+ 			nbss_get_session_end(session);
+ 			break;
+ 	}
+ 	kfree_skb(skb);
+ out:	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_deliver_frame
+  *	Accepts an I-Frame frame and depending on session locking state
+  *	either queues the frame for later processing (when session unlocked)
+  *	or calls frame dispatcher for direct processing.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure the frame is received from
+  *	skb	: pointer to sk_buff which holds the frame
+  *
+  * Returns: none
+  */
+ void nbss_deliver_frame(session_t *session, struct sk_buff *skb)
+ {
+ 	session_hold(session);
+ 	if (session->users)
+ 		__skb_queue_tail(&session->back_log, skb);
+ 	else
+ 		nbss_switch_frame(session, skb);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_drop_session
+  *	Drops a specified session on a specified link.
+  *
+  * Parameters:
+  *	link_no    : an integer that indicates the link number.
+  *	session_no : an integer that indicates the session number.
+  *
+  * Returns: int
+  *	zero     : if the session dropped successfully.
+  *	negative : if operation fails.
+  *	           -EINVAL : at least one of the arguments is invalid.
+  */
+ int nbss_drop_session(int link_no, int session_no)
+ {
+ 	session_t *sn;
+ 	link_t *nb_link = nbll_get_link(link_no);
+ 	dextab_t *sn_tbl;
+ 	int rc = -EINVAL;
+ 
+ 	if (!nb_link) /* Invalid link number */
+ 		goto out;
+ 	sn_tbl = &nb_link->session_table;
+ 	spin_lock_bh(&sn_tbl->lock);
+ 	rc = -EINVAL;
+ 	if (session_no > sn_tbl->size) { /* Invalid session number */
+ 		spin_unlock_bh(&sn_tbl->lock);
+ 		goto out;
+ 	}
+ 	sn = sn_tbl->addr[session_no];
+ 	spin_unlock_bh(&sn_tbl->lock);
+ 	if (!sn) /* no such session */
+ 		goto out;
+ 	session_hold(sn);
+ 	/* Announce the link manager */
+ 	nbll_detach_session(link_no, session_no);
+ 	/* Announce the session state machine */
+ 	nbss_abort_session(sn);
+ 	session_put(sn);
+ out:	nbll_link_put(nb_link);
+ 	return rc;
+ }
+ 
+ /*
+  * Session service state machine functions
+  * Implementing locking mechanism
+  */
+ /*
+  * Function: nbss_lock_session
+  *	Locks a session while processing a critical region.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure which is to be locked
+  *
+  * Returns: none
+  *
+  * Notes:
+  *	- Locking is a low cost mechanism for avoiding races when a
+  *	  critical region appears in code.
+  */
+ static void nbss_lock_session(session_t *session)
+ {
+ 	session_hold(session);
+ 	session->users++;
+ 	barrier();
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_process_backlog
+  *	Processes frames entered on a session while the session was locked
+  *	it simply calls dispatcher for every queued frame.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure who may have some frames in its
+  *		  backlog.
+  *
+  * Returns: none
+  */
+ static void nbss_process_backlog(session_t *session)
+ {
+ 	struct sk_buff *skb;
+ 	
+ 	session_hold(session);
+ 	while ((skb = __skb_dequeue(&session->back_log)) != NULL)
+ 		nbss_switch_frame(session, skb);
+ 	session_put(session);
+ }
+ 
+ /*
+  * Function: nbss_release_session
+  *	Unlocks a previously locked session.
+  *
+  * Parameters:
+  *	session : pointer to session_t structure which is to be unlocked
+  *
+  * Returns:
+  *	0	     : if session is successfully unlocked.
+  *	-ECONNABORTED: if session is aborted
+  *
+  * Notes:
+  *	- The return value is important to nbss_sleep_on() who decides whether
+  *	  to re-schedule system or continue execution of current process.
+  */
+ static int nbss_release_session(session_t *session)
+ {
+ 	int rc = 0;
+ 
+ 	session_hold(session);
+ 	barrier();
+ 	if (!session->users)
+ 		goto out;
+ 	if (!--session->users)
+ 		nbss_process_backlog(session);
+ 	if (session->zapped)
+ 		rc = session->status = -ECONNABORTED;
+ out:	session_put(session);
+ 	return rc;
+ }
Index: kernel-acme/net/netbeui/sock_dgram.c
diff -c /dev/null kernel-acme/net/netbeui/sock_dgram.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/sock_dgram.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,458 ----
+ /*
+  * sock_dgram.c - Contains functions that supply SOCK_DGRAM type sockets for
+  *                NetBEUI protocol stack which their names has a 'nbso_dgram_'
+  *                prefix.
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/config.h>
+ #include <linux/module.h>
+ #include <linux/net.h>
+ #include <linux/sched.h>
+ #include <linux/wait.h>
+ #include <linux/fs.h>
+ #include <linux/slab.h>
+ #include <linux/string.h>
+ #include <linux/kernel.h>
+ #include <linux/types.h>
+ #include <linux/timer.h>
+ #include <linux/uio.h>
+ #include <linux/skbuff.h>
+ #include <linux/poll.h>
+ #include <net/sock.h>
+ #include <asm/uaccess.h>
+ #include <linux/netbeui.h>
+ 
+ /* SOCK_DGRAM Calls */
+ /*
+  * Function: nbso_dgram_release
+  *	Performs additional actions at release of SOCK_DGRAM sockets.
+  *
+  * Parameters:
+  *	sock : pointer to socket that must be released.
+  *
+  * Returns: int
+  *	0 : in all cases. (this function always succeed)
+  */
+ static int nbso_dgram_release(struct socket *sock)
+ {
+ 	struct sock *sk = sock->sk;
+ 
+ 	if (sk) {
+                 sock_orphan(sk);
+                 sock_hold(sk);
+                 lock_sock(sk);
+ 		if (NB_SK(sk)->u.dg.namep) {
+ 			nbdg_del_name(NB_SK(sk)->u.dg.namep);
+ 			if (NB_SK(sk)->name)
+ 				nbns_del_name(NB_SK(sk)->name);
+ 		}
+                 release_sock(sk);
+                 sock_put(sk);
+ 	}
+ 	MOD_DEC_USE_COUNT;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbso_dgram_bind
+  *	Performs additional actions at bind of SOCK_DGRAM sockets to names.
+  *
+  * Parameters:
+  *	sock     : pointer to socket that must bind a name to it.
+  *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+  *	           information about sightly name.
+  *	addr_len : length of 'struct sockaddr_netbeui'.
+  *
+  * Returns: int
+  *	0        : if name is binded to socket successfully.
+  *	negative : if a fault occurs.
+  *	           -EINVAL : if socket binds already, or given name is not
+  *	                     valid.
+  */
+ static int nbso_dgram_bind(struct socket *sock, struct sockaddr *uaddr,
+ 			   int addr_len)
+ {
+ 	name_t *nb_name;
+ 	struct sock *sk = sock->sk;
+ 	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+ 	int rc = -EPERM;
+ 
+ 	if (!capable(CAP_NET_BIND_SERVICE))
+ 		goto out;
+ 	rc = -EINVAL;
+ 	if (NB_SK(sk)->u.dg.namep || addr->snb_addr.name[0] == '*')
+ 		goto out;
+ 	rc = nbns_add_name(addr->snb_addr.name, addr->snb_addr.name_type,
+ 			   &nb_name);
+ 	if (rc)
+ 		goto out;
+ 	rc = nbdg_add_name(addr->snb_addr.name, sk->sleep,
+ 			   &NB_SK(sk)->u.dg.namep);
+ 	if (rc)
+ 		nbns_del_name(nb_name);
+ 	else
+ 		NB_SK(sk)->name = nb_name;
+ 	nbns_name_put(nb_name);
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: nbso_dgram_connect
+  *	Performs additional actions at attach of SOCK_DGRAM sockets to a
+  *	specified peer.
+  *
+  * Parameters:
+  *	sock     : pointer to socket that must attach to peer.
+  *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+  *	           information about peer.
+  *	addr_len : length of 'struct sockaddr_netbeui'.
+  *	sflags   : bitwise integer that contains socket flags.
+  *
+  * Returns: int
+  *	0        : if socket attaches to the specified peer successfully.
+  *	negative : if a fault occurs.
+  *	           -EINVAL : means socket not bounded normally.
+  *	           -EACCES : permission denied for broadcasting. user must
+  *	                     sets the SO_BROADCAST socket option to active,
+  *	                     before try to connect to all ('*').
+  */
+ static int nbso_dgram_connect(struct socket *sock, struct sockaddr *uaddr,
+ 			      int addr_len, int sflags)
+ {
+ 	struct sock *sk = sock->sk;
+ 	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+ 	int rc = -EINVAL;
+ 
+ 	lock_sock(sk);
+ 	if (!NB_SK(sk)->name)
+ 		goto out;
+ 
+ 	if (uaddr && addr_len == sizeof(*addr)) {
+ 		rc = -EACCES;
+ 		if (addr->snb_addr.name[0] == '*' && !sk->broadcast)
+ 			goto out;
+ 		sock->state = SS_CONNECTING;
+ 		memcpy(&NB_SK(sk)->u.dg.conn_name, addr, sizeof(*addr));
+ 		nbdg_register_peername(NB_SK(sk)->u.dg.namep,
+ 				       NB_SK(sk)->u.dg.conn_name.snb_addr.name);
+ 		sock->state = SS_CONNECTED;
+ 	} else { /* Invalid address means detach from previous address */
+ 		if (sock->state == SS_UNCONNECTED)
+ 			goto out_ok;
+ 		sock->state = SS_DISCONNECTING;
+ 		nbdg_deregister_peername(NB_SK(sk)->u.dg.namep);
+ 		sock->state = SS_UNCONNECTED;
+ 	}
+ out_ok:	rc = 0;
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_dgram_getname
+  *	Gets SOCK_DGRAM socket name or peer name that attached to it.
+  *
+  * Parameters:
+  *	sock      : pointer to socket that we need to name of it or its peer.
+  *	uaddr     : (VRP) pointer to 'struct sockaddr_netbeui' that be filled
+  *	            with requested information.
+  *	uaddr_len : (VRP) pointer to an integer that returns length of
+  *	            'struct sockaddr_netbeui'.
+  *	peer      : an integer that indicates type of request.
+  *
+  * Returns: int
+  *	0        : if requested name is retrieved successfully.
+  *	negative : if a fault occurs.
+  *	           -ENOTCONN : name of peer was requested but socket has not
+  *	                       any attachment.
+  *	           -EBADF    : socket not bounded to a name but name of it
+  *	                       was requested.
+  */
+ static int nbso_dgram_getname(struct socket *sock, struct sockaddr *uaddr,
+ 			      int *uaddr_len, int peer)
+ {
+ 	struct sock *sk = sock->sk;
+ 	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+ 	int rc;
+ 
+ 	*uaddr_len = sizeof(*addr);
+ 	lock_sock(sk);
+ 	if (peer) {
+ 		rc = -ENOTCONN;
+ 		if (sock->state != SS_CONNECTED)
+ 			goto out;
+ 		memcpy(addr, &NB_SK(sk)->u.dg.conn_name, sizeof(*addr));
+ 	} else {
+ 		rc = -EBADF;
+ 		if (!NB_SK(sk)->u.dg.namep)
+ 			goto out;
+ 		memcpy(addr->snb_addr.name, NB_SK(sk)->u.dg.namep->name,
+ 		       NETBEUI_NAME_LEN);
+ 		addr->snb_addr.name_type = NB_SK(sk)->name->type;
+ 	}
+ 	rc = 0;
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_dgram_poll
+  *	Determines operational (particularly I/O) condition of SOCK_STREAM
+  *	socket.
+  *
+  * Parameters:
+  *	sock     : pointer to socket that check it.
+  *	sel_type : an integer that determines type of checking.
+  *	wait     : pointer to a particular structure that contains some
+  *	           wait queues. The system itself checks members of these
+  *	           wait queues for their time outs. we only sleep on this
+  *	           structure if there is not exist a categoric answer, so far.
+  *
+  * Returns: int
+  *	0 : means that however must wait.
+  *	1 : means that answer is positive or an error occurred.
+  */
+ static unsigned int nbso_dgram_poll(struct file *file, struct socket *sock,
+ 				    poll_table *wait)
+ {
+ 	struct sock *sk = sock->sk;
+ 	unsigned int mask = POLLWRNORM;
+ 
+ 	poll_wait(file, sk->sleep, wait);
+ 
+ 	if (sk->err)
+ 		mask |= POLLERR;
+ 	if (!NB_SK(sk)->u.dg.namep)
+ 		mask |= POLLERR;
+ 	else
+ 		if (!nbdg_receive_ready(NB_SK(sk)->u.dg.namep))
+ 			mask |= POLLIN | POLLRDNORM;
+ 	return mask;
+ }
+ 
+ /*
+  * Function: nbso_dgram_ioctl
+  *	Performs some particular operations on SOCK_DGRAM socket, that can not
+  *	do with regular system calls.
+  *
+  * Parameters:
+  *	sock : pointer to socket that action must perform on it.
+  *	cmd  : an integer that indicates type of operation.
+  *	arg  : this parameter often is a pointer to 'cmd' relative data
+  *	       structure that be used by it as an argument.
+  *
+  * Returns: int
+  *	0        : if cmd is performed successfully.
+  *	negative : if a fault occurs. error codes that bubble to user are
+  *	           dependent to cmd.
+  */
+ static int nbso_dgram_ioctl(struct socket *sock, unsigned int cmd,
+ 			    unsigned long arg)
+ {
+ 	struct sock *sk = sock->sk;
+ 	int rc = -EINVAL;
+ 
+ 	lock_sock(sk);
+ 	if (cmd == SIOCRUWDGF) {
+ 		int len;
+ 
+ 		if (!NB_SK(sk)->u.dg.namep)
+ 			goto out;
+ 		rc = -EFAULT;
+ 		if (get_user(len, (int *)arg))
+ 			goto out;
+ 		rc = -EINVAL;
+ 		if (len < 0)
+ 			goto out;
+ 		rc = nbdg_remove_unwanted_dgf(NB_SK(sk)->u.dg.namep, len);
+ 	}
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_dgram_sendmsg
+  *	Sends a DATAGRAM message through a SOCK_DGRAM socket to desired
+  *	target(s).
+  *
+  * Parameters:
+  *	sock     : a pointer to socket that data sends through it.
+  *	msg      : a pointer to 'struct msghdr' that contains message body,
+  *	           target name and etc.
+  *	           Note: msg->msg_control AND msg->msg_controllen are per
+  *	                 protocol magic fields, and in our sendmsg() they
+  *	                 indicate alias name to use for message sender name
+  *	                 instead of the name that socket binds to it.
+  *	len      : length of message all around.
+  *	nonblock : an integer that if be set to non-zero value means that
+  *	           no waiting (sleeping, blocking & ...) acceptable during
+  *	           operation.
+  *	sflags   : bitwise integer that contains socket flags.
+  *
+  * Returns: int
+  *	positive : indicates how many bytes of data was sent.
+  *	negative : if a fault occurs.
+  *	           -EINVAL   : if a flag specified (we do not support any
+  *	                       flags), or socket not bounded normally, or
+  *	                       given target name is not valid.
+  *	           -EACCES   : permission denied for broadcasting. user must
+  *	                       sets the SO_BROADCAST socket option to active,
+  *	                       before try to broadcasts a message.
+  *	           -ENOTCONN : target name not given and socket is not
+  *	                       attached to any peer.
+  */
+ static int nbso_dgram_sendmsg(struct socket *sock, struct msghdr *msg, int len,
+ 			      struct scm_cookie *scm)
+ {
+ 	char *local_name, name_buff[NETBEUI_NAME_LEN];
+ 	struct sock *sk = sock->sk;
+ 	int rc, noblock = msg->msg_flags & MSG_DONTWAIT;
+ 	struct sockaddr_netbeui *remote_addr;
+ 
+ 	lock_sock(sk);
+ 	if (msg->msg_name) {
+ 		struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)
+ 								msg->msg_name;
+ 		rc = -EINVAL;
+ 		if (!NB_SK(sk)->name || msg->msg_namelen < sizeof(*addr) ||
+ 		    (addr->snb_family && addr->snb_family != AF_NETBEUI))
+ 			goto out;
+ 		rc = -EACCES;
+ 		if (addr->snb_addr.name[0] == '*' && !sk->broadcast)
+ 			goto out;
+ 		remote_addr = addr;
+ 	} else {
+ 		rc = -ENOTCONN;
+ 		if (sock->state != SS_CONNECTED)
+ 			goto out;
+ 		remote_addr = &NB_SK(sk)->u.dg.conn_name;
+ 	}
+ 	if (msg->msg_control && msg->msg_controllen == NETBEUI_NAME_LEN) {
+ 		rc = -EFAULT;
+ 		if (copy_from_user(name_buff, msg->msg_control,
+ 				   NETBEUI_NAME_LEN))
+ 			goto out;
+ 		local_name = name_buff;
+ 	} else
+ 		local_name = NB_SK(sk)->name->name;
+ 	/* All things are good, so start to send data ... */
+ 	rc = nbdg_send(sk, local_name, remote_addr->snb_addr.name,
+ 		       remote_addr->snb_addr.name_type, msg->msg_iov,
+ 		       len, noblock);
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_dgram_recvmsg
+  *	Receives a DATAGRAM message through a SOCK_DGRAM socket.
+  *
+  * Parameters:
+  *	sock     : a pointer to socket that data receives through it.
+  *	msg      : (VRP) a pointer to 'struct msghdr' that at return contains
+  *	           message body, source name and etc.
+  *	           Note: msg->msg_control AND msg->msg_controllen are per
+  *	                 protocol magic fields, and in our recvmsg() at return
+  *	                 they indicate target name of received message, that
+  *	                 for sockets which connect to all ('*') may be different
+  *	                 from the socket name.
+  *	size     : MAXimum length of message all around.
+  *	nonblock : an integer that if be set to non-zero value means that
+  *	           no waiting (sleeping, blocking & ...) acceptable during
+  *	           operation.
+  *	sflags   : bitwise integer that contains socket flags.
+  *	addr_len : (VRP) a pointer to an integer that if it is not NULL, at
+  *	           return will be filled with length of 'struct
+  *	           sockaddr_netbeui'.
+  *
+  * Returns: int
+  *	positive : indicates how many bytes of data was received.
+  *	negative : if a fault occurs.
+  *	           -EINVAL      : if a flag specified (we do not support any
+  *	                          flags), or socket not bounded to a name
+  *	                          normally.
+  */
+ static int nbso_dgram_recvmsg(struct socket *sock, struct msghdr *msg,
+ 			      int size, int flags, struct scm_cookie *scm)
+ {
+ 	int iov_no, bytes_received;
+ 	struct iovec *iov;
+ 	int   nonblock = msg->msg_flags & MSG_DONTWAIT;
+ 	char   *dest_name = NULL,
+ 	       *source_name = NULL;
+ 	struct sock *sk = sock->sk;
+ 	int rc = -EINVAL;
+ 
+ 	lock_sock(sk);
+ 	if (!NB_SK(sk)->u.dg.namep)
+ 		goto out;
+ 	if (msg->msg_name) {
+ 		struct sockaddr_netbeui *addr = msg->msg_name;
+ 
+ 		addr->snb_family = AF_NETBEUI;
+ 		addr->snb_addr.reserved = 0;
+ 		source_name = addr->snb_addr.name;
+ 	}
+ 	if (msg->msg_control && msg->msg_controllen == NETBEUI_NAME_LEN) {
+ 		rc = verify_area(VERIFY_WRITE, msg->msg_control,
+ 				 NETBEUI_NAME_LEN);
+ 		if (rc)
+ 			goto out;
+ 		dest_name = msg->msg_control;
+ 	}
+ 	bytes_received = 0;
+ 	iov = msg->msg_iov;
+ 	iov_no = msg->msg_iovlen;
+ 
+ 	/* All things are good, so start to receive data ... */
+ 	while (iov_no--) {
+ 		rc = verify_area(VERIFY_WRITE, iov->iov_base, iov->iov_len);
+ 		if (rc) {
+ 			rc = bytes_received ? : rc;
+ 			break;
+ 		}
+ 		rc = nbdg_receive(NB_SK(sk)->u.dg.namep, source_name, dest_name,
+ 		                  iov->iov_base, iov->iov_len, nonblock);
+ 		if (rc < 0) {
+ 			rc = bytes_received ? : rc;
+ 			break;
+ 		}
+ 		bytes_received += rc;
+ 		++iov;
+ 		rc = bytes_received;
+ 	}
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /* Dispatcher struct for SOCK_DGRAM calls */
+ struct proto_ops SOCKOPS_WRAPPED(nbso_dgram_proto_ops) = {
+ 	family:		PF_NETBEUI,
+ 	release:	nbso_dgram_release,
+ 	bind:		nbso_dgram_bind,
+ 	connect:	nbso_dgram_connect,
+ 	socketpair:	sock_no_socketpair,
+ 	accept:		sock_no_accept,
+ 	getname:	nbso_dgram_getname,
+ 	poll:		nbso_dgram_poll,
+ 	ioctl:		nbso_dgram_ioctl,
+ 	listen:		sock_no_listen,
+ 	shutdown:	sock_no_shutdown,
+ 	setsockopt:	sock_no_setsockopt,
+ 	getsockopt:	sock_no_getsockopt,
+ 	sendmsg:	nbso_dgram_sendmsg,
+ 	recvmsg:	nbso_dgram_recvmsg,
+ };
+ #include <linux/smp_lock.h>
+ SOCKOPS_WRAP(nbso_dgram_proto, PF_NETBEUI);
Index: kernel-acme/net/netbeui/sock_name.c
diff -c /dev/null kernel-acme/net/netbeui/sock_name.c:1.1.4.4
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/sock_name.c	Sat Aug 25 03:43:42 2001
***************
*** 0 ****
--- 1,156 ----
+ /*
+  * sock_name.c - Contains functions that implement first layer of socket
+  * 		 interface for socket type SOCK_NAME. SOCK_NAME is a new
+  * 		 socket type introduced in NetBEUI used as a interface for
+  * 		 manipulating NetBIOS names under kernel control.
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/config.h>
+ #include <linux/module.h>
+ #include <linux/net.h>
+ #include <linux/sched.h>
+ #include <linux/wait.h>
+ #include <linux/fs.h>
+ #include <linux/slab.h>
+ #include <linux/string.h>
+ #include <linux/kernel.h>
+ #include <linux/types.h>
+ #include <linux/timer.h>
+ #include <linux/uio.h>
+ #include <linux/skbuff.h>
+ #include <net/sock.h>
+ #include <linux/netbeui.h>
+ 
+ /*
+  * Socket interface layer
+  * SOCK_NAME interface routines
+  */
+ /*
+  * Function: nbso_name_release
+  *	Releases a SOCK_NAME by requesting Name Service to remove all names
+  *	the socket owns.
+  *
+  * Parameters:
+  *	sock : pointer to socket that must be released.
+  *
+  * Returns:
+  *	0 	: always returns zero
+  *
+  * Notes:
+  *	- The names a SOCK_NAME type socket owns are detected by their
+  *	  identifier which is socket memory address.
+  */
+ static int nbso_name_release(struct socket *sock)
+ {
+ 	struct sock *sk = sock->sk;
+ 	unsigned long id = (unsigned long)NB_SK(sk);
+ 
+ 	nbns_del_identifier(id);
+ 	MOD_DEC_USE_COUNT;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbso_name_bind
+  *	Manipulates (binds/unbinds) names to SOCK_NAME type socket.
+  *
+  * Parameters:
+  *	sock     : pointer to socket structure
+  *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+  *	           information about sightly name.
+  *	addr_len : length of 'struct sockaddr_netbeui'.
+  *
+  * Returns:
+  *	0	 : if name is bound to socket successfully.
+  *	other	 : errors reported by name service module.
+  *	
+  * Notes:
+  *	- NetBEUI extends SOCK_NAME bind system call by defining
+  *	 	bind+   for registering a name from socket
+  *		bind-	for deregistering or releasing a name from socket
+  *	  * bind- is recognized by setting name_type in sockaddr_netbeui to 255
+  *	  * bind+ is recognized by setting name_type in sockaddr_netbeui to
+  *	  	  other values
+  *
+  *	- The names a SOCK_NAME type socket owns are detected by their
+  *	  identifier which is socket memory address.
+  */
+ static int nbso_name_bind(struct socket *sock, struct sockaddr *uaddr,
+ 			  int addr_len)
+ {
+ 	struct sock *sk = sock->sk;
+ 	unsigned long id = (unsigned long)NB_SK(sk);
+ 	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+ 	name_t *nb_name;
+ 	int rc = -EPERM;
+ 
+ 	if (!capable(CAP_NET_BIND_SERVICE))
+ 		goto out;
+ 	nb_name = nbns_find_name(addr->snb_addr.name);
+ 	rc = 0;
+ 	if (addr->snb_addr.name_type == 0xFF) {   /* Remove name from socket */
+ 		if (nb_name) {
+ 		       if (nb_name->identifier == id)
+ 				nbns_del_name(nb_name);
+ 		       nbns_name_put(nb_name);
+ 		}
+ 		goto out;
+ 	}
+ 	/* Add name to socket */
+ 	if (nb_name) {
+ 		nbns_name_put(nb_name);
+ 		goto out;
+ 	}
+ 	rc = nbns_add_name(addr->snb_addr.name, addr->snb_addr.name_type,
+ 			   &nb_name);
+ 	if (!rc) {
+ 		nb_name->identifier = id;
+ 		nbns_name_put(nb_name);
+ 	}
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: nbso_name_ioctl
+  *
+  * Parameters:
+  *
+  * Returns:
+  *	
+  * Notes:
+  *	- is not supported in SOCK_NAME, pass it to the config functions
+  */
+ static int nbso_name_ioctl(struct socket *sock, unsigned int cmd,
+ 			   unsigned long arg)
+ {
+ 	return nbcs_ioctl(cmd, (void *)arg);
+ }
+ 
+ /* proto_ops definition for SOCK_NAME socket type */
+ struct proto_ops SOCKOPS_WRAPPED(nbso_name_proto_ops) = {
+ 	family:		PF_NETBEUI,
+ 	release:	nbso_name_release,
+ 	bind:		nbso_name_bind,
+ 	connect:	sock_no_connect,
+ 	socketpair:	sock_no_socketpair,
+ 	accept:		sock_no_accept,
+ 	getname:	sock_no_getname,
+ 	ioctl:		nbso_name_ioctl,
+ 	listen:		sock_no_listen,
+ 	shutdown:	sock_no_shutdown,
+ 	setsockopt:	sock_no_setsockopt,
+ 	getsockopt:	sock_no_getsockopt,
+ 	sendmsg:	sock_no_sendmsg,
+ 	recvmsg:	sock_no_recvmsg,
+ };
+ #include <linux/smp_lock.h>
+ SOCKOPS_WRAP(nbso_name_proto, PF_NETBEUI);
Index: kernel-acme/net/netbeui/sock_session.c
diff -c /dev/null kernel-acme/net/netbeui/sock_session.c:1.1.4.6
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/sock_session.c	Sun Aug 26 17:30:44 2001
***************
*** 0 ****
--- 1,909 ----
+ /*
+  * sock_session.c - Contains functions that supply SOCK_STREAM type sockets for
+  *                  NetBEUI protocol stack which their names has a
+  *                  'nbso_session_' prefix, and also some utility functions that
+  *                  their names only has a 'nbso_' prefix.
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <linux/config.h>
+ #include <linux/module.h>
+ #include <linux/net.h>
+ #include <linux/sched.h>
+ #include <linux/wait.h>
+ #include <linux/fs.h>
+ #include <linux/slab.h>
+ #include <linux/string.h>
+ #include <linux/kernel.h>
+ #include <linux/types.h>
+ #include <linux/timer.h>
+ #include <linux/uio.h>
+ #include <linux/poll.h>
+ #include <net/sock.h>
+ #include <asm/uaccess.h>
+ #include <linux/skbuff.h>
+ #include <linux/netbeui.h>
+ 
+ /* SOCK_STREAM internal functions */
+ /*
+  * Function: nbso_end_backlog
+  *	Closes sessions that their connection was established but not
+  *	accepted yet.
+  *
+  * Parameters:
+  *	sk : pointer to NetBEUI socket that must close its waited connections.
+  *
+  * Returns: none
+  */
+ static void nbso_end_backlog(struct sock *sk)
+ {
+ 	while (NB_SK(sk)->u.st.backlog) {
+ 		session_t *sn = NB_SK(sk)->u.st.backlog;
+ 
+ 		NB_SK(sk)->u.st.backlog = NB_SK(sk)->u.st.backlog->next;
+ 		nbss_hangup(sn);
+ 	}
+ }
+ 
+ /*
+  * Function: nbso_autobind
+  *	Automatically binds a NetBEUI socket to NAME_NUMBER_1 .
+  *
+  * Parameters:
+  *	sk : pointer to NetBEUI socket that must bind it to NAME_NUMBER_1 .
+  *
+  * Returns: int
+  *	0  : if NetBEUI socket binds to NAME_NUMBER_1 successfully.
+  *	-1 : if can not bind NetBEUI socket to NAME_NUMBER_1 .
+  */
+ static int nbso_autobind(struct sock *sk)
+ {
+ 	NB_SK(sk)->name = nbns_name_number_1();
+ 	return NB_SK(sk)->name ? 0 : -1;
+ }
+ 
+ /*
+  * Function: nbso_session_ready (Call back function)
+  *	Gets an established session from transport layer, and puts it
+  *	in its owner's queue for sessions which are waited for accept.
+  *
+  * Parameters:
+  *	sk      : a pointer to NetBEUI socket that is owner of established
+  *	          session.
+  *	session : a pointer to established session.
+  *
+  * Returns: none
+  */
+ static void nbso_session_ready(struct sock *sk, session_t *sn)
+ {
+ 	sock_hold(sk);
+ 	bh_lock_sock(sk);
+ 	if (NB_SK(sk)->u.st.backlog)
+ 		NB_SK(sk)->u.st.backlog->prev = sn;
+ 	sn->next = NB_SK(sk)->u.st.backlog;
+ 	sn->prev = NULL;
+ 	NB_SK(sk)->u.st.backlog = sn;
+ 	wake_up_interruptible(sk->sleep);
+ 	bh_unlock_sock(sk);
+ 	sock_put(sk);
+ }
+ /*
+  * Function: nbso_abort_interface_session (Call back function)
+  *	Transport layer announces that a session is not valid from now.
+  *	we must perform different actions depend on NetBEUI socket state:
+  *	i)   if socket state is NBSO_INIT, we are in a special case that causes
+  *	     when a 'nbss_call()' was interrupted. we must only announce
+  *	     process which wants to establish connection that its request was
+  *	     aborted.
+  *	ii)  if socket state is NBSO_RUNNING, we must announce all processes
+  *	     that wait for something on the socket.
+  *	iii) if socket state is NBSO_LISTENNING, we only must remove the
+  *	     session from backlog list.
+  *
+  * Parameters:
+  *	owner  : a pointer to NetBEUI socket that is owner of aborted session.
+  *	session: a pointer to aborted session.
+  *
+  * Returns: none
+  */
+ static void nbso_abort_interface_session(struct sock *sk, session_t *sn)
+ {
+ 	sock_hold(sk);
+ 	bh_lock_sock(sk);
+ 	if (sk->state == NBSO_INIT) {
+ 		sk->socket->state = SS_UNCONNECTED;
+ 		goto out;
+ 	}
+ 	if (sk->state == NBSO_RUNNING) {
+ 		sk->state = NBSO_INIT;
+ 		sk->socket->state = SS_UNCONNECTED;
+ 		wake_up_interruptible(sk->sleep);
+ 		goto out;
+ 	}
+ 	/* NOW, Certainly state is NBSO_LISTENING */
+ 	if (sn->next)
+ 		sn->next->prev = sn->prev;
+ 	if (sn->prev)
+ 		sn->prev->next = sn->next;
+ 	else
+ 		NB_SK(sk)->u.st.backlog = sn->next;
+ 	/* To countervail deletion of this session from backlog list */
+ 	nbss_listen_bh(NB_SK(sk)->name, sk->max_ack_backlog, sk,
+ 		       nbso_abort_interface_session, nbso_session_ready);
+ out:	netbeui_proc_del_session(sn);
+ 	bh_unlock_sock(sk);
+ 	sock_put(sk);
+ }
+ 
+ /* SOCK_STREAM Calls */
+ /*
+  * Function: nbso_session_release
+  *	Performs additional actions at release of SOCK_STREAM sockets.
+  *
+  * Parameters:
+  *	sock : pointer to socket that must be released.
+  *
+  * Returns: int
+  *	0 : in all cases. (this function always succeed)
+  */
+ static int nbso_session_release(struct socket *sock)
+ {
+ 	struct sock *sk = sock->sk;
+ 
+ 	if (!sk)
+ 		goto out;
+ 	sock_orphan(sk);
+ 	sock_hold(sk);
+ 	lock_sock(sk);
+ 	sk->shutdown = SHUTDOWN_MASK;
+ 	if (sk->state == NBSO_LISTENING) {
+ 		__nbss_end_listen(NB_SK(sk)->name);
+ 		nbso_end_backlog(sk);
+ 	}
+ 	if (NB_SK(sk)->u.st.session)
+ 		nbss_hangup(NB_SK(sk)->u.st.session);
+ 	if (NB_SK(sk)->name)
+ 		nbns_del_name(NB_SK(sk)->name);
+ 	release_sock(sk);
+ 	sock_put(sk);
+ 	MOD_DEC_USE_COUNT;
+ out:	return 0;
+ }
+ 
+ /*
+  * Function: nbso_session_bind
+  *	Performs additional actions at bind of SOCK_STREAM sockets to names.
+  *
+  * Parameters:
+  *	sock     : pointer to socket that must bind a name to it.
+  *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+  *	           information about sightly name.
+  *	addr_len : length of 'struct sockaddr_netbeui'.
+  *
+  * Returns: int
+  *	0        : if name is binded to socket successfully.
+  *	negative : if a fault occurs.
+  *	           -EINVAL : if socket binds already.
+  */
+ static int nbso_session_bind(struct socket *sock, struct sockaddr *uaddr,
+ 			     int addr_len)
+ {
+ 	name_t *nb_name;
+ 	struct sock *sk = sock->sk;
+ 	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+ 	int rc = -EPERM;
+ 
+ 	if (!capable(CAP_NET_BIND_SERVICE))
+ 		goto out;
+ 	rc = -EINVAL;
+ 	if (!NB_SK(sk)->name) {
+ 		rc = nbns_add_name(addr->snb_addr.name,
+ 				   addr->snb_addr.name_type, &nb_name);
+ 		if (!rc) {
+ 			NB_SK(sk)->name = nb_name;
+ 			nbns_name_put(nb_name);
+ 		}
+ 	}
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_connect
+  *	Performs additional actions at connect of SOCK_STREAM sockets to a
+  *	specified peer.
+  *
+  * Parameters:
+  *	sock     : pointer to socket that must connect to peer.
+  *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+  *	           information about peer.
+  *	addr_len : length of 'struct sockaddr_netbeui'.
+  *	flags    : bitwise integer that contains socket flags.
+  *
+  * Returns: int
+  *	0        : if socket connects to the specified peer successfully.
+  *	negative : if a fault occurs.
+  *	           -EISCONN    : socket connected already or listens for
+  *	                         incoming connection requests.
+  *	           -EAGAIN     : no name available for the socket now, try
+  *	                          again.
+  *	           -ECONNRESET : connection reset by peer.
+  */
+ static int nbso_session_connect(struct socket *sock, struct sockaddr *uaddr,
+ 				int addr_len, int flags)
+ {
+ 	int rc;
+ 	session_t *sn;
+ 	struct sock *sk = sock->sk;
+ 	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+ 
+ 	lock_sock(sk);
+ 	rc = -EISCONN;
+ 	if (sk->state != NBSO_INIT)
+ 		goto out;
+ 	if (!NB_SK(sk)->name) {
+ 		/* To force short circuiting by compiler */
+ 		rc = -EAGAIN;   /* return -EADDRNOTAVAIL; ?! */
+ 		if (nbso_autobind(sk))
+ 			goto out;
+ 	}
+ 	sock->state = SS_CONNECTING;
+ 	rc = nbss_call(NB_SK(sk)->name, addr->snb_addr.name, sk,
+ 		       nbso_abort_interface_session, &sn);
+ 	if (rc)
+ 		goto out;
+ 	rc = -ECONNRESET;
+ 	if (sock->state != SS_CONNECTING)
+ 		goto out;
+ 	sock->state = SS_CONNECTED;
+ 	sk->state = NBSO_RUNNING;
+ 	sk->sleep = &sn->waitq;
+ 	NB_SK(sk)->u.st.session = sn;
+ 	rc = 0;
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ static struct sock *nbso_session_accept_newsk(struct sock *sk,
+ 					      struct socket *newsock)
+ {
+ 	struct sock *nsk = sk_alloc(PF_NETBEUI, sk->allocation, 1);
+ 
+ 	if (!nsk)
+ 		goto out;
+ 	nsk->protinfo.af_netbeui = kmalloc(sizeof(*nsk->protinfo.af_netbeui),
+ 					   sk->allocation);
+ 	if (!nsk->protinfo.af_netbeui)
+ 		goto err_nbsk;
+ 	memset(nsk->protinfo.af_netbeui, 0, sizeof(*nsk->protinfo.af_netbeui));
+ 	nsk->protinfo.destruct_hook = nsk->protinfo.af_netbeui;
+ 	sock_init_data(newsock, nsk);
+ 	NB_SK(nsk)->u.st.session = NB_SK(sk)->u.st.backlog;
+ 	NB_SK(nsk)->u.st.session->owner = nsk;
+ 	newsock->state = SS_CONNECTED;
+ 	NB_SK(nsk)->name = NB_SK(sk)->name;
+ 	nbns_name_hold(NB_SK(sk)->name);
+ 	nsk->state = NBSO_RUNNING;
+ 	nsk->sleep = &NB_SK(nsk)->u.st.session->waitq;
+ 	NB_SK(sk)->u.st.backlog = NB_SK(sk)->u.st.backlog->next;
+ 
+ 	if (NB_SK(sk)->u.st.backlog)
+ 		NB_SK(sk)->u.st.backlog->prev = NULL;
+ 	nbss_listen(NB_SK(sk)->name, sk->max_ack_backlog, sk,
+ 		    nbso_abort_interface_session, nbso_session_ready);
+ 	netbeui_proc_add_session(NB_SK(nsk)->u.st.session);
+ out:	return nsk;
+ err_nbsk:
+ 	sk_free(nsk);
+ 	nsk = NULL;
+ 	goto out;
+ }
+ 
+ /*
+  *	Wait for an incoming connection, avoid race
+  *	conditions. This must be called with the socket locked.
+  */
+ static int nbso_session_wait_for_connect(struct sock *sk)
+ {
+ 	DECLARE_WAITQUEUE(wait, current);
+ 	int rc, timeout = netbios_config.inactivity_timeout * HZ;
+ 
+ 	add_wait_queue_exclusive(sk->sleep, &wait);
+ 	for (;;) {
+ 		__set_current_state(TASK_INTERRUPTIBLE);
+ 		if (!NB_SK(sk)->u.st.backlog) {
+ 			release_sock(sk);
+ 			timeout = schedule_timeout(timeout);
+ 			lock_sock(sk);
+ 		}
+ 		rc = 0;
+ 		if (NB_SK(sk)->u.st.backlog)
+ 			break;
+ 		rc = -EINVAL;
+ 		if (sk->state != NBSO_LISTENING)
+ 			break;
+ 		rc = -ERESTARTSYS;
+ 		if (signal_pending(current))
+ 			break;
+ 		rc = -EAGAIN;
+ 		if (!timeout)
+ 			break;
+ 	}
+ 	__set_current_state(TASK_RUNNING);
+ 	remove_wait_queue(sk->sleep, &wait);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_accept
+  *	Performs additional actions at accept of incoming connection requests
+  *	for a SOCK_STREAM socket.
+  *
+  * Parameters:
+  *	sock    : pointer to socket that wants to accept the incoming
+  *	          connection requests.
+  *	newsock : (Semi VRP!) pointer to a new socket with attributes like
+  *	          original that connection between it & peer will be
+  *	          established. This 'struct socket' created by system before
+  *	          call us, and we only must complete its fields.
+  *	flags   : bitwise integer that contains socket flags.
+  *
+  * Returns: int
+  *	0        : if connection is successfully established between newsock
+  *	           and peer.
+  *	negative : if a fault occurs.
+  *	           -EINVAL      : this operation permitted only after a
+  *	                          successful call of listen().
+  *	           -EAGAIN      : user requests non-blocking operation, but
+  *	                          operation would block.
+  *	           -ERESTARTSYS : interrupted system call.
+  */
+ static int nbso_session_accept(struct socket *sock, struct socket *newsock,
+ 			       int flags)
+ {
+ 	struct sock *sk = sock->sk, *nsk;
+ 	int rc = -EINVAL;
+ 
+ 	lock_sock(sk);
+ 	if (sk->state != NBSO_LISTENING)
+ 		goto out;
+ 	newsock->state = SS_CONNECTING;
+ 
+ 	if (!NB_SK(sk)->u.st.backlog) {
+ 		rc = -EAGAIN;
+ 		if (flags & O_NONBLOCK)
+ 			goto err;
+ 		rc = nbso_session_wait_for_connect(sk);
+ 		if (rc)
+ 			goto err;
+ 	}
+ 	nsk = nbso_session_accept_newsk(sk, newsock);
+ 	rc = -ENOBUFS;
+         if (!nsk)
+ 		goto out;
+ 	rc = nbss_listen(NB_SK(sk)->name, sk->max_ack_backlog, sk,
+ 			 nbso_abort_interface_session, nbso_session_ready);
+ 	if (rc < 0)
+ 		goto err;
+ 	MOD_INC_USE_COUNT;
+ out:	release_sock(sk);
+ 	return rc;
+ err:	newsock->state = SS_UNCONNECTED;
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbso_session_getname
+  *	Gets SOCK_STREAM socket name or peer name that connected to it.
+  *
+  * Parameters:
+  *	sock      : pointer to socket that we need to name of it or its peer.
+  *	uaddr     : (VRP) pointer to 'struct sockaddr_netbeui' that be filled
+  *	            with requested information.
+  *	uaddr_len : (VRP) pointer to an integer that returns length of
+  *	            'struct sockaddr_netbeui'.
+  *	peer      : an integer that indicates type of request.
+  *
+  * Returns: int
+  *	0        : if requested name is retrieved successfully.
+  *	negative : if a fault occurs.
+  *	           -ENOTCONN : name of peer was requested but socket has not
+  *	                       any connection.
+  *	           -EBADF    : socket not bounded to a name but name of it
+  *	                       was requested.
+  */
+ static int nbso_session_getname(struct socket *sock, struct sockaddr *uaddr,
+ 				int *uaddr_len, int peer)
+ {
+ 	int rc;
+ 	struct sock *sk = sock->sk;
+ 	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+ 
+ 	lock_sock(sk);
+ 	if (peer) {
+ 		rc = -ENOTCONN;
+ 		if (sk->state != NBSO_RUNNING)
+ 			goto out;
+ 		memcpy(addr->snb_addr.name,
+ 		       NB_SK(sk)->u.st.session->remote_name, NETBEUI_NAME_LEN);
+ 		addr->snb_addr.name_type =
+ 				     NB_SK(sk)->u.st.session->remote_name_type;
+ 	} else {
+ 		rc = -EBADF;
+ 		if (!NB_SK(sk)->name)
+ 			goto out;
+ 		memcpy(addr->snb_addr.name, NB_SK(sk)->name->name,
+ 		       NETBEUI_NAME_LEN);
+ 		addr->snb_addr.name_type = NB_SK(sk)->name->type;
+ 	}
+ 	rc = 0;
+ 	*uaddr_len = sizeof(*addr);
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_poll
+  *	Determines operational (particularly I/O) condition of SOCK_STREAM
+  *	socket.
+  *
+  * Parameters:
+  *	sock     : pointer to socket that check it.
+  *	sel_type : an integer that determines type of checking.
+  *	wait     : pointer to a particular structure that contains some
+  *	           wait queues. The system itself checks members of these
+  *	           wait queues for their time outs. we only sleep on this
+  *	           structure if there is not exist a categoric answer, so far.
+  *
+  * Returns: int
+  *	0 : means that however must wait.
+  *	1 : means that answer is positive or an error occurred.
+  */
+ static unsigned int nbso_session_poll(struct file *file, struct socket *sock,
+ 				      poll_table *wait)
+ {
+ 	struct sock *sk = sock->sk;
+ 	unsigned int mask = 0;
+ 
+ 	poll_wait(file, sk->sleep, wait);
+ 	if (sk->err)
+ 		mask |= POLLERR;
+ 	if (sk->shutdown == SHUTDOWN_MASK || sk->state != NBSO_RUNNING)
+ 		mask |= POLLHUP;
+ 	if (sk->shutdown & RCV_SHUTDOWN)
+ 		mask |= POLLIN | POLLRDNORM;
+ 	/* Connected? */
+ 	if (sk->state == NBSO_RUNNING) {
+ 		if (nbss_receive_ready(NB_SK(sk)->u.st.session))
+ 			mask |= POLLIN | POLLRDNORM;
+ 		if (!(sk->shutdown & SEND_SHUTDOWN) &&
+ 	    	    nbss_send_ready(NB_SK(sk)->u.st.session))
+ 			mask |= POLLOUT | POLLWRNORM;
+ 	}
+ 	return mask;
+ }
+ 
+ /*
+  * Function: nbso_session_ioctl
+  *	Performs some particular operations on SOCK_STREAM socket, that can not
+  *	do with regular system calls.
+  *
+  * Parameters:
+  *	sock : pointer to socket that action must perform on it.
+  *	cmd  : an integer that indicates type of operation.
+  *	arg  : this parameter often is a pointer to 'cmd' relative data
+  *	       structure that be used by it as an argument.
+  *
+  * Returns: int
+  *	0        : if cmd is performed successfully.
+  *	negative : if a fault occurs. error codes that bubble to user are
+  *	           dependent to cmd.
+  */
+ static int nbso_session_ioctl(struct socket *sock, unsigned int cmd,
+ 			      unsigned long arg)
+ {
+ 	int rc = -EOPNOTSUPP;
+ 	struct sock *sk = sock->sk;
+ 	session_t *session;
+ 
+ 	lock_sock(sk);
+ 	session = NB_SK(sk)->u.st.session;
+ 	if (cmd == SIOCTRIMDATA) {
+ 		if (sk->state == NBSO_RUNNING)
+ 			rc = nbss_trim_data(session);
+ 	} else if (cmd == SIOCSENDZERO) {
+ 		if (sk->state == NBSO_RUNNING)
+ 			rc = nbss_send_zero(session, (char *)arg);
+ 	} else
+ 		rc = -EINVAL;
+ 	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_listen
+  *	Listens for incoming connection requests, and places them in a queue
+  *	that MAXimum of its length is 'backlog'. this operation defined only
+  *	for SOCK_STREAM functions.
+  *
+  * Parameters:
+  *	sock    : pointer to socket that must listens for incoming requests.
+  *	backlog : an integer that indicates length of queue which holds
+  *	          incoming requests that not accepted yet.
+  *
+  * Returns: int
+  *	0        : if operation is performed successfully.
+  *	negative : if a fault occurs.
+  *	           -EPERM : this operation not permitted on a connected socket.
+  */
+ static int nbso_session_listen(struct socket *sock, int backlog)
+ {
+ 	struct sock *sk = sock->sk;
+ 	int rc = -EPERM;
+ 
+ 	lock_sock(sk);
+ 	if (sk->state == NBSO_RUNNING)
+ 		goto out;
+ 	if (!(unsigned)backlog)	/* BSDism */
+ 		backlog = 1;
+ 	if ((unsigned)backlog > SOMAXCONN)
+ 		backlog = SOMAXCONN;
+ 	if (backlog > sk->max_ack_backlog)
+ 		nbss_listen(NB_SK(sk)->name, backlog, sk,
+ 		            nbso_abort_interface_session, nbso_session_ready);
+ 	sk->max_ack_backlog = backlog;
+ 	sk->state = NBSO_LISTENING;
+ 	rc = 0;
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_shutdown
+  *	Shuts down part of a full-duplex connection.
+  *
+  * Parameters:
+  *	sock : pointer to socket that part of its connection must be closed.
+  *	how  : an integer that indicates part of full_duplex connection that
+  *	       must be closed.
+  *
+  * Returns: int
+  *	0        : if operation is performed successfully.
+  *	negative : if a fault occurs.
+  *	           -ENOTCONN : the specified socket is not connected.
+  *	           -EINVAL   : the 'how' parameter has not a valid value.
+  */
+ static int nbso_session_shutdown(struct socket *sock, int how)
+ {
+ 	struct sock *sk = sock->sk;
+ 	int rc = -ENOTCONN;
+ 
+ 	lock_sock(sk);
+ 	if (!sk)
+ 		goto out;
+ 	/* To avoid short circuiting by compiler */
+ 	rc = -ENOTCONN;
+ 	if (sk->state != NBSO_RUNNING)
+ 		goto out;
+ 	how++; /*
+ 		* maps 0->1 has the advantage of making bit 1 rcvs and
+ 		*      1->2 bit 2 snds.
+ 		*      2->3
+ 		*/
+ 	rc = -EINVAL;
+ 	if ((how & ~SHUTDOWN_MASK) || !how) /* Is "1 <= how <= 3" ?! */
+ 		goto out;
+ 	sk->shutdown |= how;
+ 	rc = 0;
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_setsockopt
+  *	Sets some operational options of SOCK_STREAM sockets.
+  *
+  * Parameters:
+  *	sock    : a pointer to socket that must tune its options.
+  *	level   : this parameter is not used in this function and always is
+  *		  zero.
+  *	optname : an integer that indicates option that must tune.
+  *	optval  : a pointer to related data structure which used for assign
+  *	          value(s) to option.
+  *	optlen  : length of data structure that 'optval' points to it.
+  *
+  * Returns: int
+  *	0        : if tuning is performed successfully.
+  *	negative : if a fault occurs.
+  *	           -EOPNOTSUPP  : Operation not supported by us.
+  *	           -ENOPROTOOPT : Option name is not defined for us.
+  */
+ static int nbso_session_setsockopt(struct socket *sock, int level, int optname,
+ 				   char *optval, int optlen)
+ {
+ 	int rc = 0;
+ 	struct sock *sk = sock->sk;
+ 
+ 	lock_sock(sk);
+   	switch (optname) {
+ 		case SO_SNDBUF:
+ 		case SO_RCVBUF:
+ 		case SO_SNDLOWAT:
+ 		case SO_RCVLOWAT:
+ 			rc = -EOPNOTSUPP;
+ 			break;
+ 		case SO_SNDTIMEO:
+ 			if (copy_from_user((void *)&NB_SK(sk)->u.st.sto, optval,
+ 					   MIN(sizeof(NB_SK(sk)->u.st.sto),
+ 					       optlen)))
+ 				rc = -EFAULT;
+ 			break;
+ 		case SO_RCVTIMEO:
+ 			if (copy_from_user((void *)&NB_SK(sk)->u.st.rto, optval,
+ 					   MIN(sizeof(NB_SK(sk)->u.st.rto),
+ 						      optlen)))
+ 				rc = -EFAULT;
+ 			break;
+ 		default:
+ 			rc = -ENOPROTOOPT;
+ 			break;
+ 	}
+ 	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_getsockopt
+  *	Gets some operational options of SOCK_STREAM sockets.
+  *
+  * Parameters:
+  *	sock    : a pointer to socket that action performs on it.
+  *	level   : this parameter is not used in this function and always is
+  *		  zero.
+  *	optname : an integer that indicates option that must be gotten.
+  *	optval  : (VRP) a pointer to related data structure which used for
+  *	          getting value(s) of option.
+  *	optlen  : (VRP) length of data structure that 'optval' points to it.
+  *
+  * Returns: int
+  *	0        : if operation is performed successfully.
+  *	negative : if a fault occurs.
+  *	           -EOPNOTSUPP  : Operation not supported by us.
+  *	           -ENOPROTOOPT : Option name is not defined for us.
+  */
+ static int nbso_session_getsockopt(struct socket *sock, int level, int optname,
+ 				   char *optval, int *optlen)
+ {
+ 	int len, rc = 0;
+ 	struct sock *sk = sock->sk;
+ 
+ 	lock_sock(sk);
+   	switch (optname) {
+ 		case SO_SNDBUF:
+ 		case SO_RCVBUF:
+ 		case SO_SNDLOWAT:
+ 		case SO_RCVLOWAT:
+ 			rc = -EOPNOTSUPP;
+ 			break;
+ 		case SO_SNDTIMEO:
+ 			if (get_user(len, (int *)optlen)) {
+ 				rc = -EFAULT;
+ 				break;
+ 			}
+ 			len = MIN(len, sizeof(NB_SK(sk)->u.st.sto));
+ 			if (copy_to_user(optval,
+ 					 (void *)&NB_SK(sk)->u.st.sto, len) ||
+ 			    put_user(len, (int *)optlen))
+ 				rc = -EFAULT;
+ 			break;
+ 		case SO_RCVTIMEO:
+ 			if (get_user(len, (int *)optlen)) {
+ 				rc = -EFAULT;
+ 				break;
+ 			}
+ 			len = MIN(len, sizeof(NB_SK(sk)->u.st.rto));
+ 			if (copy_to_user(optval,
+ 					 (void *)&NB_SK(sk)->u.st.rto, len) ||
+ 			    put_user(len, (int *)optlen))
+ 				rc = -EFAULT;
+ 			break;
+ 		default:
+ 			rc = -ENOPROTOOPT;
+ 			break;
+   	}
+ 	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_sendmsg
+  *	Sends a message through a SOCK_STREAM socket to desired target.
+  *
+  * Parameters:
+  *	sock     : a pointer to socket that data sends through it.
+  *	msg      : a pointer to 'struct msghdr' that contains message body,
+  *	           target name and etc.
+  *	len      : length of message all around.
+  *	nonblock : an integer that if be set to non-zero value means that
+  *	           no waiting (sleeping, blocking & ...) acceptable during
+  *	           operation.
+  *	flags    : bitwise integer that contains socket flags.
+  *
+  * Returns: int
+  *	positive : indicates how many bytes of data was sent.
+  *	negative : if a fault occurs.
+  *	           -EINVAL      : we do not support any flags.
+  *	           -EPIPE       : 'send part' of full-duplex connection was
+  *	                          closed already.
+  *	           -ENOTCONN    : socket is not connected yet.
+  *	           -EMSGSIZE    : length of one of iovec buffers is greater
+  *	                          than NETBEUI_MAX_DATALEN.
+  *	           -EWOULDBLOCK : user requests non-blocking operation, but
+  *	                          operation would block.
+  */
+ static int nbso_session_sendmsg(struct socket *sock, struct msghdr *msg,
+ 				int len, struct scm_cookie *scm)
+ {
+ 	int rc, iov_no, bytes_sent;
+ 	int nonblock = msg->msg_flags & MSG_DONTWAIT;
+ 	struct iovec *iov;
+ 	struct timer_list snd_tmr;
+ 	struct sock *sk = sock->sk;
+ 
+ 	lock_sock(sk);
+ 	rc = -EPIPE;
+ 	if (sk->shutdown & SEND_SHUTDOWN) {
+ 		send_sig(SIGPIPE, current, 1);
+ 		goto out;
+ 	}
+ 	rc = -ENOTCONN;
+ 	if (sock->state != SS_CONNECTED || sk->state != NBSO_RUNNING)
+ 		goto out;
+ 	init_timer(&snd_tmr);
+ 	if (NB_SK(sk)->u.st.sto.tv_sec || NB_SK(sk)->u.st.sto.tv_usec) {
+ 		snd_tmr.expires = jiffies + NB_SK(sk)->u.st.sto.tv_sec * HZ +
+ 				  NB_SK(sk)->u.st.sto.tv_usec / (1000000 / HZ);
+ 		snd_tmr.data	 = (unsigned long)NB_SK(sk)->u.st.session;
+ 		snd_tmr.function = (void *)nbss_abort_send;
+ 		add_timer(&snd_tmr);
+ 	}
+ 	rc = bytes_sent = 0;
+ 	iov = msg->msg_iov;
+ 	iov_no = msg->msg_iovlen;
+ 	/* All things are good, so start to send data ... */
+ 	while (iov_no--) {
+ 		/* Currently, limit on size of data
+ 		   which can be sent is 64K-bytes */
+ 		if (iov->iov_len > NETBEUI_MAX_DATALEN) {
+ 			rc = bytes_sent ? : -EMSGSIZE;
+ 			break;
+ 		}
+ 		rc = nbss_send(NB_SK(sk)->u.st.session, iov->iov_base,
+ 			       iov->iov_len, nonblock, 0);
+ 		if (rc < 0) {
+ 			rc = bytes_sent ? : rc;
+ 			break;
+ 		}
+ 		bytes_sent += rc;
+ 
+ 		if (rc < iov->iov_len) {
+ 			rc = bytes_sent ? : -EWOULDBLOCK;
+ 			break;
+ 		}
+ 		++iov;
+ 		rc = bytes_sent;
+ 	}
+ 	del_timer(&snd_tmr);
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbso_session_recvmsg
+  *	Receives a message through a SOCK_STREAM socket from desired source.
+  *
+  * Parameters:
+  *	sock     : a pointer to socket that data receives through it.
+  *	msg      : (VRP) a pointer to 'struct msghdr' that at return contains
+  *	           message body, source name and etc.
+  *	size     : MAXimum length of message all around.
+  *	nonblock : an integer that if be set to non-zero value means that
+  *	           no waiting (sleeping, blocking & ...) acceptable during
+  *	           operation.
+  *	flags    : bitwise integer that contains socket flags.
+  *	addr_len : (VRP) a pointer to an integer that if it is not NULL, at
+  *	           return will be filled with length of struct sockaddr_netbeui.
+  *
+  * Returns: int
+  *	positive : indicates how many bytes of data was received.
+  *	negative : if a fault occurs.
+  *	           -EINVAL      : we do not support any flags.
+  *	           -EPIPE       : 'receive part' of full-duplex connection was
+  *	                          closed already.
+  *	           -ENOTCONN    : socket is not connected yet.
+  *	           -EWOULDBLOCK : user requests non-blocking operation, but
+  *	                          operation would block.
+  */
+ static int nbso_session_recvmsg(struct socket *sock, struct msghdr *msg,
+ 				int size, int flags, struct scm_cookie *scm)
+ {
+ 	int rc, iov_no, bytes_received;
+ 	int nonblock = msg->msg_flags & MSG_DONTWAIT;
+ 	struct iovec *iov;
+ 	struct timer_list rcv_tmr;
+ 	struct sock *sk = sock->sk;
+ 
+ 	lock_sock(sk);
+ 	rc = -EPIPE;
+ 	if (sk->shutdown & RCV_SHUTDOWN) {
+ 		send_sig(SIGPIPE, current, 1);
+ 		goto out;
+ 	}
+ 	if (sock->state != SS_CONNECTED || sk->state != NBSO_RUNNING) {
+ 		rc = -ENOTCONN;
+ 	 	if (!(NB_SK(sk)->u.st.session &&
+ 		      nbss_receive_ready(NB_SK(sk)->u.st.session)))
+ 			goto out;
+ 	}
+ 	init_timer(&rcv_tmr);
+ 	if (NB_SK(sk)->u.st.rto.tv_sec || NB_SK(sk)->u.st.rto.tv_usec) {
+ 		rcv_tmr.expires  = jiffies + NB_SK(sk)->u.st.rto.tv_sec * HZ +
+ 		                   NB_SK(sk)->u.st.rto.tv_usec / (1000000 / HZ);
+ 		rcv_tmr.data     = (unsigned long)NB_SK(sk)->u.st.session;
+ 		rcv_tmr.function = (void *)nbss_abort_receive;
+ 		add_timer(&rcv_tmr);
+ 	}
+ 	rc = bytes_received = 0;
+ 	iov = msg->msg_iov;
+ 	iov_no = msg->msg_iovlen;
+ 
+ 	while (iov_no--) {
+ 		rc = nbss_receive(NB_SK(sk)->u.st.session, iov->iov_base,
+ 				  iov->iov_len, nonblock);
+ 		if (rc < 0) {
+ 			rc = bytes_received ? : rc;
+ 			break;
+ 		}
+ 		bytes_received += rc;
+ 
+ 		if (rc < iov->iov_len) {
+ 			rc = bytes_received ? : -EWOULDBLOCK;
+ 			break;
+ 		}
+ 		++iov;
+ 		rc = bytes_received;
+ 	}
+ 	del_timer(&rcv_tmr);
+ out:	release_sock(sk);
+ 	return rc;
+ }
+ 
+ /* Dispatcher struct for SOCK_STREAM calls */
+ struct proto_ops SOCKOPS_WRAPPED(nbso_session_proto_ops) = {
+ 	family:		PF_NETBEUI,
+ 	release:	nbso_session_release,
+ 	bind:		nbso_session_bind,
+ 	connect:	nbso_session_connect,
+ 	socketpair:	sock_no_socketpair,
+ 	accept:		nbso_session_accept,
+ 	getname:	nbso_session_getname,
+ 	poll:		nbso_session_poll,
+ 	ioctl:		nbso_session_ioctl,
+ 	listen:		nbso_session_listen,
+ 	shutdown:	nbso_session_shutdown,
+ 	setsockopt:	nbso_session_setsockopt,
+ 	getsockopt:	nbso_session_getsockopt,
+ 	sendmsg:	nbso_session_sendmsg,
+ 	recvmsg:	nbso_session_recvmsg
+ };
+ #include <linux/smp_lock.h>
+ SOCKOPS_WRAP(nbso_session_proto, PF_NETBEUI);
Index: kernel-acme/net/netbeui/status_serve.c
diff -c /dev/null kernel-acme/net/netbeui/status_serve.c:1.1.4.5
*** /dev/null	Wed Sep  5 00:22:39 2001
--- kernel-acme/net/netbeui/status_serve.c	Thu Aug 30 01:59:25 2001
***************
*** 0 ****
--- 1,799 ----
+ /*
+  * status_serve.c - Contains functions that supply STATUS service for NetBEUI
+  *                  protocol stack, and also some utility functions.
+  * Notes:
+  *	- VRP in comments is the acronym of "Value Result Parameter"
+  *	- EHF in comments is the acronym of "Event Handling Function".
+  *
+  * Copyright (c) 1997 by Procom Technology, Inc.
+  * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  *
+  * This program can be redistributed or modified under the terms of the
+  * GNU General Public License as published by the Free Software Foundation.
+  * This program is distributed without any warranty or implied warranty
+  * of merchantability or fitness for a particular purpose.
+  *
+  * See the GNU General Public License for more details.
+  */
+ #include <asm/types.h>
+ #include <linux/sched.h>
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/if_arp.h>
+ #include <linux/errno.h>
+ #include <linux/timer.h>
+ #include <linux/skbuff.h>
+ #include <linux/netbeui.h>
+ #include <asm/uaccess.h>
+ 
+ static void nbst_timer_function(unsigned long input);
+ 
+ /* These functions are STATUS State Transition handlers */
+ static int nbst_status_query_in_initial(status_t *nb_status);
+ static int nbst_retry_timeout_in_all(status_t *nb_status);
+ static int nbst_response_timeout_in_all(status_t *nb_status);
+ static int nbst_status_response_in_respwait(status_t *nb_status);
+ static int nbst_incomp_response_in_respwait(status_t *nb_status);
+ 
+ #define NBST_LENGTH_MASK	0x3FFF
+ #define NBST_OVERFLOW_MASK	0x4000
+ #define NBST_FRAGMENT_MASK	0x8000
+ 
+ /* List of adapters bound to */
+ extern struct net_device *adapters[];
+ 
+ /* DataGram BroadCast Maximum Transfer Unit */
+ extern unsigned int dgbc_mtu;
+ 
+ static unsigned long jiffies_at_reset;
+ 
+ static unsigned short int nbst_correlator;
+ #define nbst_next_correlator()   (++nbst_correlator)
+ 
+ static status_t *status_request_list;
+ static rwlock_t status_request_list_lock = RW_LOCK_UNLOCKED;
+ 
+ typedef int (* status_event_handler_t)(status_t *);
+ 
+ struct event_struct {
+ 	status_state_t next_state;
+ 	status_event_handler_t event_handler;
+ };
+ 
+ static struct event_struct status_state_table[2][5] = {
+ 			/* NBS_STAT_INITIAL */
+ {
+ { NBS_STAT_RESPWAIT, nbst_status_query_in_initial }, /* NBE_STAT_STATUS_QUERY */
+ { -1, NULL },				/* NBE_STAT_RETRY_TIMEOUT    */
+ { -1, NULL },				/* NBE_STAT_RESPONSE_TIMEOUT */
+ { -1, NULL },				/* NBE_STAT_STATUS_RESPONSE  */
+ { -1, NULL }				/* NBE_STAT_INCOMP_RESPONSE  */
+ },
+      		/* NBS_STAT_RESPWAIT */
+ {
+ { -1, NULL },				/* NBE_STAT_STATUS_QUERY     */
+ { NBS_STAT_RESPWAIT, nbst_retry_timeout_in_all },  /* NBE_STAT_RETRY_TIMEOUT */
+ { NBS_STAT_INITIAL, nbst_response_timeout_in_all },/* NBE_STAT_RESPONSE_TIMEOUT */
+ { NBS_STAT_INITIAL, nbst_status_response_in_respwait }, /* NBE_STAT_STATUS_RESPONSE  */
+ { NBS_STAT_RESPWAIT, nbst_incomp_response_in_respwait } /* NBE_STAT_INCOMP_RESPONSE  */
+ }
+ };
+ 
+ static nb_status_buffer_t nb_status_record;
+ /*
+  * Internal NBST functions
+  */
+ /*
+  * Function: nbst_alloc_status
+  *	Allocates a 'nb_status' structure and initializes its fields.
+  *
+  * Parameters: none
+  *
+  * Returns: status_t *
+  *       non NULL : address of allocated nb_status.
+  *       NULL     : if can not allocate nb_status, or initialize its fields
+  *	           properly.
+  */
+ static status_t *nbst_alloc_status(void)
+ {
+ 	int status_dgram_len;
+ 	status_t *nb_status = kmalloc(sizeof(*nb_status), GFP_KERNEL);
+ 
+ 	if (!nb_status)
+ 		goto out;
+ 	/* Implicitly initialize all fields */
+ 	memset(nb_status, 0, sizeof(*nb_status));
+ 	/* Allocate status skb */
+ 	status_dgram_len = nb_command_header_len[NETBEUI_STATUS_QUERY];
+ 	nb_status->tx_skb = alloc_skb(CALC_DG_SKBLEN(NETBEUI_MAC_B_HEADLEN,
+ 				      status_dgram_len), GFP_KERNEL);
+ 	if (!nb_status->tx_skb)
+ 		goto err;
+ 	skb_reserve(nb_status->tx_skb, LLCMAC_UIB_HEADLEN());
+ 	nb_status->tx_skb->nh.raw = nb_status->tx_skb->h.raw =
+ 		nb_status->tx_skb->data;
+ 	skb_put(nb_status->tx_skb, status_dgram_len);
+ 	nb_status->tx_skb->dev = NULL;
+ 	init_timer(&nb_status->timer);
+ 	nb_status->timer.data = (unsigned long)nb_status;
+ 	nb_status->timer.function = nbst_timer_function;
+ 	init_waitqueue_head(&nb_status->waitq);
+ out:	return nb_status;
+ err:	kfree(nb_status);
+ 	nb_status = NULL;
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbst_free_status
+  *	Frees a nb_status structure and its sk_buff.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that must be freed.
+  *
+  * Returns: none
+  */
+ static inline void nbst_free_status(status_t *nb_status)
+ {
+ 	kfree_skb(nb_status->tx_skb);
+ 	kfree(nb_status);
+ }
+ 
+ /*
+  * Function: nbst_add_status_to_list
+  *	Adds a nb_status structure to the 'status_request_list'.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that must be added to the
+  *	            list.
+  *
+  * Returns: none
+  */
+ static inline void nbst_add_status_to_list(status_t *nb_status)
+ {
+ 	write_lock(&status_request_list_lock);
+ 	nb_status->next = status_request_list;
+ 	status_request_list = nb_status;
+ 	write_unlock(&status_request_list_lock);
+ }
+ 
+ /*
+  * Function: nbst_remove_status_from_list
+  *	Removes a nb_status structure from the 'status_request_list'.
+  *
+  * Parameters:
+  *       nb_status : pointer to nb_status structure that must be removed from
+  *	            the list.
+  *
+  * Returns: none
+  */
+ static void nbst_remove_status_from_list(status_t *nb_status)
+ {
+ 	status_t *entry, *prev_entry = NULL;
+ 
+ 	write_lock(&status_request_list_lock);
+ 	for (entry = status_request_list; entry; entry = entry->next) {
+ 		if (entry == nb_status) {
+ 			if (prev_entry)
+ 				prev_entry->next = entry->next;
+ 			else
+ 				status_request_list = entry->next;
+ 			break;
+ 		}
+ 		prev_entry = entry;
+ 	}
+ 	write_unlock(&status_request_list_lock);
+ }
+ 
+ /*
+  * Function: nbst_find_correlator
+  *	Finds a nb_status in the 'status_request_list' that have a specific
+  *	response correlator.
+  *
+  * Parameters:
+  *	correlator : the response correlator that we search for it.
+  *
+  * Returns: status_t *
+  *       non NULL : address of sightly nb_status in the list.
+  *       NULL     : if no match be found.
+  */
+ static status_t *nbst_find_correlator(__u16 correlator)
+ {
+ 	status_t *nb_status;
+ 
+ 	read_lock(&status_request_list_lock);
+ 	nb_status = status_request_list;
+ 	for (; nb_status; nb_status = nb_status->next)
+ 		if (nb_status->resp_correlator == correlator)
+ 			break;
+ 	read_unlock(&status_request_list_lock);
+ 	return nb_status;
+ }
+ 
+ /*
+  * Function: nbst_handle_event
+  *	Handles an entrant event to STATUS state machine.
+  *
+  * Parameters:
+  *	event     : the entrant event.
+  *	nb_status : (Semi VRP!) pointer to nb_status structure (entity) that
+  *	            event is for it.
+  *
+  * Returns: none
+  */
+ static void nbst_handle_event(status_event_t event, status_t *nb_status)
+ {
+ 	struct event_struct *ev = &status_state_table[nb_status->state][event];
+ 
+ 	if (ev && ev->event_handler)
+ 		if (!ev->event_handler(nb_status))
+ 			nb_status->state = ev->next_state;
+ }
+ 
+ /*
+  * Function: nbst_timer_function (Call back function)
+  *	Produces an appropriate event related to number of retries
+  *	so far, due to fire of a timer.
+  *
+  * Parameters:
+  *	input : pointer to nb_status structure that timer of it has been fired.
+  *
+  * Returns: none
+  */
+ static void nbst_timer_function(unsigned long input)
+ {
+ 	status_t *nb_status = (status_t *)input;
+ 
+ 	if (nb_status->retries < NETBEUI_TRANSMIT_COUNT)
+ 		nbst_handle_event(NBE_STAT_RETRY_TIMEOUT, nb_status);
+ 	else
+ 		nbst_handle_event(NBE_STAT_RESPONSE_TIMEOUT, nb_status);
+ }
+ 
+ /*
+  * Function: nbst_status_query_in_initial
+  *	(EHF) Handles NBE_STAT_STATUS_QUERY event in NBS_STAT_INITIAL state.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that event happens on it.
+  *
+  * Returns: int
+  *	zero     : if event be handled successfully.
+  *	non zero : if an error occurred during event handling.
+  */
+ static int nbst_status_query_in_initial(status_t *nb_status)
+ {
+ 	int rc;
+ 	dgram_t *hdrp;
+ 
+ 	/* Implicitly was set to zero in nbst_alloc_status() */
+ //	nb_status->retries = 0;
+ //	nb_status->len_rx_info = 0;
+ 	nb_status->resp_status = NO_RESPONSE;
+ 	hdrp = (dgram_t *)nb_status->tx_skb->data;
+ 	hdrp->length = nb_command_header_len[NETBEUI_STATUS_QUERY];
+ 	hdrp->delimiter = NETBEUI_DELIMITER;
+ 	hdrp->command = NETBEUI_STATUS_QUERY;
+ 	/* We implement NetBIOS 3.0 */
+ 	hdrp->data1 = 1;
+ 	hdrp->data2 = nb_status->sbuff_len;
+ 	hdrp->resp_correlator = nb_status->resp_correlator =
+ 		nbst_next_correlator();
+ 
+ 	rc = -EFAULT;
+ 	if (copy_from_user(hdrp->dest_name, nb_status->called_name,
+ 			   NETBEUI_NAME_LEN))
+ 		goto out;
+ 	memcpy(hdrp->source_name, (nbns_name_number_1())->name, NETBEUI_NAME_LEN);
+ 
+ 	/* BroadCast NETBEUI_STATUS_QUERY */
+ 	rc = nbll_uisend(NULL, nb_status->tx_skb);
+ 	if (!rc) {
+ 		nb_status->retries++;
+ 		nb_status->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+ 		add_timer(&nb_status->timer);
+ 		nbst_add_status_to_list(nb_status);
+ 	}
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: nbst_retry_timeout_in_all
+  *	(EHF) Handles NBE_STAT_RETRY_TIMEOUT event in all of states.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that event happens on it.
+  *
+  * Returns: int
+  *	zero     : if event be handled successfully.
+  *	non zero : if an error occurred during event handling.
+  */
+ static int nbst_retry_timeout_in_all(status_t *nb_status)
+ {
+ 	int rc = 0;
+ 
+ 	nb_status->timer.expires = jiffies+ NETBEUI_TRANSMIT_TIMEOUT;
+ 	add_timer(&nb_status->timer);
+ 	if (nb_status->unicast) {
+ 		/* UniCast NETBEUI_STATUS_QUERY */
+ 		rc = nbll_uisend(nb_status->remote_mac, nb_status->tx_skb);
+ 		if (rc)
+ 			goto out;
+ 		skb_pull(nb_status->tx_skb,
+ 			LLCMAC_UI_HEADLEN(MAC_HEADLEN(nb_status->tx_skb->dev)));
+ 	} else {
+ 		/* BroadCast NETBEUI_STATUS_QUERY */
+ 		rc = nbll_uisend(NULL, nb_status->tx_skb);
+ 		if (rc)
+ 			goto out;
+ 	}
+ 	nb_status->retries++;
+ out:	return rc;
+ }
+ 
+ /*
+  * Function: nbst_response_timeout_in_all
+  *	(EHF) Handles NBE_STAT_RESPONSE_TIMEOUT event in all of states.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that event happens on it.
+  *
+  * Returns: int
+  *	zero     : this function always succeed.
+  */
+ static int nbst_response_timeout_in_all(status_t *nb_status)
+ {
+ 	nbst_remove_status_from_list(nb_status);
+ 	wake_up(&nb_status->waitq);
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbst_status_response_in_respwait
+  *	(EHF) Handles NBE_STAT_STATUS_RESPONSE event in NBS_STAT_RESPWAIT state.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that event happens on it.
+  *
+  * Returns: int
+  *	zero     : this function always succeed.
+  */
+ static int nbst_status_response_in_respwait(status_t *nb_status)
+ {
+ 	del_timer(&nb_status->timer);
+ 	nbst_remove_status_from_list(nb_status);
+ 	if (nb_status->overflowed)
+ 		nb_status->resp_status = USER_BUFFER_OVERFLOW;
+ 	else
+ 		nb_status->resp_status = COMPLETED_RESPONSE;
+ 	return 0;
+ }
+ 
+ /*
+  * Function: nbst_incomp_response_in_respwait
+  *	(EHF) Handles NBE_STAT_INCOMP_RESPONSE event in NBS_STAT_RESPWAIT state.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that event happens on it.
+  *
+  * Returns: int
+  *	zero     : if event be handled successfully.
+  *	non zero : if an error occurred during event handling.
+  */
+ static int nbst_incomp_response_in_respwait(status_t *nb_status)
+ {
+ 	int rc;
+ 
+ 	del_timer(&nb_status->timer);
+ 	nb_status->unicast = 1;
+ 	nb_status->retries = 0;
+ 	nb_status->resp_status = INCOMPLETE_RESPONSE;
+ 	((dgram_t *)(nb_status->tx_skb->data))->data1 = nb_status->no_rx_names;
+ 	((dgram_t *)(nb_status->tx_skb->data))->data2 = nb_status->sbuff_len -
+ 	                                                nb_status->len_rx_info;
+ 	nb_status->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+ 	add_timer(&nb_status->timer);
+ 	rc = nbll_uisend(nb_status->remote_mac, nb_status->tx_skb);
+ 	if (!rc) {
+ 		skb_pull(nb_status->tx_skb,
+ 			LLCMAC_UI_HEADLEN(MAC_HEADLEN(nb_status->tx_skb->dev)));
+ 		nb_status->retries++;
+ 	}
+ 	return rc;
+ }
+ 
+ /*
+  * Function: nbst_gather_status_info
+  *	Gathers NetBIOS status information in local machine.
+  *
+  * Parameters:
+  *	dev : pointer to struct net_device that its related status information
+  *	      has been requested.
+  *
+  * Returns: int
+  *	positive : length of gathered status information. this function always
+  *	           succeed.
+  */
+ static int nbst_gather_status_info(struct net_device *dev)
+ {
+ 	int i;
+ 	__u8 tmp8;
+ 	__u16 non;
+ 	name_t *ntp;
+ 	unsigned long tmpl;
+ 
+ 	if (!dev)
+ 		dev = adapters[0];
+ 	if (dev) {
+ 		memcpy(nb_status_record.adptr_addr, dev->dev_addr, 6);
+ 		if (dev->type == ARPHRD_IEEE802)
+ 			nb_status_record.adptr_type_AND_sftwr_level.adptr_type =
+ 			       	TOKEN_RING;
+ 		else if (dev->type == ARPHRD_ETHER ||
+ 			 dev->type == ARPHRD_EETHER)
+ 			nb_status_record.adptr_type_AND_sftwr_level.adptr_type =
+ 				ETHERNET;
+ 	} else {
+ 		memset(nb_status_record.adptr_addr, 0, 6);
+ 		nb_status_record.adptr_type_AND_sftwr_level.adptr_type = 0;
+ 	}
+ 	/* We support new parameters , NetBIOS 3.0 */
+ 	nb_status_record.adptr_type_AND_sftwr_level.sftwr_level = 0x20;
+ 	nb_status_record.sftwr_release_no = 3; /* We implement NetBIOS 3.0 */
+ 	tmpl = (jiffies - jiffies_at_reset) / (HZ * 60);
+ 	nb_status_record.duration = tmpl > 0xFFFF ? 0xFFFF : tmpl;
+ 	nb_status_record.max_dgram_packet_size = dgbc_mtu;
+ 	nb_status_record.max_no_pend_sess = 0xFFFF; /* No limit! */
+ 	nb_status_record.max_size_sess_data_packet = dev ?
+ 			  (dev->mtu - LLCMAC_I_HEADLEN(dev) - NETBEUI_ILEN) : 0;
+ 	non = nbns_count_names();
+ 	nb_status_record.no_names_in_local_name_tbl = non;
+ 	ntp = nbns_get_name_list();
+ 	for (i = 0; i < non; i++, ntp = ntp->next) {
+ 		memcpy(nb_status_record.local_names[i].name, ntp->name,
+ 		       NETBEUI_NAME_LEN);
+ 		nb_status_record.local_names[i].name_number = ntp->name_number;
+ 
+ 		tmp8 = ntp->type == NETBEUI_NAME_GROUP ? 0x80 : 0x00;
+ 		switch (ntp->state) {
+ #if 0
+ 			/* commented out in original procom code */
+ 			case NETBEUI_NAME_ADDWAIT:  /* Try to register a name */
+ 				tmp8 |= 0x00;
+ 				break;
+ #endif
+ 			case NETBEUI_NAME_ACQUIRED: /* A registered name */
+ 				tmp8 |= 0x04;
+ 				break;
+ 			case NETBEUI_NAME_INITIAL:  /* A deregistered name */
+ 				tmp8 |= 0x05;
+ 			default: ;	/* Only for silence of the gcc! */
+ 		}
+ 		if (ntp->conflicted)           /* A detected duplicate name */
+ 			tmp8 |= 0x06;
+ 		nb_status_record.local_names[i].name_status = tmp8;
+ 	}
+ 	return NETBEUI_MIN_STATUS_BUFF_LEN + (NETBEUI_NAME_LEN + 2) * non;
+ }
+ 
+ /*
+  * Function: nbst_local_status
+  *	Retrieves local NetBIOS status information.
+  *
+  * Parameters:
+  *	status_buff : pointer to user buffer that must be filled with local
+  *	              status information.
+  *	buff_len    : (VRP) pointer to an integer that indicates length of
+  *	              user buffer at start and length of retrieved information
+  *	              at end.
+  *
+  * Returns: int
+  *	zero     : if information retrieved successfully.
+  *	negative : if something is bad.
+  *	           -EOVERFLOW : user buffer length is not large enough to
+  *	                        keep all of information, so some of it was
+  *	                        copied to user buffer.
+  */
+ static int nbst_local_status(char *status_buff, int *buff_len)
+ {
+ 	int len, info_len;
+ 
+ 	if (get_user(len, buff_len))
+ 		return -EFAULT;
+ 	info_len = nbst_gather_status_info(NULL);
+ 	len = MIN(len, info_len);
+ 	if (copy_to_user(status_buff, &nb_status_record, len) ||
+ 	    put_user(len, buff_len))
+ 		return -EFAULT;
+ 	return len < info_len ? -EOVERFLOW : 0;
+ }
+ 
+ /*
+  * Function: nbst_wait_for_resp
+  *	Waits for end of STATUS state machine operation, and supervise
+  *	received status response frames.
+  *
+  * Parameters:
+  *	nb_status : pointer to nb_status structure that operations perform
+  *	            on it.
+  *
+  * Returns: none
+  */
+ static void nbst_wait_for_resp(status_t *nb_status)
+ {
+ 	sleep_on(&nb_status->waitq);
+ 	nb_status->locked = 1;
+ 
+ 	while (nb_status->rx_skb) {
+ 		int sdl, tmp;
+ 		char *sdp;
+ 		dgram_t *hdrp = (dgram_t *)nb_status->rx_skb->data;
+ 
+ 		nb_status->overflowed = hdrp->data2 & NBST_OVERFLOW_MASK;
+ 		/* Pointer to the status data in the received frame */
+ 		sdp = skb_pull(nb_status->rx_skb, NETBEUI_UILEN);
+ 		sdl = hdrp->data2 & NBST_LENGTH_MASK;
+ 		tmp = nb_status->len_rx_info ?
+ 			sdl : (sdl - NETBEUI_MIN_STATUS_BUFF_LEN);
+ 		nb_status->no_rx_names += tmp / (NETBEUI_NAME_LEN + 2);
+ 		nb_status->len_rx_info += sdl;
+ 
+ 		if (nb_status->len_rx_info < nb_status->sbuff_len) {
+ 			/* FIXME(acme): check copy_to_user result! */
+ 			copy_to_user(nb_status->user_sbuff, (char *)sdp, sdl);
+ 
+ 			if ((hdrp->data2 & NBST_FRAGMENT_MASK) && hdrp->data1)
+ 				nbst_handle_event(NBE_STAT_INCOMP_RESPONSE,
+ 						  nb_status);
+ 			else
+ 				nbst_handle_event(NBE_STAT_STATUS_RESPONSE,
+ 						  nb_status);
+ 		}
+ 		else {
+ 			sdl -= nb_status->len_rx_info - nb_status->sbuff_len;
+ 			copy_to_user(nb_status->user_sbuff, sdp, sdl);
+ 
+ 			nbst_handle_event(NBE_STAT_STATUS_RESPONSE, nb_status);
+ 		}
+ 		nb_status->user_sbuff += sdl;
+ 		kfree_skb(nb_status->rx_skb);
+ 		nb_status->rx_skb = NULL;
+ 
+ 		if (nb_status->state == NBS_STAT_RESPWAIT) {
+ 			barrier();
+ 			nb_status->locked = 0;
+ 			sleep_on(&nb_status->waitq);
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Function: nbst_remote_status
+  *	Retrieves NetBIOS status information of a remote host.
+  *
+  * Parameters:
+  *	remote_name : pointer to a NetBIOS name that must retrieve status
+  *	              information about it.
+  *	status_buff : (VRP) pointer to user buffer that must be filled with
+  *	              status information of remote host.
+  *	buff_len    : (VRP) pointer to an integer that indicates length of
+  *	              user buffer at start and length of retrieved information
+  *	              at end.
+  *
+  * Returns: int
+  *	zero     : if information retrieved successfully.
+  *	negative : if something is bad.
+  *	           -ENONET       : no network device found.
+  *	           -ENOMEM       : out of memory condition.
+  *	           -EHOSTUNREACH : no response from remote host.
+  *	           -ETIMEDOUT    : system timed out before retrieving all of
+  *	                           information, so some of it was copied to
+  *	                           user buffer.
+  *	           -EOVERFLOW    : user buffer length is not large enough to
+  *	                           keep all of information, so some of it was
+  *	                           copied to user buffer.
+  */
+ static int nbst_remote_status(char *remote_name, char *status_buff,
+ 			      int *buff_len)
+ {
+ 	status_t *nb_status;
+ 	int rc = -ENONET;
+ 
+ 	if (!adapters[0])
+ 		goto out;
+ 	nb_status = nbst_alloc_status();
+ 	rc = -ENOMEM;
+ 	if (!nb_status)
+ 		goto out;
+ 	nb_status->called_name = remote_name;
+ 	nb_status->user_sbuff = status_buff;
+ 	rc = -EFAULT;
+ 	if (get_user(nb_status->sbuff_len, buff_len))
+ 		goto out_status;
+ 	nb_status->state = NBS_STAT_INITIAL;
+ 	nbst_handle_event(NBE_STAT_STATUS_QUERY, nb_status);
+ 	if (nb_status->state != NBS_STAT_INITIAL)
+ 		nbst_wait_for_resp(nb_status);
+ 	rc = -EFAULT;
+ 	if (put_user(MIN(nb_status->sbuff_len, nb_status->len_rx_info),
+ 			buff_len))
+ 		goto out_status;
+ 	switch (nb_status->resp_status) {
+ 		case NO_RESPONSE:
+ 			rc = -EHOSTUNREACH;
+ 			break;
+ 		case INCOMPLETE_RESPONSE:
+ 			rc = -ETIMEDOUT;
+ 			break;
+ 		case USER_BUFFER_OVERFLOW:
+ 			rc = -EOVERFLOW;
+ 		default: /* COMPLETED_RESPONSE */
+ 			rc = 0;
+ 	}
+ out_status:
+ 	nbst_free_status(nb_status);
+ out:	return rc;
+ }
+ 
+ /* Exported  N B S T  Functions */
+ /*
+  * Function: nbst_init_status
+  *	Performs some initializes for STATUS service functions during
+  *	installation of NetBEUI in memory.
+  *
+  * Parameters: none
+  *
+  * Returns: none
+  */
+ void nbst_init_status(void)
+ {
+ 	memset(&nb_status_record, 0, sizeof(nb_status_record));
+ 	jiffies_at_reset = jiffies;
+ }
+ 
+ /*
+  * Function: nbst_obtain_status
+  *	Interface function for NetBEUI STATUS service.
+  *
+  * Parameters:
+  *	remote_name : pointer to a NetBIOS name that must retrieve status
+  *	              information about it.
+  *	status_buff : (VRP) pointer to user buffer that must be filled with
+  *	              status information.
+  *	buff_len    : (VRP) pointer to an integer that indicates length of
+  *	              user buffer at start and length of retrieved information
+  *	              at end.
+  *
+  * Returns: int
+  *	zero     : if information retrieved successfully.
+  *	negative : if something is bad.
+  */
+ int nbst_obtain_status(char *called_name, char *status_buff, int *buff_len)
+ {
+ 	int name;
+ 
+ 	if (get_user(name, called_name))
+ 		return -EFAULT;
+ 	return name == '*' ?  nbst_local_status(status_buff, buff_len) :
+ 			      nbst_remote_status(called_name, status_buff,
+ 					         buff_len);
+ }
+ 
+ /*
+  * Function: nbst_get_status_query
+  *	Takes a NETBEUI_STATUS_QUERY frame from 'llc supplementary' and response
+  *	to it.
+  *
+  * Parameters:
+  *	skb        : pointer to sk_buff that contains received frame.
+  *	remote_mac : pointer to buffer that contains MAC address of sender
+  *	             of the frame.
+  *
+  * Returns: none
+  */
+ void nbst_get_status_query(struct sk_buff *skb, unsigned char *remote_mac)
+ {
+ 	int tmp, losd, nonts, info_len;
+ 	__u16 loits;
+ 	struct sk_buff *resp_skb;
+ 	dgram_t *resp_hdrp, *hdrp = (dgram_t *)skb->data;
+ 	/* Test for illegal requests */
+ 	name_t *nb_name = nbns_find_name(hdrp->dest_name);
+ 
+ 	if (!nb_name)
+ 		goto free_skb;
+ 	/* Status query for a group name has no meaning */
+ 	if (nb_name->type == NETBEUI_NAME_GROUP)
+ 		goto out_put;
+ 	info_len = nbst_gather_status_info(skb->dev);
+ 	if (hdrp->data1 > 1 &&
+ 	    hdrp->data1 >= nb_status_record.no_names_in_local_name_tbl)
+ 		goto out_put;
+ 	/* Make a sk_buff for response */
+ 	resp_skb = alloc_skb(skb->dev->mtu, GFP_ATOMIC);
+ 	if (!resp_skb)
+ 		goto out_put;
+ 	tmp = LLCMAC_UI_HEADLEN(MAC_HEADLEN(skb->dev));
+ 	skb_reserve(resp_skb, tmp);
+ 	resp_skb->nh.raw = resp_skb->h.raw = resp_skb->data;
+ 	resp_hdrp = (dgram_t *)skb_put(resp_skb,
+ 			        nb_command_header_len[NETBEUI_STATUS_RESPONSE]);
+ 	resp_hdrp->length = nb_command_header_len[NETBEUI_STATUS_RESPONSE];
+ 	resp_hdrp->delimiter = NETBEUI_DELIMITER;
+ 	resp_hdrp->command = NETBEUI_STATUS_RESPONSE;
+ 	resp_hdrp->xmit_correlator = hdrp->resp_correlator;
+ 	/* Find length of data that can be sent */
+ 	tmp = skb->dev->mtu - tmp;
+ 	losd = tmp - nb_command_header_len[NETBEUI_STATUS_RESPONSE];
+ 	losd = MIN(losd, hdrp->data2);
+ 
+ 	if (hdrp->data1 <= 1) { /* An initial request */
+ 		nonts = (losd - NETBEUI_MIN_STATUS_BUFF_LEN) /
+ 			(NETBEUI_NAME_LEN + 2);
+ 		nonts = MIN(nonts, nb_status_record.no_names_in_local_name_tbl);
+ 		loits = NETBEUI_MIN_STATUS_BUFF_LEN + nonts *
+ 				(NETBEUI_NAME_LEN + 2);
+ 		memcpy(skb_put(resp_skb, loits), &nb_status_record, loits);
+ 		resp_hdrp->data1 = nonts ? nonts : 1;
+ 	} else {
+ 		nonts = losd / (NETBEUI_NAME_LEN + 2);
+ 		tmp = nb_status_record.no_names_in_local_name_tbl - hdrp->data1;
+ 		nonts = MIN(nonts, tmp);
+ 		info_len = tmp * (NETBEUI_NAME_LEN + 2);
+ 		loits = nonts * (NETBEUI_NAME_LEN + 2);
+ 		memcpy(skb_put(resp_skb, loits),
+ 		       &nb_status_record.local_names[hdrp->data1], loits);
+ 		resp_hdrp->data1 = nonts + hdrp->data1;
+ 	}
+ 	loits &= NBST_LENGTH_MASK;
+ 	if (info_len > losd)
+ 		loits |= NBST_FRAGMENT_MASK;
+ 	if (info_len > hdrp->data2)
+ 		loits |= NBST_OVERFLOW_MASK;
+ 	resp_hdrp->data2 = loits;
+ 	memcpy(resp_hdrp->dest_name, hdrp->source_name, NETBEUI_NAME_LEN);
+ 	memcpy(resp_hdrp->source_name, hdrp->dest_name, NETBEUI_NAME_LEN);
+ 	resp_skb->dev = skb->dev;
+ 	kfree_skb(skb);
+ 	nbll_uisend(remote_mac, resp_skb);
+ 	nbns_name_put(nb_name);
+ out:	return;
+ out_put:
+ 	nbns_name_put(nb_name);
+ free_skb:
+ 	kfree_skb(skb);
+ 	goto out;
+ }
+ 
+ /*
+  * Function: nbst_get_status_response
+  *	Takes a NETBEUI_STATUS_RESPONSE frame from 'llc supplementary' and
+  *	place it on appropriate nb_status structure.
+  *
+  * Parameters:
+  *	skb        : pointer to sk_buff that contains received frame.
+  *	remote_mac : pointer to buffer that contains MAC address of sender
+  *	             of the frame.
+  *
+  * Returns: none
+  */
+ void nbst_get_status_response(struct sk_buff *skb, unsigned char *remote_mac)
+ {
+ 	dgram_t *dgram = (dgram_t *)skb->data;
+ 	status_t *nb_status = nbst_find_correlator(dgram->xmit_correlator);
+ 
+ 	/* If it does not match a waited status query */
+ 	if (!nb_status)
+ 		goto free_skb;
+ 	barrier();
+ 	if (nb_status->locked) 
+ 		goto free_skb;
+ 	nb_status->rx_skb = skb;
+ 	nb_status->tx_skb->dev = skb->dev;
+ 	memcpy(nb_status->remote_mac, remote_mac, MAC_ADDR_LEN);
+ 	wake_up(&nb_status->waitq);
+ out:	return;
+ free_skb:
+ 	kfree_skb(skb);
+ 	goto out;
+ }
