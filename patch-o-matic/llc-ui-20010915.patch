diff -ruN linux-2.4.9/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.9/Documentation/Configure.help	Sun Sep  9 12:19:09 2001
+++ linux/Documentation/Configure.help	Thu Sep 13 11:08:35 2001
@@ -4890,6 +4890,13 @@
   This is a Logical Link Layer protocol used for X.25 connections over
   Ethernet, using ordinary Ethernet cards. 
 
+
+ANSI/IEEE 802.2 Data link layer User Interface SAPs (EXPERIMENTAL)
+CONFIG_LLC_UI
+  LLC User Interface SAPs is a Linux socket interface into the
+  LLC datalink layer. This allows a user to create entire user
+  space network layers tied to a real SAP.
+
 Frame Diverter (EXPERIMENTAL)
 CONFIG_NET_DIVERT
   The Frame Diverter allows you to divert packets from the
diff -ruN linux-2.4.9/include/linux/llc.h linux/include/linux/llc.h
--- linux-2.4.9/include/linux/llc.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/llc.h	Thu Sep 13 11:08:35 2001
@@ -0,0 +1,78 @@
+/*
+ * IEEE 802.2 User Interface SAPs for Linux, data structures and indicators.
+ *
+ * Copyright (c) 2001 by Jay Schulist <jschlst@samba.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_LLC_H
+#define __LINUX_LLC_H
+
+struct sockaddr_llc {
+        sa_family_t     sllc_family;		/* AF_LLC */
+	sa_family_t	sllc_arphrd;		/* ARPHRD_ETHER */
+	unsigned char   sllc_test;
+        unsigned char   sllc_xid;
+	unsigned char	sllc_ua;		/* UA data, only for SOCK_STREAM. */
+	unsigned char   sllc_dsap;
+	unsigned char   sllc_ssap;
+        unsigned char   sllc_dmac[IFHWADDRLEN];
+        unsigned char   sllc_smac[IFHWADDRLEN];
+};
+
+#define LLC_RETRY		0x01	/* Max retrans attempts. */
+#define LLC_SIZE		0x02	/* Max PDU size (octets). */
+#define LLC_ACK_TIMER_EXPIRE	0x04	/* ack expire time (secs). */
+#define LLC_P_TIMER_EXPIRE	0x05	/* pf cycle expire time (secs). */
+#define LLC_REJ_TIMER_EXPIRE	0x06	/* rej sent expire time (secs). */
+#define LLC_BUSY_TIMER_EXPIRE	0x07	/* busy state expire time (secs). */
+
+#define LLC_MAX_RETRY			100
+#define	LLC_MAX_SIZE			sizeof(u16)
+#define LLC_MAX_WINDOW			50
+#define LLC_MAX_ACK_TIMER_EXPIRE	60
+#define LLC_MAX_P_TIMER_EXPIRE		60
+#define LLC_MAX_REJ_TIMER_EXPIRE	60
+#define LLC_MAX_BUSY_TIMER_EXPIRE	60
+
+/* LLC SAP types. */
+#define LLC_SAP_NULL	0x00		/* NULL SAP. 			*/
+#define LLC_SAP_LLC	0x02		/* LLC Sublayer Managment. 	*/
+#define LLC_SAP_SNA	0x04		/* SNA Path Control. 		*/
+#define LLC_SAP_PNM	0x0E		/* Proway Network Managment.	*/	
+#define LLC_SAP_IP	0x06		/* TCP/IP. 			*/
+#define LLC_SAP_BSPAN	0x42		/* Bridge Spanning Tree Proto	*/
+#define LLC_SAP_MMS	0x4E		/* Manufacturing Message Srv.	*/
+#define LLC_SAP_8208	0x7E		/* ISO 8208			*/
+#define LLC_SAP_3COM	0x80		/* 3COM. 			*/
+#define LLC_SAP_PRO	0x8E		/* Proway Active Station List	*/
+#define LLC_SAP_SNAP	0xAA		/* SNAP. 			*/
+#define LLC_SAP_BANYAN	0xBC		/* Banyan. 			*/
+#define LLC_SAP_IPX	0xE0		/* IPX/SPX. 			*/
+#define LLC_SAP_NETBIOS	0xF0		/* NetBIOS. 			*/
+#define LLC_SAP_LANMGR	0xF4		/* LanManager. 			*/
+#define LLC_SAP_IMPL	0xF8		/* IMPL				*/
+#define LLC_SAP_DISC	0xFC		/* Discovery			*/
+#define LLC_SAP_OSI	0xFE		/* OSI Network Layers. 		*/
+#define LLC_SAP_LAR	0xDC		/* LAN Address Resolution 	*/
+#define LLC_SAP_RM	0xD4		/* Resource Management 		*/
+#define LLC_SAP_GLOBAL	0xFF		/* Global SAP. 			*/
+
+#ifdef __KERNEL__
+struct llc_ui_opt {
+	u16 link_no;
+	struct p8022_sap *sap;
+	struct p8022_connection *handle;
+	struct net_device *dev;
+};
+
+extern int llc_ui_init(void);
+extern void llc_ui_exit(void);
+#endif /* __KERNEL__ */
+#endif /* __LINUX_LLC_H */
diff -ruN linux-2.4.9/include/linux/socket.h linux/include/linux/socket.h
--- linux-2.4.9/include/linux/socket.h	Tue Sep 25 19:29:03 2001
+++ linux/include/linux/socket.h	Thu Sep 13 11:09:59 2001
@@ -152,7 +152,7 @@
 #define AF_ASH		18	/* Ash				*/
 #define AF_ECONET	19	/* Acorn Econet			*/
 #define AF_ATMSVC	20	/* ATM SVCs			*/
-#define AF_SNA		22	/* Linux SNA Project (nutters!) */
+#define AF_LLC		22	/* Linux-LLC 			*/
 #define AF_IRDA		23	/* IRDA sockets			*/
 #define AF_PPPOX	24	/* PPPoX sockets		*/
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
@@ -183,7 +183,7 @@
 #define PF_ASH		AF_ASH
 #define PF_ECONET	AF_ECONET
 #define PF_ATMSVC	AF_ATMSVC
-#define PF_SNA		AF_SNA
+#define PF_LLC		AF_LLC
 #define PF_IRDA		AF_IRDA
 #define PF_PPPOX	AF_PPPOX
 #define PF_WANPIPE	AF_WANPIPE
@@ -237,6 +237,7 @@
 #define SOL_ATM		264	/* ATM layer (cell level) */
 #define SOL_AAL		265	/* ATM Adaption Layer (packet level) */
 #define SOL_IRDA        266
+#define SOL_LLC		277
 
 /* IPX options */
 #define IPX_TYPE	1
diff -ruN linux-2.4.9/include/net/llc_conn.h linux/include/net/llc_conn.h
--- linux-2.4.9/include/net/llc_conn.h	Sun Sep  9 11:56:29 2001
+++ linux/include/net/llc_conn.h	Thu Sep 13 11:15:18 2001
@@ -38,15 +38,19 @@
 	u8                  retry_count;        /* number of retries */
 	struct timer_list   ack_timer;          /* ack to I-PDU/rsp to UI PDU */
 	u8		    ack_running;        /* ack timer is running or no */
+	u16		    ack_expire;		/* ack timer expire time */
 	u8		    ack_must_be_send;
 	u8		    first_pdu_Ns;
 	u8		    npta;   
 	struct timer_list   pf_cycle_timer;     
 	u8		    pf_cycle_running;   /* pf cycle timer is running? */
+	u16		    pf_cycle_expire;	/* pf cycle expire time */
 	struct timer_list   reject_sent_timer;  /* REJECT timer */
 	u8		    reject_sent_running;/* REJ timer is running or no */
+	u16		    reject_sent_expire;	/* REJECT timer expire time */
 	struct timer_list   busy_state_timer;   /* ind busy clr at remote LLC */
 	u8                  busy_state_running; /* busy timer is running? */
+	u16		    busy_state_expire;	/* busy timer expire time */
 	u8                  vS;                 /* seq# next in-seq I-PDU tx'd*/
 	u8		    vR;                 /* seq# next in-seq I-PDU rx'd*/
 	u32		    n2;                 /* max nbr re-tx's for timeout*/
@@ -112,7 +116,7 @@
 extern u16 conn_remove_acked_pdus(struct p8022_connection *conn, u8 nr,
 				  u16 *how_many_unacked);
 extern struct p8022_connection *find_conn(struct p8022_sap *sap,
-					  address_t *remote_addr);
+					  address_t *remote_addr, address_t *local_addr);
 extern u8   data_accept_state(u8 state); 
 extern void build_offset_table(void); 
 extern u16  find_offset(u16 state, u16 event_type);
diff -ruN linux-2.4.9/include/net/llc_sap.h linux/include/net/llc_sap.h
--- linux-2.4.9/include/net/llc_sap.h	Sun Sep  9 11:56:29 2001
+++ linux/include/net/llc_sap.h	Thu Sep 13 11:08:35 2001
@@ -37,8 +37,6 @@
 			    struct p8022_connection *connection);
 extern void sap_unassign_conn(struct p8022_sap *sap,
 			      struct p8022_connection *connection);
-extern struct p8022_connection *sap_find_conn(struct p8022_sap *sap,
-					      address_t *remote_addr);
 extern struct sap_state_event *sap_get_event(struct p8022_sap *sap);
 extern u16 sap_send_event(struct p8022_sap *sap, struct sap_state_event *event);
 extern u16 sap_rtn_pdu(struct p8022_sap *sap, struct sk_buff *skb,
diff -ruN linux-2.4.9/include/net/sock.h linux/include/net/sock.h
--- linux-2.4.9/include/net/sock.h	Sun Sep  9 12:25:11 2001
+++ linux/include/net/sock.h	Thu Sep 13 11:10:17 2001
@@ -98,6 +98,9 @@
 #if defined(CONFIG_NETBEUI) || defined(CONFIG_NETBEUI_MODULE)
 #include <linux/netbeui.h>	/* struct netbeui_sock */
 #endif
+#ifdef CONFIG_LLC_UI
+#include <linux/llc.h>
+#endif
 
 #if defined(CONFIG_ATM) || defined(CONFIG_ATM_MODULE)
 struct atm_vcc;
@@ -659,6 +662,9 @@
 #endif
 #if defined(CONFIG_NETBEUI) || defined(CONFIG_NETBEUI_MODULE)
 		struct netbeui_sock     *af_netbeui;
+#endif
+#ifdef CONFIG_LLC_UI
+		struct llc_ui_opt	*af_llc;
 #endif
 #if defined(CONFIG_WAN_ROUTER) || defined(CONFIG_WAN_ROUTER_MODULE)
                struct wanpipe_opt      *af_wanpipe;
diff -ruN linux-2.4.9/net/8022llc/Makefile linux/net/8022llc/Makefile
--- linux-2.4.9/net/8022llc/Makefile	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/Makefile	Thu Sep 13 11:08:35 2001
@@ -24,6 +24,10 @@
 	 llc_main.o llc_s_ac.o llc_conn.o llc_c_st.o llc_stat.o llc_actn.o \
 	 llc_s_ev.o llc_evnt.o llc_pdu.o llc_cmd_rsp.o
 
+ifeq ($(CONFIG_LLC_UI),y)
+  obj-y += llc_sock.o
+endif
+
 # Objects that export symbols.
 export-objs := llc_if.o
 
diff -ruN linux-2.4.9/net/8022llc/llc_c_ac.c linux/net/8022llc/llc_c_ac.c
--- linux-2.4.9/net/8022llc/llc_c_ac.c	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/llc_c_ac.c	Thu Sep 13 11:08:35 2001
@@ -705,7 +705,7 @@
 	if (!conn->remote_busy_flag) {
 		conn->remote_busy_flag = 1;
 		conn->busy_state_timer.expires  = jiffies +
-						  P8022_BUSY_TIME * HZ;
+						  conn->busy_state_expire * HZ;
 		conn->busy_state_timer.data	= (unsigned long)conn;
 		conn->busy_state_timer.function = conn_busy_timer_callback;
 		add_timer(&conn->busy_state_timer);
@@ -949,7 +949,7 @@
 {
 	conn->p_flag = 1;
 	del_timer(&conn->pf_cycle_timer);
-	conn->pf_cycle_timer.expires  = jiffies + P8022_P_TIME * HZ;
+	conn->pf_cycle_timer.expires  = jiffies + conn->pf_cycle_expire * HZ;
 	conn->pf_cycle_timer.data     = (unsigned long)conn;
 	conn->pf_cycle_timer.function = conn_pf_cycle_timer_callback;
 	add_timer(&conn->pf_cycle_timer);
@@ -1306,7 +1306,7 @@
 			    struct conn_state_event *event)
 {
 	del_timer(&conn->ack_timer);
-	conn->ack_timer.expires  = jiffies + P8022_ACK_TIME * HZ;
+	conn->ack_timer.expires  = jiffies + conn->ack_expire * HZ;
 	conn->ack_timer.data	 = (unsigned long)conn;
 	conn->ack_timer.function = conn_ack_timer_callback;
 	add_timer(&conn->ack_timer);
@@ -1318,7 +1318,7 @@
 			    struct conn_state_event *event)
 {
 	del_timer(&conn->reject_sent_timer);
-	conn->reject_sent_timer.expires  = jiffies + P8022_REJ_TIME * HZ;
+	conn->reject_sent_timer.expires  = jiffies + conn->reject_sent_expire * HZ;
 	conn->reject_sent_timer.data     = (unsigned long)conn;
 	conn->reject_sent_timer.function = conn_rej_timer_callback;
 	add_timer(&conn->reject_sent_timer);
@@ -1330,7 +1330,7 @@
 					   struct conn_state_event *event)
 {
 	if (!conn->ack_running) {
-		conn->ack_timer.expires  = jiffies + P8022_ACK_TIME * HZ;
+		conn->ack_timer.expires  = jiffies + conn->ack_expire * HZ;
 		conn->ack_timer.data 	 = (unsigned long)conn;
 		conn->ack_timer.function = conn_ack_timer_callback;
 		add_timer(&conn->ack_timer);
@@ -1390,7 +1390,7 @@
 		}
 		if (nbr_unack_pdus) {
 			conn->ack_timer.expires  = jiffies +
-						   P8022_ACK_TIME * HZ;
+						   conn->ack_expire * HZ;
                 	conn->ack_timer.data 	 = (unsigned long)conn;
                 	conn->ack_timer.function = conn_ack_timer_callback;
                 	add_timer(&conn->ack_timer);
diff -ruN linux-2.4.9/net/8022llc/llc_conn.c linux/net/8022llc/llc_conn.c
--- linux-2.4.9/net/8022llc/llc_conn.c	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/llc_conn.c	Thu Sep 13 11:08:35 2001
@@ -479,30 +479,33 @@
  *
  * Description :
  *  This function search connection list of the SAP and finds connection
- *  based on remote MAC and SAP address.
+ *  using the remote mac, remote sap, local mac, and local sap.
  *
  * Parameters :
  *  SAP_t *sap : pointer to SAP.
  *  address_t *remote_addr : address of remote LLC (MAC+SAP).
+ *  address_t *local_addr  : address of local LLC (MAC+SAP).
  *  void **conn_ptr : found connection.
  *
  * Returns :
  *  0 : success.
  *  1 : connection not found.
  */
+
 struct p8022_connection *find_conn(struct p8022_sap *sap,
-				   address_t *remote_addr)
+                                       address_t *remote_addr, address_t *local_addr)
 {
-	struct p8022_connection *conn = NULL;
-	struct list_head *entry;
+        struct p8022_connection *conn = NULL;
+        struct list_head *entry;
 
-	spin_lock_bh(&sap->connection_list.lock);
-	list_for_each(entry, &sap->connection_list.list) {
-		conn = list_entry(entry, struct p8022_connection, node);
-		if (!memcmp(conn->remote_dl_addr.mac, remote_addr->mac,
-			    MAC_ADDR_LEN))
-			break;
-	}
+        spin_lock_bh(&sap->connection_list.lock);
+        list_for_each(entry, &sap->connection_list.list) {
+                conn = list_entry(entry, struct p8022_connection, node);
+                if (!memcmp(conn->local_dl_addr.mac, local_addr->mac, MAC_ADDR_LEN)
+                        && !memcmp(conn->remote_dl_addr.mac, remote_addr->mac,
+                        MAC_ADDR_LEN))
+                        break;
+        }
 	if (entry == &sap->connection_list.list) /* not found */
 		conn = NULL;
 	spin_unlock_bh(&sap->connection_list.lock);
diff -ruN linux-2.4.9/net/8022llc/llc_if.c linux/net/8022llc/llc_if.c
--- linux-2.4.9/net/8022llc/llc_if.c	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/llc_if.c	Thu Sep 13 11:08:35 2001
@@ -425,14 +427,14 @@
 	/* network layer supplies addressing required to establish connection;
 	 * package as an event and send it to the connection event handler */
 	struct p8022_connection *conn = find_conn(sap, 
-						  &prim->data->conn.dest_addr);
+		&prim->data->conn.dest_addr, &prim->data->conn.source_addr);
 
 	if (conn) {
 		confirm_impossible(prim);
 		goto out;
 	}
 	conn = llc_connection_alloc();
-	if (conn) {
+	if (!conn) {
 		confirm_impossible(prim);
 		goto out;
 	}
diff -ruN linux-2.4.9/net/8022llc/llc_mac.c linux/net/8022llc/llc_mac.c
--- linux-2.4.9/net/8022llc/llc_mac.c	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/llc_mac.c	Thu Sep 13 11:08:35 2001
@@ -108,12 +108,15 @@
 	if (dest == P8022_DEST_SAP) /* type 1 services */
 		llc_pdu_router(sap, NULL, skb, P8022_TYPE_1);
 	else if (dest == P8022_DEST_CONN) {
-		address_t source_addr;
+		address_t source_addr, dest_addr;
 		struct p8022_connection *conn;
 
 		pdu_decode_sa(skb, source_addr.mac);
 		pdu_decode_ssap(skb, &source_addr.lsap);
-		conn = sap_find_conn(sap, &source_addr);
+		pdu_decode_da(skb, dest_addr.mac);
+		pdu_decode_dsap(skb, &dest_addr.lsap);
+
+		conn = find_conn(sap, &source_addr, &dest_addr);
 		if (!conn) { /* didn't find an active connection; allocate a
 			      connection to use; associate it with this SAP */
 			conn = llc_connection_alloc();
diff -ruN linux-2.4.9/net/8022llc/llc_main.c linux/net/8022llc/llc_main.c
--- linux-2.4.9/net/8022llc/llc_main.c	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/llc_main.c	Thu Sep 13 11:08:35 2001
@@ -32,6 +32,7 @@
 #include <net/llc_s_ev.h>
 #include <net/llc_s_st.h>
 #include <net/llc_mac.h>
+#include <linux/llc.h>
 
 /* static function prototypes */
 static u16 station_service_events(struct p8022_station *station);
@@ -48,6 +49,13 @@
 					     struct station_state_event *event);
 static int rtn_all_conns(struct p8022_sap *sap);
 
+extern void P8022_register_sap(unsigned char sap,
+                               int (*rcvfunc)(struct sk_buff *,
+                                              struct net_device *,
+                                              struct packet_type *));
+extern void P8022_unregister_sap(unsigned char sap);
+
+
 static struct p8022_station Station;	/* only one of its kind */
 u16 Max_nbr_saps = P8022_GLOBAL_DEFAULT_MAX_NBR_SAPS;
 u16 Max_nbr_connections = P8022_GLOBAL_DEFAULT_MAX_NBR_CONNS;
@@ -174,20 +182,24 @@
 	if (!conn)
 		goto out;
 	memset(conn, 0, sizeof(*conn));
-	conn->state	   = CONN_STATE_ADM;
-	conn->inc_step	   = 1;
-	conn->dec_step	   = 1;
-	conn->inc_cntr	   = 2;
-	conn->dec_cntr	   = 2;
-	conn->connect_step = 1;
+	conn->state	   	= CONN_STATE_ADM;
+	conn->inc_step	   	= 1;
+	conn->dec_step	   	= 1;
+	conn->inc_cntr	   	= 2;
+	conn->dec_cntr	   	= 2;
+	conn->connect_step 	= 1;
 	skb_queue_head_init(&conn->mac_pdu_q);
 	skb_queue_head_init(&conn->pdu_unack_q);
 	INIT_LIST_HEAD(&conn->log_q.list);
 	spin_lock_init(&conn->log_q.lock);
-	conn->n2	   = 2;    /* max retransmit */
-	conn->k		   = 2;    /* tx window size, will adjust dynamically */
-	conn->rw	   = 128;  /* rx window size (optional and equal to
-				      tx_window of remote LLC )*/
+	conn->ack_expire   	= P8022_ACK_TIME;
+	conn->pf_cycle_expire 	= P8022_P_TIME;
+	conn->reject_sent_expire= P8022_REJ_TIME;
+	conn->busy_state_expire = P8022_BUSY_TIME;
+	conn->n2	   	= 2;    /* max retransmit */
+	conn->k		   	= 2;    /* tx window size, will adjust dynamically */
+	conn->rw	   	= 128;  /* rx window size (optional and equal to
+				      		tx_window of remote LLC )*/
 out:	return conn;
 }
 
@@ -621,25 +633,24 @@
 	struct list_head *sap_entry, *conn_entry;
 	off_t begin = 0, pos = 0;
 	int len = 0;
-		
+
 	spin_lock_bh(&Station.sap_list.lock);
 	list_for_each(sap_entry, &Station.sap_list.list) {
 		sap = list_entry(sap_entry, struct p8022_sap, node);
-		len += snprintf(bf + len, length - offset - len,
+		len += sprintf(bf + len,
 				"lsap=%d\n", sap->local_dl_addr.lsap);
 		spin_lock_bh(&sap->connection_list.lock);
 		if (list_empty(&sap->connection_list.list)) {
-			len += snprintf(bf + len, length - offset - len,
+			len += sprintf(bf + len,
 					"no connections\n");
 			goto unlock;
 		}
-		len += snprintf(bf + len, length - offset - len,
-				"connection list:\nstate      retries busy\n",
-				sap->local_dl_addr.lsap);
+		len += sprintf(bf + len,
+				"connection list:\nstate      retries busy\n");
 		list_for_each(conn_entry, &sap->connection_list.list) {
 			conn = list_entry(conn_entry, struct p8022_connection,
 					  node);
-			len += snprintf(bf + len, length - offset - len,
+			len += sprintf(bf + len,
 					"  %-11s%-8d%-4d\n",
 				   Connection_state_table[conn->state - 1].desc,
 					conn->retry_count,
@@ -685,6 +696,7 @@
 	memcpy(Station.mac_sa, dev_base->next->dev_addr, MAC_ADDR_LEN);
 	Station.ack_timer.expires = jiffies + 3 * HZ;
 	/* initialize the station component */
+	P8022_register_sap(0x00, mac_indicate);
 	Station.maximum_retry = 1;
 	Station.state = STATION_STATE_DOWN;
 	event->type = STATION_EV_TYPE_SIMPLE;
@@ -694,6 +706,11 @@
 	Ind_prim.data = &Ind_data_prim;
 	Cfm_prim.data = &Cfm_data_prim;
 	proc_net_create("802.2", 0, p8022_proc_get_info);
+
+#ifdef CONFIG_LLC_UI
+	llc_ui_init();
+#endif /* CONFIG_LLC_UI */
+
 out:	return rc;
 err:	printk(err_llc);
 	rc = 1;
@@ -702,6 +719,11 @@
 
 static void __exit p8022_exit(void)
 {
+#ifdef CONFIG_LLC_UI
+	llc_ui_exit();
+#endif /* CONFIG_LLC_UI */
+
+	P8022_unregister_sap(0x00);
 	proc_net_remove("802.2");
 }
 
diff -ruN linux-2.4.9/net/8022llc/llc_pdu.c linux/net/8022llc/llc_pdu.c
--- linux-2.4.9/net/8022llc/llc_pdu.c	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/llc_pdu.c	Thu Sep 13 11:08:35 2001
@@ -541,7 +541,7 @@
 	pdu->ctrl_1 = LLC_PDU_TYPE_U;
 	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
 	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
-	if (ev_skb->protocol == ntohs(ETH_P_802_2)) {
+	if (ev_skb->protocol != ntohs(ETH_P_802_2)) {
 		data_size = ntohs(((ieee_802_3_mac_hdr_t *)
 					ev_skb->mac.raw)->lpdu_len) - 3;
 		memcpy(((u8 *)skb->nh.raw) + 3,
diff -ruN linux-2.4.9/net/8022llc/llc_sap.c linux/net/8022llc/llc_sap.c
--- linux-2.4.9/net/8022llc/llc_sap.c	Sun Sep  9 11:56:30 2001
+++ linux/net/8022llc/llc_sap.c	Thu Sep 13 11:08:35 2001
@@ -68,9 +68,9 @@
  */
 void sap_unassign_conn(struct p8022_sap *sap, struct p8022_connection *conn)
 {
-	spin_lock_bh(&sap->connection_list.lock);
+//	spin_lock_bh(&sap->connection_list.lock);
 	list_del(&conn->node);
-	spin_unlock_bh(&sap->connection_list.lock);
+//	spin_unlock_bh(&sap->connection_list.lock);
 }
 
 /*
@@ -204,42 +204,6 @@
 	mac_send_pdu(skb);
 	kfree_skb(skb);
 	return 0;
-}
-
-/*
- * Function : sap_find_conn
- *
- * Description :
- *  This function searches connection list of a SAP and finds a connection
- *  by given address.
- *
- * Parameters :
- *  struct p8022_sap *sap : pointer to SAP.
- *  address_t *remote_addr : MAC address of remote machine (base of search).
- *  void **conn_ptr : pointer to found connection (output argument).
- *
- * Returns :
- *  0 : success.
- *  1 : failure.
- */
-struct p8022_connection *sap_find_conn(struct p8022_sap *sap,
-				       address_t *remote_addr)
-{
-	/* search for the corresponding active connection */
-	struct p8022_connection *conn;
-	struct list_head *entry;
-
-	spin_lock_bh(&sap->connection_list.lock);
-	list_for_each(entry, &sap->connection_list.list) {
-		conn = list_entry(entry, struct p8022_connection, node);
-		if (!memcmp(conn->remote_dl_addr.mac, remote_addr->mac,
-		    MAC_ADDR_LEN))
-			break;
-	}
-	if (entry == &sap->connection_list.list) /* didn't found it */
-		conn = NULL;
-	spin_unlock_bh(&sap->connection_list.lock);
-	return conn;
 }
 
 /*
diff -ruN linux-2.4.9/net/8022llc/llc_sock.c linux/net/8022llc/llc_sock.c
--- linux-2.4.9/net/8022llc/llc_sock.c	Wed Dec 31 16:00:00 1969
+++ linux/net/8022llc/llc_sock.c	Tue Sep 25 19:08:57 2001
@@ -0,0 +1,2001 @@
+/*
+ * llc_sock.c - LLC User Interface SAPs
+ * Description :
+ *   Functions in this module are implementation of socket based llc
+ *   communications for the Linux operating system. Support of llc class
+ *   one and class two is provided via SOCK_DGRAM and SOCK_STREAM
+ *   respectively.
+ *
+ *   An llc2 connection is (mac+sap), only one llc2 sap connection
+ *   is allowed per mac. Though one sap may have multiple mac+sap
+ *   connections.
+ *
+ * Copyright (c) 2001 by Jay Schulist <jschlst@samba.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <asm/uaccess.h>        
+#include <asm/ioctls.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/in.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/errno.h>
+#include <net/sock.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/init.h>
+
+#ifndef LLC_UI_DEBUG
+#define LLC_UI_DEBUG 1
+#endif
+static unsigned int llc_ui_debug_level = LLC_UI_DEBUG;
+#define llc_ui_debug(level, format, arg...) \
+	if(llc_ui_debug_level > level)  \
+		printk(__FILE__ ":" __FUNCTION__ "(%d): " format, __LINE__, ## arg)
+
+static u16 llc_ui_sap_link_no_max[256];
+static struct sock *llc_ui_sockets = NULL;
+static struct proto_ops llc_ui_ops;
+static spinlock_t llc_ui_sockets_lock = SPIN_LOCK_UNLOCKED;
+
+static int llc_ui_indicate(struct prim_if_block *prim);
+static int llc_ui_confirm(struct prim_if_block *prim);
+static int llc_ui_wait_for_connect(struct sock *sk, int seconds);
+static int llc_ui_wait_for_disconnect(struct sock *sk, int seconds);
+
+/*
+ * Function : llc_ui_next_link_no
+ *
+ * Description :
+ *  Return the next unused link number for a given sap.
+ *
+ * Parameters :
+ *  sap : Address of sap to get link number from.
+ *
+ * Returns :
+ *  The next unused link number for the sap 0 - 65535.
+ */
+static inline u16 llc_ui_next_link_no(int sap)
+{
+	return (llc_ui_sap_link_no_max[sap]++);
+}
+
+/*
+ * Function : llc_ui_mac_match
+ * 
+ * Description :
+ *  Determines if two given mac address are the same.
+ *  
+ * Parameters :
+ *  mac1 : First mac address to compare.
+ *  mac2 : Second mac address to compare.
+ *  len  : Min length to compare.
+ *  
+ * Returns :
+ *  0, if there is not a complete match upto len.
+ *  1, if a complete match upto len is found.
+ */
+static inline u8 llc_ui_mac_match(u8 *mac1, u8 *mac2, u8 len)
+{
+	return (!memcmp(mac1, mac2, len));
+}
+
+/*
+ * Function : llc_ui_mac_null
+ *
+ * Description :
+ *  Determines if a given address is a NULL mac address.
+ *
+ * Parameters :
+ *  mac : Mac address to test if NULL.
+ *  len : Length of given mac address.
+ *
+ * Returns :
+ *  0, if the address is not a NULL mac.
+ *  1, if the address is a NULL mac.
+ */
+static inline u8 llc_ui_mac_null(u8 *mac, u8 len)
+{
+        u8 addrany[IFHWADDRLEN];
+        memset(&addrany, 0, sizeof(addrany));
+        return (!memcmp(addrany, mac, len));
+}
+
+/*
+ * Function : llc_ui_protocol_type
+ * 
+ * Description :
+ *  Given an ARP harder type return the corresponding ethernet protocol.
+ * 
+ * Parameters :
+ *  arphrd : ARP header type.
+ *  
+ * Returns :
+ *  0, if ARP header type not supported.
+ *  non-zero, the corresponding ethernet protocol type.
+ */
+static inline u16 llc_ui_protocol_type(u16 arphrd)
+{
+        switch(arphrd) {
+                case (ARPHRD_IEEE802):
+                        return (htons(ETH_P_TR_802_2));
+
+                case (ARPHRD_ETHER):
+                default:
+                        return (htons(ETH_P_802_2));
+        }
+
+        return (0);
+}
+
+/* 
+ * Function : llc_ui_header_len
+ * 
+ * Description :
+ *  Provide the length of the llc header depending on what kind of
+ *  operation the user would like to perform and the type of socket.
+ *
+ * Parameters :
+ *  sk : Socket which contains a valid llc socket type.
+ *  addr : Complete sockaddr_llc structure received from the user.
+ *
+ * Returns :
+ *  The correct llc header length.
+ *
+ */
+static inline u8 llc_ui_header_len(struct sock *sk, struct sockaddr_llc *addr)
+{
+        if(addr->sllc_test || addr->sllc_xid)
+                return (LLC_PDU_LEN_U);
+        if(sk->type == SOCK_STREAM)
+                return (LLC_PDU_LEN_I);
+        else
+                return (LLC_PDU_LEN_U);
+}
+
+/*
+ * Function : llc_ui_send_connect
+ *
+ * Description :
+ *  Send a connect command to the llc layer for a new llc2 connection.
+ *
+ * Parameters :
+ *  sap : Sap the socket is bound to.
+ *  addr : Source and destination fields provided by the user.
+ *  dev : Device which this connection should use.
+ *  link_no : Link number to assign to this connection.
+ *
+ * Returns :
+ *  0, upon success.
+ *  non-zero, if action did not succeed.
+ */
+static int llc_ui_send_connect(struct p8022_sap *sap, struct sockaddr_llc *addr,
+        struct net_device *dev, int link_no)
+{
+        prim_data_u prim_data;
+        struct prim_if_block prim;
+
+        llc_ui_debug(10, "start link_no %d\n", link_no);
+
+        prim.data 			= &prim_data;
+	prim.sap 			= sap;
+        prim.primitive 			= P8022_CONNECT_PRIM;
+	prim_data.conn.device 		= dev;
+        prim_data.conn.link_no		= link_no;
+        prim_data.conn.connection 	= NULL;
+        prim_data.conn.priority 	= 0;
+        prim_data.conn.source_addr.lsap = addr->sllc_ssap;
+	prim_data.conn.dest_addr.lsap 	= addr->sllc_dsap;
+        memcpy(prim_data.conn.source_addr.mac, addr->sllc_smac, 
+		IFHWADDRLEN);
+        memcpy(prim_data.conn.dest_addr.mac, addr->sllc_dmac, 
+		IFHWADDRLEN);
+
+        return (sap->request(&prim));
+}
+
+/*
+ * Function : llc_ui_send_disconnect
+ *
+ * Description :
+ *  Send a disconnect command to the llc layer for an established
+ *  llc2 connection.
+ *
+ * Parameters :
+ *  sk : Socket with valid llc information.
+ *
+ * Returns :
+ *  0, upon success.
+ *  non-zero, if action did not succeed.
+ */
+static int llc_ui_send_disconnect(struct sock *sk)
+{
+        struct llc_ui_opt *llc = sk->protinfo.af_llc;
+        prim_data_u prim_data;
+        struct prim_if_block prim;
+
+        llc_ui_debug(10, "start %p\n", sk);
+
+        if(sk->type != SOCK_STREAM)
+                return (0);
+        if(sk->state != TCP_ESTABLISHED)
+                return (0);
+        sk->state = TCP_CLOSING;
+
+        prim.data                 = &prim_data;
+	prim.sap                  = llc->sap;
+        prim.primitive            = P8022_DISCONNECT_PRIM;
+        prim_data.disc.connection = llc->handle;
+        prim_data.disc.link_no    = llc->link_no;
+
+        return (llc->sap->request(&prim));
+}
+
+/*
+ * Function : llc_ui_send_data
+ *
+ * Description :
+ *  Send data via reliable llc2 connection.
+ *
+ * Parameters :
+ *  sap : Sap the socket is bound to.
+ *  handle : Connection the socket is using.
+ *  skb : Data the user wishes to send.
+ *  addr : Source and destination fields provided by the user.
+ *
+ * Returns :
+ *  0, upon success.
+ *  non-zero, if action did not succeed.
+ */
+int llc_ui_send_data(struct p8022_sap *sap, struct p8022_connection *handle,
+        struct sk_buff *skb, struct sockaddr_llc *addr)
+{
+        prim_data_u prim_data;
+        struct prim_if_block prim;
+
+        prim.data 	  	  = &prim_data;
+	prim.sap                  = sap;
+        prim.primitive            = P8022_DATA_PRIM;
+        prim_data.data.skb 	  = skb;
+	prim_data.data.priority   = 0;
+        prim_data.data.connection = handle;
+	skb->protocol             = llc_ui_protocol_type(addr->sllc_arphrd); 
+ 
+        return (sap->request(&prim));
+} 
+
+/*
+ * Function : llc_ui_send_llc1
+ *      
+ * Description :
+ *  Send an llc1 primative data block to the llc layer for processing.
+ *  This function is used for test, xid and unit_data messages.
+ *
+ * Parameters :
+ *  sap : Sap the socket is bound to.
+ *  skb : Data the user wishes to send.
+ *  addr : Source and destination fields provided by the user.
+ *  primative : Action the llc layer should perform.
+ *      
+ * Returns :
+ *  0, upon success.
+ *  non-zero, if action did not succeed.
+ */     
+int llc_ui_send_llc1(struct p8022_sap *sap, struct sk_buff *skb,
+        struct sockaddr_llc *addr, int primative)
+{
+        prim_data_u prim_data;
+        struct prim_if_block prim;
+ 
+        prim.data 			= &prim_data;
+	prim.sap 			= sap;
+        prim.primitive 			= primative;
+	prim_data.test.skb 		= skb;
+        prim_data.test.source_addr.lsap = addr->sllc_ssap;
+	prim_data.test.dest_addr.lsap 	= addr->sllc_dsap;
+	skb->protocol = llc_ui_protocol_type(addr->sllc_arphrd);
+        memcpy(prim_data.test.source_addr.mac, skb->dev->dev_addr, 
+		IFHWADDRLEN);
+        memcpy(prim_data.test.dest_addr.mac, addr->sllc_dmac, 
+		IFHWADDRLEN);
+        
+        return (sap->request(&prim));
+}       
+
+/*
+ * Function : llc_ui_find_sap
+ *
+ * Description :
+ *  Search the local socket list and return the first instance of
+ *  the sap structure which matches the sap number the user specified.
+ *
+ * Parameters :
+ *  sap : Sap number to search for.
+ *
+ * Returns :
+ *  p8022_sap, upon match.
+ *  NULL, upon no match found.
+ */
+static inline struct p8022_sap *llc_ui_find_sap(u8 sap)
+{
+	struct sock *sk;
+
+	llc_ui_debug(15, "sap %d\n", sap);
+
+        for(sk = llc_ui_sockets; sk != NULL; sk = sk->next)
+	{
+		struct llc_ui_opt *llc = sk->protinfo.af_llc;
+                if(!llc->sap)
+			continue;
+                if(llc->sap->local_dl_addr.lsap == sap)
+			return (llc->sap);
+	}
+	return (NULL);
+}
+
+/*
+ * Function : llc_ui_find_socket_by_link_no
+ * 
+ * Description :
+ *  Search the local socket list and return the socket which has
+ *  a matching sap and link_no. This search only works on connected
+ *  sockets.
+ *
+ * Parameters :
+ *  sap : Sap to search for.
+ *  link_no : link number of connection to match.
+ *
+ * Returns :
+ *  sock, upon match.
+ *  NULL, upon no match found.
+ */
+static inline struct sock *llc_ui_find_socket_by_link_no(struct p8022_sap *sap, 
+	u16 link_no)
+{
+        struct sock *sk;
+
+        llc_ui_debug(15, "link_no %d\n", link_no);
+
+        for(sk = llc_ui_sockets; sk != NULL; sk = sk->next)
+        {
+                struct llc_ui_opt *llc = sk->protinfo.af_llc;
+		if(!llc->sap)
+			continue;
+		if(llc->sap->local_dl_addr.lsap != sap->local_dl_addr.lsap)
+			continue;
+		if(!llc->handle)
+                        continue;	/* if no handle, link_no is invalid. */
+		if(llc->link_no != link_no)
+                        continue;
+                return (sk);    	/* exact mac+sap match. */
+        }
+
+        return (NULL);
+}
+
+/*
+ * Function : llc_ui_find_socket_by_addr
+ *
+ * Description :
+ *  Search the local socket list and return the socket which has
+ *  a matching local (mac+sap) address (allows null mac). This search 
+ *  will work on unconnected and connected sockets, though find_by_link_no
+ *  is recommend for connected sockets.
+ *
+ * Parameters :
+ *  addr : Local address to match.
+ *
+ * Returns :
+ *  sock, upon match.
+ *  NULL, upon no match found.
+ */
+static inline struct sock *llc_ui_find_socket_by_addr(address_t *addr)
+{
+        struct sock *sk;
+
+	llc_ui_debug(15, "%02X:%02X:%02X:%02X:%02X:%02X @ %d\n", 
+		addr->mac[0], addr->mac[1], addr->mac[2],
+		addr->mac[3], addr->mac[4], addr->mac[5],
+		addr->lsap);
+
+        for(sk = llc_ui_sockets; sk != NULL; sk = sk->next)
+	{
+		struct llc_ui_opt *llc = sk->protinfo.af_llc;
+		if(!llc->sap)
+			continue;
+		if(llc->sap->local_dl_addr.lsap != addr->lsap)
+                        continue;
+		if(!llc->dev)
+			return (sk);	/* socket gets all connections for this sap. */
+		if(!llc_ui_mac_match(addr->mac, llc->dev->dev_addr, IFHWADDRLEN))
+			continue;
+		return (sk);	/* exact mac+sap match. */
+	}
+
+	return (NULL);
+}
+
+/*              
+ * Function : llc_ui_insert_socket
+ *              
+ * Description :
+ *  Insert a socket into the local llc socket list.
+ *
+ * Parameters :
+ *  sk : Socket to insert.
+ *              
+ * Returns :    
+ *  None.
+ */      
+static inline void llc_ui_insert_socket(struct sock *sk)
+{               
+	llc_ui_debug(5, "start %p\n", sk);
+                       
+        spin_lock_bh(&llc_ui_sockets_lock);
+	sk->next = llc_ui_sockets;
+	if(sk->next)
+		llc_ui_sockets->pprev = &sk->next;
+	llc_ui_sockets = sk;
+	sk->pprev = &llc_ui_sockets;
+	spin_unlock_bh(&llc_ui_sockets_lock);
+        return;
+}   
+
+/*              
+ * Function : llc_ui_remove_socket
+ *              
+ * Description :
+ *  Remove a socket from the local llc socket list.
+ *
+ * Parameters :
+ *  sk : Socket to remove.
+ *              
+ * Returns :    
+ *  None.
+ */      
+static inline void llc_ui_remove_socket(struct sock *sk)
+{
+        llc_ui_debug(5, "start %p\n", sk);
+
+	spin_lock_bh(&llc_ui_sockets_lock);
+	if(sk->pprev)
+	{
+		if(sk->next)
+			sk->next->pprev = sk->pprev;
+		*sk->pprev = sk->next;
+		sk->pprev = NULL;
+	}
+	spin_unlock_bh(&llc_ui_sockets_lock);
+        return;
+}
+
+/*       
+ * Function : llc_ui_destroy_timer
+ *
+ * Description :
+ *  Attempt to destroy a socket which was previously destroyed but
+ *  was still in use at the time.
+ *
+ * Parameters :
+ *  data : Socket which is to be destroyed.
+ *              
+ * Returns :
+ *  None.
+ */      
+static void llc_ui_destroy_timer(unsigned long data)
+{
+        struct sock *sk = (struct sock *)data;
+ 
+        llc_ui_debug(5, "start %p\n", sk);
+
+        skb_queue_purge(&sk->receive_queue);
+        skb_queue_purge(&sk->write_queue);
+        if(!atomic_read(&sk->wmem_alloc)
+                && !atomic_read(&sk->rmem_alloc) && sk->dead)
+        {
+                sock_put(sk);
+                MOD_DEC_USE_COUNT;
+        }
+        else
+        {
+                sk->timer.expires = jiffies + SOCK_DESTROY_TIME;
+                add_timer(&sk->timer);
+        }
+
+        return;
+}
+
+/*              
+ * Function : llc_ui_sock_destructor
+ *              
+ * Description :
+ *  Free the private areas of this socket with regards to the llc_ui layer.
+ *
+ * Parameters :
+ *  sk : Socket to be destroyed.
+ *              
+ * Returns :    
+ *  None.
+ */      
+static void llc_ui_sock_destructor(struct sock *sk)
+{
+	if(!sk->dead) 
+                return;
+
+	BUG_TRAP(atomic_read(&sk->rmem_alloc)==0);
+        BUG_TRAP(atomic_read(&sk->wmem_alloc)==0);
+	sk->protinfo.af_llc->dev    = NULL;
+	sk->protinfo.af_llc->sap    = NULL;
+	sk->protinfo.af_llc->handle = NULL;
+	kfree(sk->protinfo.af_llc);
+
+	return;
+}
+
+/*              
+ * Function : llc_ui_sock_init
+ *              
+ * Description :
+ *  Allocate and initialize the private area of an llc_ui socket.
+ *
+ * Parameters :
+ *  sk : Socket to initialize.
+ *              
+ * Returns :    
+ *  0, upon success.
+ *  -ENOMEM, upon failure to allocate memory for socket's private area.
+ */      
+static int llc_ui_sock_init(struct sock *sk)
+{
+	sk->protinfo.af_llc = kmalloc(sizeof(*sk->protinfo.af_llc), GFP_KERNEL);
+	if(!sk->protinfo.af_llc)
+		return (-ENOMEM);
+	memset(sk->protinfo.af_llc, 0, sizeof(*sk->protinfo.af_llc));
+	sk->protinfo.af_llc->link_no= 0;
+	sk->protinfo.af_llc->dev    = NULL;
+	sk->protinfo.af_llc->sap    = NULL;
+	sk->protinfo.af_llc->handle = NULL;
+
+        return (0);
+}
+
+/*              
+ * Function : llc_ui_create
+ *              
+ * Description :
+ *  Allocate and initialize a new llc_ui socket, validate the user wants
+ *  a socket type we have available.
+ *
+ * Parameters :
+ *  sock : Socket to initialize and attach allocated sk to.
+ *  protocol : Unused.
+ *              
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.            
+ */      
+static int llc_ui_create(struct socket *sock, int protocol)
+{
+        struct sock *sk;
+	int err;
+
+        sk = sk_alloc(PF_LLC, GFP_KERNEL, 1);
+        if(sk == NULL)
+                return (-ENOMEM);
+
+        switch(sock->type)
+        {
+		case (SOCK_RAW):
+                case (SOCK_DGRAM):	/* llc1 */
+		case (SOCK_STREAM):     /* llc2 */
+                        sock->ops = &llc_ui_ops;
+                        break;
+
+		case (SOCK_SEQPACKET):	/* llc3 */
+                default:
+                        sk_free(sk);
+                        return (-ESOCKTNOSUPPORT);
+        }
+
+        sock_init_data(sock, sk);
+        sk->destruct = llc_ui_sock_destructor;
+	sk->zapped   = 1;
+	err = llc_ui_sock_init(sk);
+	if(err < 0)
+	{
+		sk_free(sk);
+		return (err);
+	}
+
+        MOD_INC_USE_COUNT;
+
+        return (0);
+}
+
+/*              
+ * Function : llc_ui_release
+ *              
+ * Description :
+ *  Shutdown and deallocate an existing socket.
+ *      
+ * Parameters :
+ *  sock : Socket to release.
+ *              
+ * Returns :    
+ *  0 always.
+ */      
+static int llc_ui_release(struct socket *sock)
+{
+        struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc;
+        if(sk == NULL)
+                return (0);
+
+        llc_ui_debug(5, "start %p\n", sk);
+
+	llc_ui_remove_socket(sk);
+	llc = sk->protinfo.af_llc;
+	if(llc->sap)
+	{
+		/* if no one else is using the sap, close it, else disconnect. */
+		if(!llc_ui_find_sap(llc->sap->local_dl_addr.lsap))
+	                llc_sap_close(llc->sap);
+		else
+			llc_ui_send_disconnect(sk);
+	}
+	skb_queue_purge(&sk->receive_queue);
+	skb_queue_purge(&sk->write_queue);
+	sock_orphan(sk);
+        sock->sk = NULL;
+
+	if(!atomic_read(&sk->wmem_alloc)
+                && !atomic_read(&sk->rmem_alloc) && sk->dead)
+        {       
+                sock_put(sk);
+                MOD_DEC_USE_COUNT;
+        }       
+        else
+        {
+                init_timer(&sk->timer);
+                sk->timer.expires = jiffies + SOCK_DESTROY_TIME;
+                sk->timer.function = llc_ui_destroy_timer;
+                sk->timer.data = (unsigned long)sk;
+                add_timer(&sk->timer);
+        }
+
+        return (0);
+}
+
+/*
+ * Function : llc_ui_autobind
+ *
+ * Description :
+ *  Bind a socket to a specific address. For llc a user is able to bind
+ *  to a specific sap only or mac+sap. If the user only specifies a sap
+ *  and a null dmac (all zeros) the user is attempting to bind to an entire
+ *  sap. This will stop anyone else on the local system from using that sap.
+ *  If someone else has a mac+sap open the bind to null+sap will fail.
+ *
+ *  If the user desires to bind to a specific mac+sap, it is possible to
+ *  have multiple sap connections via multiple macs.
+ *
+ *  Bind and autobind for that matter must enforce the correct sap usage
+ *  otherwise all hell will break loose.
+ *
+ * Parameters :
+ *  sk : Socket to bind an address to.
+ *  addr : Address the user wants the socket bound to.
+ * 
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)
+{
+	struct sock *sk = sock->sk;
+        struct p8022_sap *sap; 
+        struct net_device *dev = NULL;
+        
+        llc_ui_debug(5, "start %p\n", sk);
+        
+        if(!sk->zapped)
+                return (-EINVAL);
+        
+        /* bind to a specific mac, optional. */
+        if(!llc_ui_mac_null(addr->sllc_smac, IFHWADDRLEN))
+        {       
+                rtnl_lock();
+                dev = dev_getbyhwaddr(addr->sllc_arphrd, addr->sllc_smac);
+                rtnl_unlock();
+                if(!dev)
+                        return (-ENETUNREACH);
+                sk->protinfo.af_llc->dev = dev;
+		llc_ui_debug(5, "using device %s\n", dev->name);
+        }
+ 
+        /* bind to a specific sap, required. */
+        sap = llc_ui_find_sap(addr->sllc_ssap);
+        if(!sap)
+        {       
+                sap = llc_sap_open(llc_ui_indicate, llc_ui_confirm, addr->sllc_ssap);
+                if(!sap)
+                        return (-EBUSY);   /* some other network layer is using the sap. */
+        }
+        else
+        {
+		address_t local_addr;
+                if(!dev)
+                        return (-EUSERS);       /* can't get exclusive use of sap. */
+		memset(&local_addr, 0, sizeof(local_addr));
+		memcpy(local_addr.mac, addr->sllc_smac, IFHWADDRLEN);
+		local_addr.lsap = addr->sllc_ssap;
+		if(llc_ui_find_socket_by_addr(&local_addr))
+                        return (-EADDRINUSE);   /* mac+sap clash. */
+        }
+
+        sk->protinfo.af_llc->sap = sap;
+        sk->zapped 		 = 0;
+        llc_ui_insert_socket(sk);
+        
+        return (0);
+}
+
+/*
+ * Function : llc_ui_bind
+ *
+ * Description :
+ *  Bind a socket to a specific address. For llc a user is able to bind
+ *  to a specific sap only or mac+sap. If the user only specifies a sap
+ *  and a null dmac (all zeros) the user is attempting to bind to an entire
+ *  sap. This will stop anyone else on the local system from using that sap.
+ *  If someone else has a mac+sap open the bind to null+sap will fail.
+ *
+ *  If the user desires to bind to a specific mac+sap, it is possible to
+ *  have multiple sap connections via multiple macs.
+ *
+ *  Bind and autobind for that matter must enforce the correct sap usage
+ *  otherwise all hell will break loose.
+ *
+ * Parameters :
+ *  sock : Socket to bind an address to.
+ *  uaddr : Address the user wants the socket bound to.
+ *  addr_len : Length of the uaddr structure.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+        struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;
+	struct sock *sk = sock->sk;
+
+	llc_ui_debug(5, "start %p\n", sk);
+
+        if(sk->zapped == 0)
+                return (-EINVAL);
+        if(addr_len != sizeof(struct sockaddr_llc))
+                return (-EINVAL);
+        if(addr->sllc_family != AF_LLC)
+                return (-EAFNOSUPPORT);
+
+	/* use autobind, to avoid code replication. */
+	return (llc_ui_autobind(sock, addr));
+}
+
+/*
+ * Function : llc_ui_shutdown
+ *
+ * Description :
+ *  Shutdown a connected llc2 socket. Currently this function only supports
+ *  shutting down both sends and receives (2), we could probably make this 
+ *  function such that a user can shutdown only half the connection but not
+ *  right now.
+ *
+ * Parameters :
+ *  sock : Socket to shutdown.
+ *  how : What part of the socket to shutdown.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_shutdown(struct socket *sock, int how)
+{
+        struct sock *sk = sock->sk;
+	int err;
+
+	llc_ui_debug(5, "start %p\n", sk);
+
+	if(sk->state != TCP_ESTABLISHED)
+		return (-ENOTCONN);
+	if(how != 2)
+		return (-EINVAL);
+
+	lock_sock(sk);
+	err = llc_ui_send_disconnect(sk);
+	if(err == 0)
+	        llc_ui_wait_for_disconnect(sk, 255);
+
+	/* Wake up anyone sleeping in poll. */
+        sk->state_change(sk);
+        release_sock(sk);
+        return (err);
+}
+
+/*
+ * Function : llc_ui_connect
+ *
+ * Description :
+ *  Connect to a remote llc2 mac+sap. The caller must specify the destination mac
+ *  and address to connect to. If the user previously called bind(2) with a smac
+ *  the user does not need to specify the source address and mac.
+ *
+ *  This function will autobind if user did not previously call bind.
+ *
+ * Parameters :
+ *  sock : Socket which will be connected to the remote destination.
+ *  uaddr : Remote and possibly the local address of the new connection.
+ *  addr_len : Size of uaddr structure.
+ *  flags : Operational flags specified by the user.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,
+        int addr_len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = sk->protinfo.af_llc;
+        struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;
+	struct net_device *dev;
+	int err;
+
+        llc_ui_debug(5, "start %p\n", sk);
+
+        if(addr_len != sizeof(*addr))
+                return (-EINVAL);
+        if(addr->sllc_family != AF_LLC)
+                return (-EAFNOSUPPORT);
+	if(sk->type != SOCK_STREAM)
+		return (-EINVAL);
+	if(sock->state == SS_CONNECTING)
+		return (-EALREADY);
+
+	lock_sock(sk);
+        sock->state     = SS_CONNECTING;
+        sk->state       = TCP_SYN_SENT;
+
+	/* must bind connection to sap if user hasn't done it. */
+        if(sk->zapped)
+        {
+                /* bind to sap with null dev, exclusive. */
+                err = llc_ui_autobind(sock, addr);
+                if(err < 0)
+                {
+                        sock->state = SS_UNCONNECTED;
+                        sk->state   = TCP_CLOSE;
+			release_sock(sk);
+                        return (err);
+                }
+        }
+
+        if(!llc->dev)
+        {
+                rtnl_lock();
+                dev = dev_getbyhwaddr(addr->sllc_arphrd, addr->sllc_smac);
+                rtnl_unlock();
+                if(dev == NULL)
+		{
+			sock->state = SS_UNCONNECTED;
+			sk->state   = TCP_CLOSE;
+			release_sock(sk);
+                        return (-ENETUNREACH);
+		}
+        }
+        else
+                dev = llc->dev;
+
+	llc->link_no = llc_ui_next_link_no(addr->sllc_ssap);
+	err = llc_ui_send_connect(llc->sap, addr, dev, llc->link_no);
+	if(err < 0)
+	{
+		sock->state = SS_UNCONNECTED;
+                sk->state   = TCP_CLOSE;
+		release_sock(sk);
+		return (err);
+	}
+
+	err = llc_ui_wait_for_connect(sk, 255);
+	release_sock(sk);
+        return (err);
+}
+
+/*
+ * Function : llc_ui_listen
+ *
+ * Description :
+ *  Allow a normal socket to accept incomming connections.
+ *
+ * Parameters :
+ *  sock : Socket to allow incomming connections on.
+ *  backlog : Number of connections to queue.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_listen(struct socket *sock, int backlog)
+{
+        struct sock *sk = sock->sk;
+
+        llc_ui_debug(5, "start %p\n", sk);
+
+        if(sock->state != SS_UNCONNECTED)
+                return (-EINVAL);
+        if(sk->type != SOCK_STREAM && sk->type != SOCK_SEQPACKET)
+                return (-EOPNOTSUPP);
+        if(sk->zapped != 0)
+                return (-EAGAIN);
+
+	lock_sock(sk);
+        if((unsigned) backlog == 0)     /* BSDism */
+                backlog = 1;
+        if((unsigned) backlog > SOMAXCONN)
+                backlog = SOMAXCONN;
+        sk->max_ack_backlog = backlog;
+        if(sk->state != TCP_LISTEN)
+        {
+                sk->ack_backlog = 0;
+                sk->state = TCP_LISTEN;
+        }
+        sk->socket->flags |= __SO_ACCEPTCON;
+	release_sock(sk);
+
+        return (0);
+}
+
+/*
+ * Function : llc_ui_wait_for_disconnect
+ *
+ * Description :
+ *  Socket "sleeps" waiting for the disconnect to complete.
+ *
+ * Parameters :
+ *  sock : Socket to wait for disconnect to complete.
+ *  seconds: Number of seconds to schedule for timeout.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_wait_for_disconnect(struct sock *sk, int seconds)
+{
+        DECLARE_WAITQUEUE(wait, current);
+        int rc, timeout = seconds * HZ;
+
+        add_wait_queue_exclusive(sk->sleep, &wait);
+        for(;;)
+        {
+                __set_current_state(TASK_INTERRUPTIBLE);
+		rc = 0;
+                if(sk->state != TCP_CLOSE)
+                        timeout = schedule_timeout(timeout);
+		else
+			break;
+                rc = -ERESTARTSYS;
+                if(signal_pending(current))
+                        break;
+                rc = -EAGAIN;
+                if(!timeout)
+                        break;
+        }
+        __set_current_state(TASK_RUNNING);
+        remove_wait_queue(sk->sleep, &wait);
+        return (rc);
+}
+
+/*
+ * Function : llc_ui_wait_for_connect
+ *
+ * Description :
+ *  Socket "sleeps" waiting for the connect to complete.
+ *
+ * Parameters :
+ *  sock : Socket to wait for connect to complete.
+ *  seconds: Number of seconds to schedule for timeout.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_wait_for_connect(struct sock *sk, int seconds)
+{
+        DECLARE_WAITQUEUE(wait, current);
+        int rc, timeout = seconds * HZ;
+
+        llc_ui_debug(5, "start %p\n", sk);
+
+        add_wait_queue_exclusive(sk->sleep, &wait);
+        for(;;)
+        {
+                __set_current_state(TASK_INTERRUPTIBLE);
+                rc = 0;
+                if(sk->state != TCP_ESTABLISHED)
+                        timeout = schedule_timeout(timeout);
+		if(sk->state == TCP_ESTABLISHED)
+		{
+			if(!sk->protinfo.af_llc->handle)
+				rc = -EAGAIN;
+			break;
+		}
+		rc = -EAGAIN;
+		if(sk->state == TCP_CLOSE)
+			break;
+                rc = -ERESTARTSYS;
+                if(signal_pending(current))
+                        break;
+                rc = -EAGAIN;
+                if(!timeout)
+                        break;
+        }               
+        __set_current_state(TASK_RUNNING);
+        remove_wait_queue(sk->sleep, &wait);
+        return (rc);
+}       
+
+/*
+ * Function : llc_ui_accept
+ *
+ * Description :
+ *  Accept a new incomming connection.
+ *
+ * Parameters :
+ *  sock : Socket which connections arrive on.
+ *  newsock : Socket to move incomming connection to.
+ *  flags : User specified operational flags.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+        struct sock *sk = sock->sk, *newsk;
+	struct sk_buff *skb;
+        int err;
+
+        llc_ui_debug(5, "start %p\n", sock->sk);
+
+	lock_sock(sk);
+	if(sk->type != SOCK_SEQPACKET && sk->type != SOCK_STREAM)
+	{
+		release_sock(sk);
+                return (-EOPNOTSUPP);
+	}
+	if(sock->state != SS_UNCONNECTED)
+	{
+		release_sock(sk);
+                return (-EINVAL);
+	}
+        if(sk->state != TCP_LISTEN)
+	{
+		release_sock(sk);
+                return (-EINVAL);
+	}
+
+	/* wait for a connection to arrive. */
+        do {
+                if((skb = skb_dequeue(&sk->receive_queue)) == NULL) 
+		{
+                        if(flags & O_NONBLOCK)
+			{
+				release_sock(sk);
+                                return (-EWOULDBLOCK);
+			}
+
+                        interruptible_sleep_on(sk->sleep);
+                        if(signal_pending(current))
+			{
+				release_sock(sk);
+                                return (-ERESTARTSYS);
+			}
+                }
+        } while(skb == NULL);
+
+	/* some other data arrived on this socket, shouldn't happen ever. */
+	if(!skb->sk->protinfo.af_llc->handle)
+        {       
+        	llc_ui_debug(5, "accept: tossing skb with bad handle (NULL)\n");
+        	kfree_skb(skb);
+		release_sock(sk);
+                return (-EINVAL);
+        }
+
+	/* attach connection to a new socket. */
+        err = llc_ui_create(newsock, sk->protocol);
+        if(err)
+	{
+		release_sock(sk);
+                return (err);
+	}
+	newsk 				= newsock->sk;
+	newsk->pair			= NULL;
+	newsk->socket			= newsock;
+	newsk->sleep                    = &newsock->wait;
+	newsk->zapped			= 0;
+	newsk->state                    = TCP_ESTABLISHED;
+	newsock->state                  = SS_CONNECTED;
+        newsk->protinfo.af_llc->sap     = sk->protinfo.af_llc->sap;
+	newsk->protinfo.af_llc->dev	= sk->protinfo.af_llc->handle->local_dev;
+	newsk->protinfo.af_llc->link_no = sk->protinfo.af_llc->handle->link_no;
+        newsk->protinfo.af_llc->handle  = sk->protinfo.af_llc->handle;
+	sk->protinfo.af_llc->handle     = NULL;
+	llc_ui_insert_socket(newsk);
+
+	llc_ui_debug(5, "newsk: %p has link_no (%d)\n", 
+		newsk, newsk->protinfo.af_llc->handle->link_no);
+
+	/* put orignal socket back into a clean listen state. */
+	sk->state = TCP_LISTEN;
+	sk->ack_backlog--;
+	release_sock(sk);
+	kfree_skb(skb);
+
+        return (0);
+}
+
+/* 
+ * Function : llc_ui_recvmsg
+ * 
+ * Description :
+ *  Copy received data to the socket user.
+ *
+ * Parameters :
+ *  sock : Socket to copy data from.
+ *  msg : Various user space related information.
+ *  size : Size of user buffer.
+ *  flags : User specified flags.
+ *  scm : Unknown.
+ *
+ * Returns :
+ *  non-negative, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+        int flags, struct scm_cookie *scm)
+{
+        struct sock *sk = sock->sk;
+	struct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;
+	struct sockaddr_llc saddr;
+	struct sk_buff *skb;
+	int err = 0, copied = 0;
+	int noblock = flags&MSG_DONTWAIT;
+
+        llc_ui_debug(10, "start %p\n", sk);
+
+        skb = skb_recv_datagram(sk, flags, noblock, &err);
+        if(skb == NULL)
+                return err;
+	if(skb->len < sizeof(struct sockaddr_llc))
+		goto dgram_free;
+
+	/* remove saved sllc header. */
+	memcpy(&saddr, skb->head, sizeof(struct sockaddr_llc));
+	skb_pull(skb, sizeof(struct sockaddr_llc));
+
+	llc_ui_debug(10, "dsap (%02X) ssap (%02X)\n", saddr.sllc_dsap, saddr.sllc_ssap);
+
+        copied = skb->len;
+        if(copied > size) 
+	{
+        	copied = size;
+                msg->msg_flags |= MSG_TRUNC;
+        }
+
+        err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
+	if(!err)
+	{
+		if(uaddr)
+			memcpy(uaddr, &saddr, sizeof(*uaddr));
+		msg->msg_namelen = sizeof(*uaddr);
+	}
+
+dgram_free:
+	skb_free_datagram(sk, skb);     /* Free the datagram. */
+        return (err ? err : copied);
+}
+
+/*
+ * Function : llc_ui_sendmsg
+ *
+ * Description :
+ *  Transmit data provided by the socket user.
+ *
+ * Parameters :
+ *  sock : Socket to transmit data from.
+ *  msg : Various user related information.
+ *  len : Length of data to transmit.
+ *  scm : Unknown.
+ *
+ * Returns :
+ *  non-negative, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_sendmsg(struct socket *sock, struct msghdr *msg, int len,
+        struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = sk->protinfo.af_llc;
+        struct sockaddr_llc *addr = (struct sockaddr_llc *)msg->msg_name;
+        int flags = msg->msg_flags;
+	struct net_device *dev;
+        struct sk_buff *skb;
+        int err = 0, size = 0;
+
+        llc_ui_debug(10, "start %p\n", sk);
+
+        if(flags & ~MSG_DONTWAIT)
+                return (-EINVAL);
+        if(msg->msg_namelen < sizeof(struct sockaddr_llc))
+                return (-EINVAL);
+
+	if(addr->sllc_family != AF_LLC)
+                return (-EINVAL);
+	if(addr->sllc_arphrd != ARPHRD_ETHER && addr->sllc_arphrd != ARPHRD_IEEE802)
+		return (-EINVAL);
+
+	/* must bind connection to sap if user hasn't done it. */
+        if(sk->zapped)
+        {
+		/* bind to sap with null dev, exclusive. */
+                err = llc_ui_autobind(sock, addr);
+                if(err < 0)
+                {
+                        sock->state = SS_UNCONNECTED;
+                        sk->state   = TCP_CLOSE;
+                        return (err);
+                }
+        }
+
+	if(!llc->dev)
+	{
+        	rtnl_lock();
+        	dev = dev_getbyhwaddr(addr->sllc_arphrd, addr->sllc_smac);
+        	rtnl_unlock();
+        	if(dev == NULL)
+        	        return (-ENETUNREACH);
+	}
+	else
+		dev = llc->dev;
+
+	size = dev->hard_header_len + len + llc_ui_header_len(sk, addr);
+	if(size > dev->mtu)
+		return (-EMSGSIZE);
+        skb = sock_alloc_send_skb(sk, size, flags&MSG_DONTWAIT, &err);
+        if(skb == NULL)
+                return (err);
+	skb->sk  = sk;
+        skb->dev = dev;
+        skb_reserve(skb, dev->hard_header_len);
+	skb_reserve(skb, llc_ui_header_len(sk, addr));
+        err = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+
+	if(addr->sllc_test)
+		err = llc_ui_send_llc1(llc->sap, skb, addr, P8022_TEST_PRIM);
+	else
+	{
+		if(addr->sllc_xid)
+			err = llc_ui_send_llc1(llc->sap, skb, addr, P8022_XID_PRIM);
+		else
+		{
+			if(sk->type == SOCK_DGRAM || addr->sllc_ua)
+				err = llc_ui_send_llc1(llc->sap, skb, 
+					addr, P8022_DATAUNIT_PRIM);
+			if(sk->type == SOCK_STREAM && !addr->sllc_ua)
+			{
+				if(llc->handle)
+					err = llc_ui_send_data(llc->sap, llc->handle, 
+						skb, addr);
+				else
+					err = -ENOTCONN;
+			}
+		}
+	}
+	if(err < 0)
+		skb_free_datagram(sk, skb);
+
+        return (err ? err : len);
+}
+
+/*
+ * Function : llc_ui_getname
+ *
+ * Description :
+ *  Return the address information of a socket.
+ *
+ * Parameters :
+ *  sock : Socket to get address of.
+ *  uaddr : Address structure to return information.
+ *  uaddr_len : Length of address structure.
+ *  peer : Does user want local or remote address information.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
+        int *uaddr_len, int peer)
+{
+	struct sockaddr_llc sllc;
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = sk->protinfo.af_llc;
+
+        *uaddr_len = sizeof(struct sockaddr_llc);
+	memset(uaddr, 0, *uaddr_len);
+	if(sk->zapped)
+		return (0);
+	if(peer)
+	{
+		if(sk->state != TCP_ESTABLISHED)
+			return (-ENOTCONN);
+		sllc.sllc_arphrd = llc->dev->type;
+		sllc.sllc_dsap	 = llc->handle->remote_dl_addr.lsap;
+		memcpy(&sllc.sllc_dmac, &llc->handle->remote_dl_addr.mac, IFHWADDRLEN);
+	}
+	else
+	{
+		if(!llc->sap)
+			return (-EINVAL);
+		sllc.sllc_ssap = llc->sap->local_dl_addr.lsap;
+
+		if(llc->dev)
+		{
+			sllc.sllc_arphrd = llc->dev->type;
+			memcpy(&sllc.sllc_smac, &llc->dev->dev_addr, IFHWADDRLEN);
+		}
+	}
+
+	sllc.sllc_family = AF_LLC;
+        memcpy(uaddr, &sllc, sizeof(sllc));
+
+        return (0);
+}
+
+/*
+ * Function : llc_ui_setsockopt
+ *
+ * Description :
+ *  Set various connection specific parameters.
+ *
+ * Parameters :
+ *  sock : Socket to set options on.
+ *  level : Socket level user is requesting operations on.
+ *  optname : Operation name.
+ *  optval : User provided operation data.
+ *  optlen : Length of optval.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_setsockopt(struct socket *sock, int level, int optname, 
+	char *optval, int optlen)
+{
+        struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = sk->protinfo.af_llc;
+        int err, opt;
+
+	if(level != SOL_LLC)
+                return (-EINVAL);
+	if(sk->type != SOCK_STREAM)
+		return (-EINVAL);
+	if(!llc->handle)
+		return (-ENOTCONN);
+	if(optlen != sizeof(int))
+                return (-EINVAL);
+        err = get_user(opt, (int *)optval);
+        if(err)
+                return (err);
+
+	lock_sock(sk);
+        switch(optname)
+	{
+	        case (LLC_RETRY):
+                	if(opt > LLC_MAX_RETRY)
+                        	return (-EINVAL);
+			llc->handle->n2 = opt;
+			break;
+
+		case (LLC_SIZE):
+                	if(opt > LLC_MAX_SIZE)
+                        	return (-EINVAL);
+			llc->handle->n1 = opt;
+			break;
+
+		case (LLC_ACK_TIMER_EXPIRE):
+                	if(opt > LLC_MAX_ACK_TIMER_EXPIRE)
+                        	return (-EINVAL);
+			llc->handle->ack_expire = opt;
+			break;
+
+		case (LLC_P_TIMER_EXPIRE):
+			if(opt > LLC_MAX_P_TIMER_EXPIRE)
+                        	return (-EINVAL);
+			llc->handle->pf_cycle_expire = opt;
+			break;
+
+		case (LLC_REJ_TIMER_EXPIRE):
+                	if(opt > LLC_MAX_REJ_TIMER_EXPIRE)
+                        	return (-EINVAL);
+			llc->handle->reject_sent_expire = opt;
+			break;
+
+		case (LLC_BUSY_TIMER_EXPIRE):
+                	if(opt > LLC_MAX_BUSY_TIMER_EXPIRE)
+                        	return (-EINVAL);
+			llc->handle->busy_state_expire = opt;
+			break;
+
+                default:
+			release_sock(sk);
+                        return (-ENOPROTOOPT);
+        }
+
+	release_sock(sk);
+        return (0);
+}
+
+/*
+ * Function : llc_ui_getsockopt
+ *
+ * Description :
+ *  Get connection specific socket information.
+ *
+ * Parameters :
+ *  sock : Socket to get information from.
+ *  level : Socket level user is requesting operations on.
+ *  optname : Operation name.
+ *  optval : Variable to return operation data in.
+ *  optlen : Length of optval.
+ *
+ * Returns :
+ *  0, upon success.
+ *  negative, upon failure.
+ */
+static int llc_ui_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+        struct sock *sk = sock->sk;
+        struct llc_ui_opt *llc = sk->protinfo.af_llc;
+        int val = 0, len = 0;
+                                
+        if(level != SOL_LLC)
+                return (-EINVAL);
+        if(sk->type != SOCK_STREAM)
+                return (-EINVAL);
+        if(!llc->handle)
+                return (-ENOTCONN);
+	if(get_user(len, optlen))
+		return (-EFAULT);
+        if(len != sizeof(int))
+                return (-EINVAL);
+
+        switch(optname)
+        {
+		case (LLC_RETRY):
+			val = llc->handle->n2;
+			break;
+
+		case (LLC_SIZE):
+			val = llc->handle->n1;
+			break;
+
+		case (LLC_ACK_TIMER_EXPIRE):
+			val = llc->handle->ack_expire;
+			break;
+
+		case (LLC_P_TIMER_EXPIRE):
+			val = llc->handle->pf_cycle_expire;
+			break;
+
+		case (LLC_REJ_TIMER_EXPIRE):
+			val = llc->handle->reject_sent_expire;
+			break;
+
+		case (LLC_BUSY_TIMER_EXPIRE):
+			val = llc->handle->busy_state_expire;
+			break;
+
+                default:
+                        return (-ENOPROTOOPT);
+        }
+
+        if(put_user(len, optlen))
+                return (-EFAULT);
+        if(copy_to_user(optval, &val, len))
+                return (-EFAULT);
+
+        return (0);
+}
+
+/*                              
+ * Function : llc_ui_indicate
+ *
+ * Description :        
+ *  LLC user interface hook into the LLC layer, every llc_ui sap references
+ *  this function as its indicate handler.
+ *
+ * Parameters :
+ *  prim : Primative block provided by the llc layer.
+ *
+ * Returns :
+ *  Always 0 to indicate reception of primative.
+ */
+static int llc_ui_indicate(struct prim_if_block *prim)
+{
+        struct sockaddr_llc *llc;
+        struct sk_buff *skb, *skb2;
+        struct sock *sk;
+
+        llc_ui_debug(5, "start %d\n", prim->primitive);
+
+        switch(prim->primitive) {
+                case (P8022_TEST_PRIM):
+                {
+                        prim_test_t *prim_data = (prim_test_t *)prim->data;
+                        sk = llc_ui_find_socket_by_addr(&prim_data->dest_addr);
+                        if(!sk)
+                                return (0);
+
+                        llc_ui_debug(5, "test_prim %p\n", sk);
+                        skb = prim->data->test.skb;
+                        skb2 = skb_copy_expand(skb, sizeof(struct sockaddr_llc), 0, GFP_ATOMIC);
+                        if(!skb2)
+                                return (0);
+
+                        /* save primitive for use by the user. (pulled in recvmsg) */
+                        llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(struct sockaddr_llc));
+                        llc->sllc_family = AF_LLC;
+                        llc->sllc_arphrd = skb->dev->type;
+                        llc->sllc_test   = 1;
+                        llc->sllc_xid    = 0;
+                        llc->sllc_ua     = 0;
+                        llc->sllc_dsap = prim_data->dest_addr.lsap;
+                        memcpy(llc->sllc_dmac, prim_data->dest_addr.mac,
+                                IFHWADDRLEN);
+                        llc->sllc_ssap = prim_data->source_addr.lsap;
+                        memcpy(llc->sllc_smac, prim_data->source_addr.mac,
+                                IFHWADDRLEN);
+
+                        /* queue skb to the user. */
+                        skb2->sk = sk;
+                        if(sock_queue_rcv_skb(sk, skb2) < 0)
+                                kfree_skb(skb2);
+                        break;
+                }
+
+		/* has no skb attched. */
+                case (P8022_XID_PRIM):
+                {
+                        prim_xid_t *prim_data = (prim_xid_t *)prim->data;
+                        sk = llc_ui_find_socket_by_addr(&prim_data->dest_addr);
+                        if(!sk)
+                                return (0);
+
+                        llc_ui_debug(5, "xid_prim %p\n", sk);
+			skb2 = alloc_skb(sizeof(struct sockaddr_llc) + 1, GFP_ATOMIC);
+                        if(!skb2)
+                                return (0);
+
+                        /* save primitive for use by the user. (pulled in recvmsg) */
+                        llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(struct sockaddr_llc));
+                        llc->sllc_family = AF_LLC;
+                        llc->sllc_arphrd = 0;
+                        llc->sllc_test   = 0;
+                        llc->sllc_xid    = 1;
+                        llc->sllc_ua     = 0;
+                        llc->sllc_dsap = prim_data->dest_addr.lsap;
+                        memcpy(llc->sllc_dmac, prim_data->dest_addr.mac,
+                                IFHWADDRLEN);
+                        llc->sllc_ssap = prim_data->source_addr.lsap;
+                        memcpy(llc->sllc_smac, prim_data->source_addr.mac,
+                                IFHWADDRLEN);
+
+                        /* queue skb to the user. */
+                        skb2->sk = sk;
+                        if(sock_queue_rcv_skb(sk, skb2) < 0)
+                                kfree_skb(skb2);
+                        break;
+                }
+
+                case (P8022_DATAUNIT_PRIM):
+                {
+                        prim_unit_data_t *prim_data = (prim_unit_data_t *)prim->data;
+                        sk = llc_ui_find_socket_by_addr(&prim_data->dest_addr);
+                        if(!sk)
+                                return (0);
+
+                        llc_ui_debug(5, "dataunit_prim %p\n", sk);
+                        skb = prim->data->udata.skb;
+                        skb2 = skb_copy_expand(skb, sizeof(struct sockaddr_llc), 0, GFP_ATOMIC);
+                        if(!skb2)
+                                return (0);
+
+                        /* save primitive for use by the user. (pulled in recvmsg) */
+                        llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(struct sockaddr_llc));
+                        llc->sllc_family = AF_LLC;
+                        llc->sllc_arphrd = skb->dev->type;
+                        llc->sllc_test   = 0;
+                        llc->sllc_xid    = 0;
+                        llc->sllc_ua     = 1;
+                        llc->sllc_dsap = prim_data->dest_addr.lsap;
+                        memcpy(llc->sllc_dmac, prim_data->dest_addr.mac,
+                                IFHWADDRLEN);
+                        llc->sllc_ssap = prim_data->source_addr.lsap;
+                        memcpy(llc->sllc_smac, prim_data->source_addr.mac,
+                                IFHWADDRLEN);
+
+                        /* queue skb to the user. */
+                        skb2->sk = sk;
+                        if(sock_queue_rcv_skb(sk, skb2) < 0)
+                                kfree_skb(skb2);
+                        break;
+                }
+
+                case (P8022_CONNECT_PRIM):
+                {
+                        prim_connect_t *prim_data = (prim_connect_t *)prim->data;
+			prim_data->connection->local_dl_addr.lsap 
+				= prim->sap->local_dl_addr.lsap;
+			sk = llc_ui_find_socket_by_addr(&prim_data->connection->local_dl_addr);
+                        if(!sk)
+                                return (0);
+
+                        llc_ui_debug(5, "connect_prim %p\n", sk);
+                        if(sk->type != SOCK_STREAM || sk->state != TCP_LISTEN)
+                                return (0);
+                        if(prim->data->conn.status)
+				return (0);	/* bad status. */
+
+                        sk->protinfo.af_llc->handle = prim_data->connection;
+                        if(!sk->protinfo.af_llc->handle)
+				return (0);	/* this should never happen. */
+
+                        /* give this connection a link number. */
+                        prim_data->connection->link_no
+                                = llc_ui_next_link_no(prim_data->connection->local_dl_addr.lsap);
+                        skb2 = alloc_skb(0, GFP_ATOMIC);
+                        if(!skb2)
+                                return (0);
+                        skb2->sk = sk;
+                        skb_queue_tail(&sk->receive_queue, skb2);
+                        sk->state_change(sk);
+                        break;
+                }
+
+                case (P8022_DATA_PRIM):
+                {
+                        prim_data_t *prim_data = (prim_data_t *)prim->data;
+                        sk = llc_ui_find_socket_by_link_no(prim->sap, prim_data->link_no);
+                        if(!sk)
+                                return (0);
+                        
+                        llc_ui_debug(5, "data_prim %p\n", sk);
+                        if(sk->type != SOCK_STREAM || (sk->state != TCP_ESTABLISHED
+                                && sk->state != TCP_LISTEN))
+				return (0);
+                        
+                        skb = prim->data->data.skb; 
+                        skb2 = skb_copy_expand(skb, sizeof(struct sockaddr_llc), 0, GFP_ATOMIC);
+                        if(!skb2)
+                                return (0);
+                                
+                        /* save primitive for use by the user. (pulled in recvmsg) */
+                        llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(struct sockaddr_llc));
+                        llc->sllc_family = AF_LLC; 
+                        llc->sllc_arphrd = skb->dev->type;
+                        llc->sllc_test   = 0;
+                        llc->sllc_xid    = 0;
+                        llc->sllc_ua     = 0;
+			llc->sllc_dsap	 = sk->protinfo.af_llc->sap->local_dl_addr.lsap;
+                        memcpy(llc->sllc_dmac, prim_data->connection->local_dl_addr.mac,
+                                IFHWADDRLEN);
+                        llc->sllc_ssap = prim_data->connection->remote_dl_addr.lsap;
+                        memcpy(llc->sllc_smac, prim_data->connection->remote_dl_addr.mac,
+                                IFHWADDRLEN);
+                        
+                        /* queue skb to the user. */
+                        skb2->sk = sk;
+                        if(sock_queue_rcv_skb(sk, skb2) < 0)
+                                kfree_skb(skb2);
+                        break;
+                }
+                
+                case (P8022_DISCONNECT_PRIM):
+                {       
+                        prim_disconnect_t *prim_data = (prim_disconnect_t *)prim->data;
+                        sk = llc_ui_find_socket_by_link_no(prim->sap, prim_data->link_no);
+                        if(!sk)
+                                return (0);
+
+                        llc_ui_debug(5, "disconnect_prim %p\n", sk);
+                        if(sk->type != SOCK_STREAM || (sk->state != TCP_ESTABLISHED
+                                && sk->state != TCP_LISTEN))
+				return (0);
+
+                        sk->protinfo.af_llc->handle     = NULL;
+                        sk->socket->state               = SS_UNCONNECTED;
+                        sk->state                       = TCP_CLOSE;
+                        if(!sk->dead)
+                        {
+                                sk->state_change(sk);
+                                sk->dead = 1;
+                        }
+                        break;
+                }
+
+                case (P8022_RESET_PRIM):
+                        break;
+
+                case (P8022_FLOWCONTROL_PRIM):
+                        break;
+
+                default:
+                        break;
+        }
+
+        return (0);
+}
+
+/*
+ * Function : llc_ui_confirm
+ *
+ * Description :
+ *  LLC user interface hook into the LLC layer, every llc_ui sap references
+ *  this function as its confirm handler.
+ *
+ * Parameters :
+ *  prim : Primative block provided by the llc layer.
+ *
+ * Returns :
+ *  Always 0 to indicate reception of primative.
+ */
+static int llc_ui_confirm(struct prim_if_block *prim)
+{
+        struct sock *sk;
+
+        llc_ui_debug(5, "start %d\n", prim->primitive);
+
+        switch(prim->primitive) {
+                case (P8022_CONNECT_PRIM):
+                {
+                        prim_connect_t *prim_data = (prim_connect_t *)prim->data;
+			sk = llc_ui_find_socket_by_addr(&prim_data->connection->local_dl_addr);
+                        if(!sk)
+                                return (0);
+
+                        llc_ui_debug(5, "connect_prim %p\n", sk);
+                        if(sk->type != SOCK_STREAM || sk->state != TCP_SYN_SENT)
+				return (0);
+
+                        if(!prim->data->conn.status)
+                        {
+                                sk->socket->state       = SS_CONNECTED;
+                                sk->state               = TCP_ESTABLISHED;
+                                sk->protinfo.af_llc->handle = prim_data->connection;
+                        }
+                        else
+                        {
+                                sk->socket->state       = SS_UNCONNECTED;
+                                sk->state               = TCP_CLOSE;
+				sk->protinfo.af_llc->handle = NULL;
+                        }
+                        sk->state_change(sk);
+                        wake_up_interruptible(sk->sleep);
+                        break;
+                }
+
+                case (P8022_DATA_PRIM):
+                        break;
+
+                case (P8022_DISCONNECT_PRIM):
+                {
+                        prim_disconnect_t *prim_data = (prim_disconnect_t *)prim->data;
+                        sk = llc_ui_find_socket_by_link_no(prim->sap, prim_data->link_no);
+                        if(!sk)
+                                return (0);
+
+                        llc_ui_debug(5, "disconnect_prim %p\n", sk);
+                        if(sk->type != SOCK_STREAM || sk->state != TCP_CLOSING)
+				return (0);
+                        sk->protinfo.af_llc->handle 	= NULL;
+                        sk->socket->state 		= SS_UNCONNECTED;
+                        sk->state 			= TCP_CLOSE;
+                        sk->state_change(sk);
+                        wake_up_interruptible(sk->sleep);
+                        break;
+                }
+
+                case (P8022_RESET_PRIM):
+                        break;
+
+                default:
+                        break;
+        }
+
+        return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+/*
+ * Function : llc_ui_get_info
+ *
+ * Description :
+ *  Return the output of the local llc ui socket list to the caller.
+ *
+ * Parameters :
+ *  buffer : none.
+ *  start  : none.
+ *  offset : none.
+ *  length : none.
+ *
+ * Returns:
+ *  Length of data wrote to buffer.
+ */
+static int llc_ui_get_info(char *buffer, char **start, off_t offset, int length)
+{       
+        off_t pos = 0;
+        off_t begin = 0; 
+        int len = sprintf(buffer, "SocketID type local_mac_sap          remote_mac_sap         tx_queue "
+                                  "rx_queue st uid link_no\n");
+        struct sock *s;
+
+        /* Output the LLC socket data for the /proc filesystem */
+        spin_lock_bh(&llc_ui_sockets_lock);
+        for(s = llc_ui_sockets; s != NULL; s = s->next) 
+	{
+		struct llc_ui_opt *llc = s->protinfo.af_llc;
+		len += sprintf(buffer + len, "%p ", s);
+		len += sprintf(buffer + len, "%02X   ", s->type);
+		if(llc->sap)
+		{
+			if(llc->dev)
+				len += sprintf(buffer + len, 
+					"%02X:%02X:%02X:%02X:%02X:%02X",
+					llc->dev->dev_addr[0],
+					llc->dev->dev_addr[1],
+					llc->dev->dev_addr[2],
+					llc->dev->dev_addr[3],
+					llc->dev->dev_addr[4],
+					llc->dev->dev_addr[5]);
+			else
+				len += sprintf(buffer + len, 
+                                        "%02X:%02X:%02X:%02X:%02X:%02X",
+                                        0, 0, 0, 0, 0, 0);
+			len += sprintf(buffer + len, "@0x%02X ", 
+				llc->sap->local_dl_addr.lsap);
+		}
+		else
+			len += sprintf(buffer + len,
+                	        "%02X:%02X:%02X:%02X:%02X:%02X@0x%02X ",
+                                0, 0, 0, 0, 0, 0, 0);
+		if(llc->handle)
+		{
+			len += sprintf(buffer + len, 
+	                        "%02X:%02X:%02X:%02X:%02X:%02X@0x%02X ",
+                                llc->handle->remote_dl_addr.mac[0],
+                                llc->handle->remote_dl_addr.mac[1],
+                                llc->handle->remote_dl_addr.mac[2],
+                                llc->handle->remote_dl_addr.mac[3],
+                                llc->handle->remote_dl_addr.mac[4],
+                                llc->handle->remote_dl_addr.mac[5],
+				llc->handle->remote_dl_addr.lsap);
+		}
+		else
+			len += sprintf(buffer + len,
+                                "%02X:%02X:%02X:%02X:%02X:%02X@0x%02X ",
+                                0, 0, 0, 0, 0, 0, 0);
+		len += sprintf(buffer + len, "%08X:%08X ",
+                               atomic_read(&s->wmem_alloc),
+                               atomic_read(&s->rmem_alloc));
+		len += sprintf(buffer + len,"%02X %-3d ", s->state,
+                               SOCK_INODE(s->socket)->i_uid);
+		if(llc->handle)
+			len += sprintf(buffer + len, "%-7d\n", llc->handle->link_no);
+		else
+			len += sprintf(buffer + len, "no_link\n");
+
+		/* Are we still dumping unwanted data then discard the record */
+                pos = begin + len;
+
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+                        begin = pos;
+                }
+                if (pos > offset + length)      /* We have dumped enough */
+                        break;
+        }
+        spin_unlock_bh(&llc_ui_sockets_lock);
+
+	/* The data in question runs from begin to begin+len */
+        *start = buffer + offset - begin;       /* Start of wanted data */
+        len -= offset - begin;	/* Remove unwanted header data from length */
+        if(len > length)
+                len = length;	/* Remove unwanted tail data from length */
+
+        return (len);
+}
+#endif /* CONFIG_PROC_FS */
+
+static struct net_proto_family llc_ui_family_ops =
+{
+        PF_LLC,
+        llc_ui_create
+};
+
+static struct proto_ops SOCKOPS_WRAPPED(llc_ui_ops) =
+{
+        family:		PF_LLC,
+        release:	llc_ui_release,
+        bind:		llc_ui_bind,
+        connect:	llc_ui_connect,
+        socketpair:	sock_no_socketpair,
+        accept:		llc_ui_accept,
+        getname:	llc_ui_getname,
+        poll:		datagram_poll,
+        ioctl:		sock_no_ioctl,
+        listen:		llc_ui_listen,
+        shutdown:	llc_ui_shutdown,
+        setsockopt:	llc_ui_setsockopt,
+        getsockopt:	llc_ui_getsockopt,
+        sendmsg:	llc_ui_sendmsg,
+        recvmsg:	llc_ui_recvmsg,
+        mmap:		sock_no_mmap,
+	sendpage:	sock_no_sendpage,
+};
+
+#include <linux/smp_lock.h>
+SOCKOPS_WRAP(llc_ui, PF_LLC);
+
+int llc_ui_init(void)
+{
+	int i;
+	for(i = 0; i < 256; i++)
+		llc_ui_sap_link_no_max[i] = 0;
+	(void)sock_register(&llc_ui_family_ops);
+
+#ifdef CONFIG_PROC_FS
+	proc_net_create("llc", 0, llc_ui_get_info);
+#endif /* CONFIG_PROC_FS */
+
+	printk(KERN_INFO "NET4.0 IEEE 802.2 User Interface SAPs, Jay Schulist, 2001\n");
+	return (0);
+}
+
+void llc_ui_exit(void)
+{
+#ifdef CONFIG_PROC_FS
+	proc_net_remove("llc");
+#endif /* CONFIG_PROC_FS */
+	sock_unregister(PF_LLC);
+	return;
+}
diff -ruN linux-2.4.9/net/Config.in linux/net/Config.in
--- linux-2.4.9/net/Config.in	Sun Sep  9 11:56:30 2001
+++ linux/net/Config.in	Thu Sep 13 11:08:35 2001
@@ -64,6 +64,7 @@
    tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
    tristate 'ANSI/IEEE 802.2 Data link layer protocol' CONFIG_LLC
    if [ "$CONFIG_LLC" != "n" ]; then
+      bool '  ANSI/IEEE 802.2 Data link layer User Interface SAPs' CONFIG_LLC_UI
       tristate 'The NETBEUI protocol' CONFIG_NETBEUI
    fi
    bool 'Frame Diverter (EXPERIMENTAL)' CONFIG_NET_DIVERT
diff -ruN linux-2.4.9/net/netsyms.c linux/net/netsyms.c
--- linux-2.4.9/net/netsyms.c	Sun Sep  9 12:26:12 2001
+++ linux/net/netsyms.c	Thu Sep 13 11:08:35 2001
@@ -468,6 +468,7 @@
 EXPORT_SYMBOL(__dev_get_by_index);
 EXPORT_SYMBOL(dev_get_by_name);
 EXPORT_SYMBOL(__dev_get_by_name);
+EXPORT_SYMBOL(dev_getbyhwaddr);
 EXPORT_SYMBOL(netdev_finish_unregister);
 EXPORT_SYMBOL(netdev_set_master);
 EXPORT_SYMBOL(eth_type_trans);
